<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://facebook.github.io/react/"

    >react-test-renderer (v15.5.4)</a>
</h1>
<h4>React package for snapshot testing.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer">module react-test-renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>CallbackQueue
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>DOMLazyTree
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>FallbackCompositionState
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMEmptyComponent
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextComponent
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(useCreateElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRenderingTransaction
            <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerUpdateQueue
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactSimpleEmptyComponent
            <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestEmptyComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestReconcileTransaction
            <span class="apidocSignatureSpan">(testOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestTextComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderSyntheticEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticAnimationEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticClipboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticCompositionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticDragEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticEvent
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticFocusEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticInputEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticKeyboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticMouseEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTouchEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTransitionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticUIEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticWheelEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.create">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>create
            <span class="apidocSignatureSpan">(nextElement, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>shallow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.unstable_batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>unstable_batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.validateDOMNesting">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>validateDOMNesting
            <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>AutoFocusUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>BeforeInputEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>CSSPropertyOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>CallbackQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ChangeEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>DOMChildrenOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>DOMProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>DOMPropertyOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>Danger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>EnterLeaveEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>EventPluginHub</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>EventPluginRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>EventPluginUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>EventPropagators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>FallbackCompositionState.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>HTMLDOMPropertyConfig</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>KeyEscapeUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>LinkedValueUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>PooledClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactBrowserEventEmitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactChildFiber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactChildReconciler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactComponentBrowserEnvironment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactComponentEnvironment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactCompositeComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactCoroutine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponentTree</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMEmptyComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMIDOperations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMInput</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMInvalidARIAHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMNullInputValuePropHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMOption</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMSelect</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMSelection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextarea</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTreeTraversal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMUnknownPropertyHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDebugTool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDefaultBatchingStrategy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDefaultInjection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactEmptyComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactErrorUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactEventEmitterMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactEventListener</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactFiber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactFiberRoot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactFiberUpdateQueue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactHostComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactHostOperationHistoryHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactInputSelection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactInstanceMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactInvalidSetStateWarningHook</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactMarkupChecksum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactMount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactNodeTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactOwner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactPerf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconcileTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconciler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactRef</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReifiedYield</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerBatchingStrategy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRendering</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRenderingTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerUpdateQueue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactSimpleEmptyComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestEmptyComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestMount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestReconcileTransaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestRenderer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestTextComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactUpdateQueue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ReactUpdates</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderSyntheticEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderTouchHistoryStore</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SelectEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SimpleEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticAnimationEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticClipboardEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticCompositionEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticDragEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticFocusEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticInputEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticKeyboardEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticMouseEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTouchEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTransitionEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticUIEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticWheelEvent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>TapEventPlugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>TouchHistoryMath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>Transaction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>ViewportMetrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.</span>shallow.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.AutoFocusUtils">module react-test-renderer.AutoFocusUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.AutoFocusUtils.focusDOMComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.AutoFocusUtils.</span>focusDOMComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.BeforeInputEventPlugin">module react-test-renderer.BeforeInputEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.BeforeInputEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.BeforeInputEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.BeforeInputEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.CSSPropertyOperations">module react-test-renderer.CSSPropertyOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CSSPropertyOperations.createMarkupForStyles">
            function <span class="apidocSignatureSpan">react-test-renderer.CSSPropertyOperations.</span>createMarkupForStyles
            <span class="apidocSignatureSpan">(styles, component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CSSPropertyOperations.setValueForStyles">
            function <span class="apidocSignatureSpan">react-test-renderer.CSSPropertyOperations.</span>setValueForStyles
            <span class="apidocSignatureSpan">(node, styles, component)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.CallbackQueue">module react-test-renderer.CallbackQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.CallbackQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>CallbackQueue
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.release">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.CallbackQueue.prototype">module react-test-renderer.CallbackQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.enqueue">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.notifyAll">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>notifyAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.reset">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.rollback">
            function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>rollback
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ChangeEventPlugin">module react-test-renderer.ChangeEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ChangeEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.ChangeEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ChangeEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.DOMChildrenOperations">module react-test-renderer.DOMChildrenOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>dangerouslyReplaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMChildrenOperations.processUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>processUpdates
            <span class="apidocSignatureSpan">(parentNode, updates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMChildrenOperations.replaceDelimitedText">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>replaceDelimitedText
            <span class="apidocSignatureSpan">(openingComment, closingComment, stringText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.DOMLazyTree">module react-test-renderer.DOMLazyTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.DOMLazyTree">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>DOMLazyTree
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.insertTreeBefore">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>insertTreeBefore
            <span class="apidocSignatureSpan">(parentNode, tree, referenceNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.queueChild">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueChild
            <span class="apidocSignatureSpan">(parentTree, childTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.queueHTML">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueHTML
            <span class="apidocSignatureSpan">(tree, html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.queueText">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueText
            <span class="apidocSignatureSpan">(tree, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMLazyTree.replaceChildWithTree">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>replaceChildWithTree
            <span class="apidocSignatureSpan">(oldNode, newTree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.DOMProperty">module react-test-renderer.DOMProperty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMProperty.isCustomAttribute">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>isCustomAttribute
            <span class="apidocSignatureSpan">(attributeName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>_isCustomAttributeFunctions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>getPossibleStandardName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>injection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>properties</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>ATTRIBUTE_NAME_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>ATTRIBUTE_NAME_START_CHAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>ID_ATTRIBUTE_NAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>ROOT_ATTRIBUTE_NAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.DOMPropertyOperations">module react-test-renderer.DOMPropertyOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForCustomAttribute">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForCustomAttribute
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForID">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForProperty">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForProperty
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForRoot">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForAttribute">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>deleteValueForAttribute
            <span class="apidocSignatureSpan">(node, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForProperty">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>deleteValueForProperty
            <span class="apidocSignatureSpan">(node, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForID">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setAttributeForID
            <span class="apidocSignatureSpan">(node, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForRoot">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setAttributeForRoot
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForAttribute">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setValueForAttribute
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForProperty">
            function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setValueForProperty
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.Danger">module react-test-renderer.Danger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Danger.dangerouslyReplaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.Danger.</span>dangerouslyReplaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.EnterLeaveEventPlugin">module react-test-renderer.EnterLeaveEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EnterLeaveEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.EnterLeaveEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EnterLeaveEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.EventPluginHub">module react-test-renderer.EventPluginHub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.__getListenerBank">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>__getListenerBank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.__purge">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>__purge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.deleteAllListeners">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>deleteAllListeners
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.deleteListener">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>deleteListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.enqueueEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>enqueueEvents
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.getListener">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>getListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.processEventQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>processEventQueue
            <span class="apidocSignatureSpan">(simulated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginHub.putListener">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>putListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.EventPluginRegistry">module react-test-renderer.EventPluginRegistry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginRegistry._resetEventPlugins">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>_resetEventPlugins
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginRegistry.getPluginModuleForEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>getPluginModuleForEvent
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginOrder">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>injectEventPluginOrder
            <span class="apidocSignatureSpan">(injectedEventPluginOrder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginsByName">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>injectEventPluginsByName
            <span class="apidocSignatureSpan">(injectedNamesToPlugins)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>eventNameDispatchConfigs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>possibleRegistrationNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>registrationNameDependencies</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>registrationNameModules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.EventPluginUtils">module react-test-renderer.EventPluginUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDirectDispatch">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDirectDispatch
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrder">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDispatchesInOrder
            <span class="apidocSignatureSpan">(event, simulated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrderStopAtTrue">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDispatchesInOrderStopAtTrue
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.getInstanceFromNode">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.getLowestCommonAncestor">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getLowestCommonAncestor
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.getNodeFromInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getNodeFromInstance
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.getParentInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getParentInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.hasDispatches">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>hasDispatches
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.isAncestor">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isAncestor
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.isEndish">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isEndish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.isMoveish">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isMoveish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.isStartish">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isStartish
            <span class="apidocSignatureSpan">(topLevelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.traverseEnterLeave">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>traverseEnterLeave
            <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPluginUtils.traverseTwoPhase">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>traverseTwoPhase
            <span class="apidocSignatureSpan">(target, fn, arg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.EventPropagators">module react-test-renderer.EventPropagators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPropagators.accumulateDirectDispatches">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateDirectDispatches
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPropagators.accumulateEnterLeaveDispatches">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateEnterLeaveDispatches
            <span class="apidocSignatureSpan">(leave, enter, from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatches">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateTwoPhaseDispatches
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget">
            function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateTwoPhaseDispatchesSkipTarget
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.FallbackCompositionState">module react-test-renderer.FallbackCompositionState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.FallbackCompositionState">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>FallbackCompositionState
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.release">
            function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.FallbackCompositionState.prototype">module react-test-renderer.FallbackCompositionState.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getData">
            function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>getData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getText">
            function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.HTMLDOMPropertyConfig">module react-test-renderer.HTMLDOMPropertyConfig</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.HTMLDOMPropertyConfig.isCustomAttribute">
            function <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>isCustomAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>DOMAttributeNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>DOMMutationMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>DOMPropertyNames</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>Properties</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.KeyEscapeUtils">module react-test-renderer.KeyEscapeUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.KeyEscapeUtils.escape">
            function <span class="apidocSignatureSpan">react-test-renderer.KeyEscapeUtils.</span>escape
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.KeyEscapeUtils.unescape">
            function <span class="apidocSignatureSpan">react-test-renderer.KeyEscapeUtils.</span>unescape
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.LinkedValueUtils">module react-test-renderer.LinkedValueUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.LinkedValueUtils.checkPropTypes">
            function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>checkPropTypes
            <span class="apidocSignatureSpan">(tagName, props, owner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.LinkedValueUtils.executeOnChange">
            function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>executeOnChange
            <span class="apidocSignatureSpan">(inputProps, event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.LinkedValueUtils.getChecked">
            function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>getChecked
            <span class="apidocSignatureSpan">(inputProps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.LinkedValueUtils.getValue">
            function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>getValue
            <span class="apidocSignatureSpan">(inputProps)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.PooledClass">module react-test-renderer.PooledClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.PooledClass.addPoolingTo">
            function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>addPoolingTo
            <span class="apidocSignatureSpan">(CopyConstructor, pooler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.PooledClass.fourArgumentPooler">
            function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>fourArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.PooledClass.oneArgumentPooler">
            function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>oneArgumentPooler
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.PooledClass.threeArgumentPooler">
            function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>threeArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2, a3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.PooledClass.twoArgumentPooler">
            function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>twoArgumentPooler
            <span class="apidocSignatureSpan">(a1, a2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactBrowserEventEmitter">module react-test-renderer.ReactBrowserEventEmitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.ensureScrollValueMonitoring">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>ensureScrollValueMonitoring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.handleTopLevel">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.isEnabled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>isEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.listenTo">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>listenTo
            <span class="apidocSignatureSpan">(registrationName, contentDocumentHandle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.setEnabled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>setEnabled
            <span class="apidocSignatureSpan">(enabled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.supportsEventPageXY">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>supportsEventPageXY
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapBubbledEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>trapBubbledEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapCapturedEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>trapCapturedEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>ReactEventListener</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactChildFiber">module react-test-renderer.ReactChildFiber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildFiber.cloneChildFibers">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>cloneChildFibers
            <span class="apidocSignatureSpan">(current, workInProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibers">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>reconcileChildFibers
            <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibersInPlace">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>reconcileChildFibersInPlace
            <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactChildReconciler">module react-test-renderer.ReactChildReconciler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildReconciler.instantiateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>instantiateChildren
            <span class="apidocSignatureSpan">(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildReconciler.unmountChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>unmountChildren
            <span class="apidocSignatureSpan">(renderedChildren, safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactChildReconciler.updateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>updateChildren
            <span class="apidocSignatureSpan">(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactComponentBrowserEnvironment">module react-test-renderer.ReactComponentBrowserEnvironment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.processChildrenUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentBrowserEnvironment.</span>processChildrenUpdates
            <span class="apidocSignatureSpan">(parentInst, updates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentBrowserEnvironment.</span>replaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactComponentEnvironment">module react-test-renderer.ReactComponentEnvironment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactComponentEnvironment.processChildrenUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentEnvironment.</span>processChildrenUpdates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactComponentEnvironment.replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentEnvironment.</span>replaceNodeWithMarkup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactComponentEnvironment.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactCompositeComponent">module react-test-renderer.ReactCompositeComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._checkContextTypes">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_checkContextTypes
            <span class="apidocSignatureSpan">(typeSpecs, values, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_constructComponent
            <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponentWithoutOwner">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_constructComponentWithoutOwner
            <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._maskContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_maskContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._performComponentUpdate">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_performComponentUpdate
            <span class="apidocSignatureSpan">(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processChildContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processChildContext
            <span class="apidocSignatureSpan">(currentContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processPendingState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processPendingState
            <span class="apidocSignatureSpan">(props, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_renderValidatedComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_renderValidatedComponentWithoutOwnerOrContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._replaceNodeWithMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_replaceNodeWithMarkup
            <span class="apidocSignatureSpan">(oldHostNode, nextMarkup, prevInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent._updateRenderedComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_updateRenderedComponent
            <span class="apidocSignatureSpan">(transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.attachRef">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>attachRef
            <span class="apidocSignatureSpan">(ref, component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.construct">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>construct
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.detachRef">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>detachRef
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getName">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getPublicInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getPublicInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMount">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performInitialMount
            <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMountWithErrorHandling">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performInitialMountWithErrorHandling
            <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performUpdateIfNecessary">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performUpdateIfNecessary
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextElement, transaction, nextContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>unmountComponent
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCompositeComponent.updateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>updateComponent
            <span class="apidocSignatureSpan">(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_instantiateReactComponent</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactCoroutine">module react-test-renderer.ReactCoroutine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCoroutine.createCoroutine">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>createCoroutine
            <span class="apidocSignatureSpan">(children, handler, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCoroutine.createYield">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>createYield
            <span class="apidocSignatureSpan">(props, continuation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCoroutine.isCoroutine">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>isCoroutine
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactCoroutine.isYield">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>isYield
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">symbol <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>REACT_COROUTINE_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">symbol <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>REACT_YIELD_TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOM">module react-test-renderer.ReactDOM</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOM.findDOMNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>findDOMNode
            <span class="apidocSignatureSpan">(componentOrElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOM.render">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>render
            <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOM.unmountComponentAtNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unmountComponentAtNode
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOM.unstable_batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unstable_batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOM.unstable_renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unstable_renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMComponent">module react-test-renderer.ReactDOMComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.ReactDOMComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.</span>Mixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMComponent.prototype">module react-test-renderer.ReactDOMComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createContentMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createContentMarkup
            <span class="apidocSignatureSpan">(transaction, props, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createInitialChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createInitialChildren
            <span class="apidocSignatureSpan">(transaction, props, context, lazyTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createOpenTagMarkupAndPutListeners
            <span class="apidocSignatureSpan">(transaction, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._mountChildAtIndex">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_mountChildAtIndex
            <span class="apidocSignatureSpan">(child, mountImage, afterNode, index, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerInstantiateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_reconcilerInstantiateChildren
            <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerUpdateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_reconcilerUpdateChildren
            <span class="apidocSignatureSpan">(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._unmountChild">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_unmountChild
            <span class="apidocSignatureSpan">(child, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateChildren
            <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateDOMChildren
            <span class="apidocSignatureSpan">(lastProps, nextProps, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMProperties">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateDOMProperties
            <span class="apidocSignatureSpan">(lastProps, nextProps, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.createChild">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>createChild
            <span class="apidocSignatureSpan">(child, afterNode, mountImage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getPublicInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>getPublicInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>mountChildren
            <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.moveChild">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>moveChild
            <span class="apidocSignatureSpan">(child, afterNode, toIndex, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextElement, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.removeChild">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>removeChild
            <span class="apidocSignatureSpan">(child, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>unmountChildren
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">(safely)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateChildren
            <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateComponent
            <span class="apidocSignatureSpan">(transaction, prevElement, nextElement, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateMarkup
            <span class="apidocSignatureSpan">(nextMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateTextContent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateTextContent
            <span class="apidocSignatureSpan">(nextContent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMComponentTree">module react-test-renderer.ReactDOMComponentTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getClosestInstanceFromNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getClosestInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getInstanceFromNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getInstanceFromNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getNodeFromInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getNodeFromInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheChildNodes">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>precacheChildNodes
            <span class="apidocSignatureSpan">(inst, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>precacheNode
            <span class="apidocSignatureSpan">(inst, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.uncacheNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>uncacheNode
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMEmptyComponent">module react-test-renderer.ReactDOMEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.ReactDOMEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMEmptyComponent
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMEmptyComponent.prototype">module react-test-renderer.ReactDOMEmptyComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMIDOperations">module react-test-renderer.ReactDOMIDOperations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMIDOperations.</span>dangerouslyProcessChildrenUpdates
            <span class="apidocSignatureSpan">(parentInst, updates)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMInput">module react-test-renderer.ReactDOMInput</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInput.getHostProps">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInput.mountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInput.postMountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInput.updateWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>updateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMInvalidARIAHook">module react-test-renderer.ReactDOMInvalidARIAHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInvalidARIAHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInvalidARIAHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMNullInputValuePropHook">module react-test-renderer.ReactDOMNullInputValuePropHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMNullInputValuePropHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMNullInputValuePropHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMOption">module react-test-renderer.ReactDOMOption</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMOption.getHostProps">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMOption.mountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props, hostParent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMOption.postMountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMSelect">module react-test-renderer.ReactDOMSelect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelect.getHostProps">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelect.getSelectValueContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>getSelectValueContext
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelect.mountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelect.postUpdateWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>postUpdateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMSelection">module react-test-renderer.ReactDOMSelection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelection.getOffsets">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelection.</span>getOffsets
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMSelection.setOffsets">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelection.</span>setOffsets
            <span class="apidocSignatureSpan">(node, offsets)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMServer">module react-test-renderer.ReactDOMServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMServer.renderToStaticMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMServer.</span>renderToStaticMarkup
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMServer.renderToString">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMServer.</span>renderToString
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.ReactDOMServer.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMTextComponent">module react-test-renderer.ReactDOMTextComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.ReactDOMTextComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextComponent
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMTextComponent.prototype">module react-test-renderer.ReactDOMTextComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextText, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMTextarea">module react-test-renderer.ReactDOMTextarea</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextarea.getHostProps">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>getHostProps
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextarea.mountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>mountWrapper
            <span class="apidocSignatureSpan">(inst, props)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextarea.postMountWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>postMountWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTextarea.updateWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>updateWrapper
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMTreeTraversal">module react-test-renderer.ReactDOMTreeTraversal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getLowestCommonAncestor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>getLowestCommonAncestor
            <span class="apidocSignatureSpan">(instA, instB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getParentInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>getParentInstance
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.isAncestor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>isAncestor
            <span class="apidocSignatureSpan">(instA, instB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseEnterLeave">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>traverseEnterLeave
            <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseTwoPhase">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>traverseTwoPhase
            <span class="apidocSignatureSpan">(inst, fn, arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDOMUnknownPropertyHook">module react-test-renderer.ReactDOMUnknownPropertyHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMUnknownPropertyHook.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMUnknownPropertyHook.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDebugTool">module react-test-renderer.ReactDebugTool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.addDevtool">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>addDevtool
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.addHook">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>addHook
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.beginProfiling">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>beginProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.endProfiling">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>endProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.getFlushHistory">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>getFlushHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.isProfiling">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>isProfiling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeMountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeMountComponent
            <span class="apidocSignatureSpan">(debugID, element, parentDebugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUnmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeUnmountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUpdateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeUpdateComponent
            <span class="apidocSignatureSpan">(debugID, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginFlush">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginLifeCycleTimer">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginLifeCycleTimer
            <span class="apidocSignatureSpan">(debugID, timerType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginProcessingChildContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndFlush">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndFlush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndLifeCycleTimer">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndLifeCycleTimer
            <span class="apidocSignatureSpan">(debugID, timerType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndProcessingChildContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onHostOperation">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onHostOperation
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onMountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onMountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onSetChildren">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onSetChildren
            <span class="apidocSignatureSpan">(debugID, childDebugIDs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onSetState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onSetState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onTestEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onTestEvent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onUnmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onUnmountComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.onUpdateComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onUpdateComponent
            <span class="apidocSignatureSpan">(debugID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.removeDevtool">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>removeDevtool
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDebugTool.removeHook">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>removeHook
            <span class="apidocSignatureSpan">(hook)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDefaultBatchingStrategy">module react-test-renderer.ReactDefaultBatchingStrategy</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactDefaultBatchingStrategy.</span>isBatchingUpdates</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDefaultBatchingStrategy.batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDefaultBatchingStrategy.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactDefaultInjection">module react-test-renderer.ReactDefaultInjection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactDefaultInjection.inject">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactDefaultInjection.</span>inject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactEmptyComponent">module react-test-renderer.ReactEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEmptyComponent.create">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEmptyComponent.</span>create
            <span class="apidocSignatureSpan">(instantiate)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactEmptyComponent.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactErrorUtils">module react-test-renderer.ReactErrorUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>invokeGuardedCallback
            <span class="apidocSignatureSpan">(name, func, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallbackWithCatch">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>invokeGuardedCallbackWithCatch
            <span class="apidocSignatureSpan">(name, func, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactErrorUtils.rethrowCaughtError">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>rethrowCaughtError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactEventEmitterMixin">module react-test-renderer.ReactEventEmitterMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventEmitterMixin.handleTopLevel">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventEmitterMixin.</span>handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactEventListener">module react-test-renderer.ReactEventListener</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>_enabled</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener._handleTopLevel">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>_handleTopLevel
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.dispatchEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>dispatchEvent
            <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.isEnabled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>isEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.monitorScrollValue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>monitorScrollValue
            <span class="apidocSignatureSpan">(refresh)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.setEnabled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>setEnabled
            <span class="apidocSignatureSpan">(enabled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.setHandleTopLevel">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>setHandleTopLevel
            <span class="apidocSignatureSpan">(handleTopLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.trapBubbledEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>trapBubbledEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactEventListener.trapCapturedEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>trapCapturedEvent
            <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>WINDOW_HANDLE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactFiber">module react-test-renderer.ReactFiber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.cloneFiber">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>cloneFiber
            <span class="apidocSignatureSpan">(fiber, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromCoroutine">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromCoroutine
            <span class="apidocSignatureSpan">(coroutine, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromElement">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromElement
            <span class="apidocSignatureSpan">(element, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromElementType">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromElementType
            <span class="apidocSignatureSpan">(type, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromYield">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromYield
            <span class="apidocSignatureSpan">(yieldNode, priorityLevel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiber.createHostContainerFiber">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createHostContainerFiber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactFiberRoot">module react-test-renderer.ReactFiberRoot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberRoot.createFiberRoot">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberRoot.</span>createFiberRoot
            <span class="apidocSignatureSpan">(containerInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactFiberUpdateQueue">module react-test-renderer.ReactFiberUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addCallbackToQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>addCallbackToQueue
            <span class="apidocSignatureSpan">(queue, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addToQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>addToQueue
            <span class="apidocSignatureSpan">(queue, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.callCallbacks">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>callCallbacks
            <span class="apidocSignatureSpan">(queue, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.createUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>createUpdateQueue
            <span class="apidocSignatureSpan">(partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.mergeUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>mergeUpdateQueue
            <span class="apidocSignatureSpan">(queue, prevState, props)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactHostComponent">module react-test-renderer.ReactHostComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostComponent.createInstanceForText">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>createInstanceForText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostComponent.createInternalComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>createInternalComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostComponent.isTextComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>isTextComponent
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactHostOperationHistoryHook">module react-test-renderer.ReactHostOperationHistoryHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.clearHistory">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>clearHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.getHistory">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>getHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.onHostOperation">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>onHostOperation
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactInputSelection">module react-test-renderer.ReactInputSelection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInputSelection.getSelection">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>getSelection
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInputSelection.getSelectionInformation">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>getSelectionInformation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInputSelection.hasSelectionCapabilities">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>hasSelectionCapabilities
            <span class="apidocSignatureSpan">(elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInputSelection.restoreSelection">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>restoreSelection
            <span class="apidocSignatureSpan">(priorSelectionInformation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInputSelection.setSelection">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>setSelection
            <span class="apidocSignatureSpan">(input, offsets)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactInstanceMap">module react-test-renderer.ReactInstanceMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInstanceMap.get">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInstanceMap.has">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInstanceMap.remove">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>remove
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInstanceMap.set">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>set
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactInvalidSetStateWarningHook">module react-test-renderer.ReactInvalidSetStateWarningHook</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onBeginProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onEndProcessingChildContext">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onEndProcessingChildContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onSetState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onSetState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactMarkupChecksum">module react-test-renderer.ReactMarkupChecksum</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMarkupChecksum.addChecksumToMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMarkupChecksum.</span>addChecksumToMarkup
            <span class="apidocSignatureSpan">(markup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMarkupChecksum.canReuseMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMarkupChecksum.</span>canReuseMarkup
            <span class="apidocSignatureSpan">(markup, element)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-test-renderer.ReactMarkupChecksum.</span>CHECKSUM_ATTR_NAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactMount">module react-test-renderer.ReactMount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount.TopLevelWrapper">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>TopLevelWrapper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount._mountImageIntoNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_mountImageIntoNode
            <span class="apidocSignatureSpan">(markup, container, instance, shouldReuseMarkup, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount._renderNewRootComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_renderNewRootComponent
            <span class="apidocSignatureSpan">(nextElement, container, shouldReuseMarkup, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount._renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount._updateRootComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_updateRootComponent
            <span class="apidocSignatureSpan">(prevComponent, nextElement, nextContext, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount.render">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>render
            <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount.renderSubtreeIntoContainer">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>renderSubtreeIntoContainer
            <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount.scrollMonitor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>scrollMonitor
            <span class="apidocSignatureSpan">(container, renderCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactMount.unmountComponentAtNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>unmountComponentAtNode
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_instancesByReactRootID</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactNodeTypes">module react-test-renderer.ReactNodeTypes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactNodeTypes.getType">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactNodeTypes.</span>getType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactNodeTypes.</span>COMPOSITE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactNodeTypes.</span>EMPTY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactNodeTypes.</span>HOST</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactOwner">module react-test-renderer.ReactOwner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactOwner.addComponentAsRefTo">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactOwner.</span>addComponentAsRefTo
            <span class="apidocSignatureSpan">(component, ref, owner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactOwner.removeComponentAsRefFrom">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactOwner.</span>removeComponentAsRefFrom
            <span class="apidocSignatureSpan">(component, ref, owner)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactPerf">module react-test-renderer.ReactPerf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getExclusive">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getExclusive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getInclusive">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getInclusive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getLastMeasurements">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getLastMeasurements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getMeasurementsSummaryMap">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getMeasurementsSummaryMap
            <span class="apidocSignatureSpan">(measurements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getOperations">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getOperations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.getWasted">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getWasted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.isRunning">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>isRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.printDOM">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printDOM
            <span class="apidocSignatureSpan">(measurements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.printExclusive">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printExclusive
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.printInclusive">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printInclusive
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.printOperations">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printOperations
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.printWasted">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printWasted
            <span class="apidocSignatureSpan">(flushHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.start">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactPerf.stop">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactReconcileTransaction">module react-test-renderer.ReactReconcileTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(useCreateElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.release">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactReconcileTransaction.prototype">module react-test-renderer.ReactReconcileTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">(checkpoint)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactReconciler">module react-test-renderer.ReactReconciler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconciler.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>getHostNode
            <span class="apidocSignatureSpan">(internalInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconciler.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>mountComponent
            <span class="apidocSignatureSpan">(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconciler.performUpdateIfNecessary">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>performUpdateIfNecessary
            <span class="apidocSignatureSpan">(internalInstance, transaction, updateBatchNumber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconciler.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>receiveComponent
            <span class="apidocSignatureSpan">(internalInstance, nextElement, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReconciler.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>unmountComponent
            <span class="apidocSignatureSpan">(internalInstance, safely)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactRef">module react-test-renderer.ReactRef</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactRef.attachRefs">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>attachRefs
            <span class="apidocSignatureSpan">(instance, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactRef.detachRefs">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>detachRefs
            <span class="apidocSignatureSpan">(instance, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactRef.shouldUpdateRefs">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>shouldUpdateRefs
            <span class="apidocSignatureSpan">(prevElement, nextElement)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactReifiedYield">module react-test-renderer.ReactReifiedYield</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReifiedYield.createReifiedYield">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReifiedYield.</span>createReifiedYield
            <span class="apidocSignatureSpan">(yieldNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactReifiedYield.createUpdatedReifiedYield">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactReifiedYield.</span>createUpdatedReifiedYield
            <span class="apidocSignatureSpan">(previousYield, yieldNode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerBatchingStrategy">module react-test-renderer.ReactServerBatchingStrategy</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactServerBatchingStrategy.</span>isBatchingUpdates</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerBatchingStrategy.batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerBatchingStrategy.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerRendering">module react-test-renderer.ReactServerRendering</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRendering.renderToStaticMarkup">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRendering.</span>renderToStaticMarkup
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRendering.renderToString">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRendering.</span>renderToString
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerRenderingTransaction">module react-test-renderer.ReactServerRenderingTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.ReactServerRenderingTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRenderingTransaction
            <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.release">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerRenderingTransaction.prototype">module react-test-renderer.ReactServerRenderingTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerUpdateQueue">module react-test-renderer.ReactServerUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.ReactServerUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerUpdateQueue
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactServerUpdateQueue.prototype">module react-test-renderer.ReactServerUpdateQueue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueCallback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueCallback
            <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueForceUpdate">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueForceUpdate
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueReplaceState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueReplaceState
            <span class="apidocSignatureSpan">(publicInstance, completeState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueSetState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueSetState
            <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.isMounted">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>isMounted
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactSimpleEmptyComponent">module react-test-renderer.ReactSimpleEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactSimpleEmptyComponent
            <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactSimpleEmptyComponent.prototype">module react-test-renderer.ReactSimpleEmptyComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestEmptyComponent">module react-test-renderer.ReactTestEmptyComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.ReactTestEmptyComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestEmptyComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestEmptyComponent.prototype">module react-test-renderer.ReactTestEmptyComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.toJSON">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestMount">module react-test-renderer.ReactTestMount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestMount.render">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestMount.</span>render
            <span class="apidocSignatureSpan">(nextElement, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestReconcileTransaction">module react-test-renderer.ReactTestReconcileTransaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.ReactTestReconcileTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestReconcileTransaction
            <span class="apidocSignatureSpan">(testOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>getPooled
            <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.release">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestReconcileTransaction.prototype">module react-test-renderer.ReactTestReconcileTransaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.checkpoint">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>checkpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.closeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getReactMountReady">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getReactMountReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTestOptions">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getTestOptions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTransactionWrappers">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getTransactionWrappers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getUpdateQueue">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getUpdateQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.initializeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.isInTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.perform">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.rollback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">(checkpoint)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestRenderer">module react-test-renderer.ReactTestRenderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestRenderer.create">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestRenderer.</span>create
            <span class="apidocSignatureSpan">(nextElement, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestRenderer.unstable_batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestRenderer.</span>unstable_batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestTextComponent">module react-test-renderer.ReactTestTextComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.ReactTestTextComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestTextComponent
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactTestTextComponent.prototype">module react-test-renderer.ReactTestTextComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.getHostNode">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>getHostNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.mountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>mountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.receiveComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>receiveComponent
            <span class="apidocSignatureSpan">(nextElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.toJSON">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.unmountComponent">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>unmountComponent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactUpdateQueue">module react-test-renderer.ReactUpdateQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueCallback
            <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallbackInternal">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueCallbackInternal
            <span class="apidocSignatureSpan">(internalInstance, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueElementInternal">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueElementInternal
            <span class="apidocSignatureSpan">(internalInstance, nextElement, nextContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueForceUpdate">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueForceUpdate
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueReplaceState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueReplaceState
            <span class="apidocSignatureSpan">(publicInstance, completeState, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueSetState">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueSetState
            <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.isMounted">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>isMounted
            <span class="apidocSignatureSpan">(publicInstance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdateQueue.validateCallback">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>validateCallback
            <span class="apidocSignatureSpan">(callback, callerName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ReactUpdates">module react-test-renderer.ReactUpdates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdates.ReactReconcileTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>ReactReconcileTransaction
            <span class="apidocSignatureSpan">(testOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdates.asap">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>asap
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdates.batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>batchedUpdates
            <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdates.enqueueUpdate">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>enqueueUpdate
            <span class="apidocSignatureSpan">(component)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ReactUpdates.flushBatchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>flushBatchedUpdates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ResponderEventPlugin">module react-test-renderer.ResponderEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderEventPlugin._getResponderID">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>_getResponderID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>GlobalInteractionHandler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>GlobalResponderHandler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>eventTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>injection</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ResponderSyntheticEvent">module react-test-renderer.ResponderSyntheticEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.ResponderSyntheticEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderSyntheticEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ResponderSyntheticEvent.prototype">module react-test-renderer.ResponderSyntheticEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ResponderTouchHistoryStore">module react-test-renderer.ResponderTouchHistoryStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ResponderTouchHistoryStore.recordTouchTrack">
            function <span class="apidocSignatureSpan">react-test-renderer.ResponderTouchHistoryStore.</span>recordTouchTrack
            <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.ResponderTouchHistoryStore.</span>touchHistory</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SelectEventPlugin">module react-test-renderer.SelectEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SelectEventPlugin.didPutListener">
            function <span class="apidocSignatureSpan">react-test-renderer.SelectEventPlugin.</span>didPutListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SelectEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.SelectEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SelectEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SimpleEventPlugin">module react-test-renderer.SimpleEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SimpleEventPlugin.didPutListener">
            function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>didPutListener
            <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SimpleEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SimpleEventPlugin.willDeleteListener">
            function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>willDeleteListener
            <span class="apidocSignatureSpan">(inst, registrationName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticAnimationEvent">module react-test-renderer.SyntheticAnimationEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.SyntheticAnimationEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticAnimationEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticAnimationEvent.prototype">module react-test-renderer.SyntheticAnimationEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticClipboardEvent">module react-test-renderer.SyntheticClipboardEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.SyntheticClipboardEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticClipboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticClipboardEvent.prototype">module react-test-renderer.SyntheticClipboardEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticCompositionEvent">module react-test-renderer.SyntheticCompositionEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.SyntheticCompositionEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticCompositionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticCompositionEvent.prototype">module react-test-renderer.SyntheticCompositionEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticDragEvent">module react-test-renderer.SyntheticDragEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent.SyntheticDragEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticDragEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticDragEvent.prototype">module react-test-renderer.SyntheticDragEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticDragEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticEvent">module react-test-renderer.SyntheticEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.SyntheticEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticEvent
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticEvent.prototype">module react-test-renderer.SyntheticEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.destructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>destructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.isPersistent">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>isPersistent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.persist">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>persist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.preventDefault">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>preventDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.stopPropagation">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>stopPropagation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticFocusEvent">module react-test-renderer.SyntheticFocusEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.SyntheticFocusEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticFocusEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticFocusEvent.prototype">module react-test-renderer.SyntheticFocusEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticInputEvent">module react-test-renderer.SyntheticInputEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent.SyntheticInputEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticInputEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticInputEvent.prototype">module react-test-renderer.SyntheticInputEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticInputEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticKeyboardEvent">module react-test-renderer.SyntheticKeyboardEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.SyntheticKeyboardEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticKeyboardEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticKeyboardEvent.prototype">module react-test-renderer.SyntheticKeyboardEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticMouseEvent">module react-test-renderer.SyntheticMouseEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.SyntheticMouseEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticMouseEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticMouseEvent.prototype">module react-test-renderer.SyntheticMouseEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticTouchEvent">module react-test-renderer.SyntheticTouchEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.SyntheticTouchEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTouchEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticTouchEvent.prototype">module react-test-renderer.SyntheticTouchEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticTransitionEvent">module react-test-renderer.SyntheticTransitionEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.SyntheticTransitionEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTransitionEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticTransitionEvent.prototype">module react-test-renderer.SyntheticTransitionEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticUIEvent">module react-test-renderer.SyntheticUIEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent.SyntheticUIEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticUIEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticUIEvent.prototype">module react-test-renderer.SyntheticUIEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticUIEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticWheelEvent">module react-test-renderer.SyntheticWheelEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.SyntheticWheelEvent">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticWheelEvent
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.augmentClass">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>augmentClass
            <span class="apidocSignatureSpan">(Class, Interface)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.getPooled">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>getPooled
            <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.release">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>release
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>poolSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>Interface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>instancePool</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.SyntheticWheelEvent.prototype">module react-test-renderer.SyntheticWheelEvent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.prototype.constructor">
            function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.prototype.</span>constructor
            <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.TapEventPlugin">module react-test-renderer.TapEventPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TapEventPlugin.extractEvents">
            function <span class="apidocSignatureSpan">react-test-renderer.TapEventPlugin.</span>extractEvents
            <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.TapEventPlugin.</span>tapMoveThreshold</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.TapEventPlugin.</span>eventTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.TouchHistoryMath">module react-test-renderer.TouchHistoryMath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.centroidDimension">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>centroidDimension
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter, isXAxis, ofCurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidX">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidX
            <span class="apidocSignatureSpan">(touchHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidXOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidY">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidY
            <span class="apidocSignatureSpan">(touchHistory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidYOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>previousCentroidXOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter">
            function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>previousCentroidYOfTouchesChangedAfter
            <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>noCentroid</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.Transaction">module react-test-renderer.Transaction</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>_isInTransaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Transaction.closeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>closeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Transaction.initializeAll">
            function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>initializeAll
            <span class="apidocSignatureSpan">(startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Transaction.isInTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>isInTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Transaction.perform">
            function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>perform
            <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.Transaction.reinitializeTransaction">
            function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>reinitializeTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>getTransactionWrappers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.ViewportMetrics">module react-test-renderer.ViewportMetrics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.ViewportMetrics.refreshScrollValues">
            function <span class="apidocSignatureSpan">react-test-renderer.ViewportMetrics.</span>refreshScrollValues
            <span class="apidocSignatureSpan">(scrollPosition)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ViewportMetrics.</span>currentScrollLeft</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">react-test-renderer.ViewportMetrics.</span>currentScrollTop</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.shallow">module react-test-renderer.shallow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.shallow">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>shallow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.createRenderer">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.</span>createRenderer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.shallow.prototype">module react-test-renderer.shallow.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype._render">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>_render
            <span class="apidocSignatureSpan">(element, transaction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype.getMountedInstance">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>getMountedInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype.getRenderOutput">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>getRenderOutput
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype.render">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>render
            <span class="apidocSignatureSpan">(element, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype.unmount">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>unmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.shallow.prototype.unstable_batchedUpdates">
            function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>unstable_batchedUpdates
            <span class="apidocSignatureSpan">(callback, bookkeeping)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-test-renderer.validateDOMNesting">module react-test-renderer.validateDOMNesting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.validateDOMNesting.validateDOMNesting">
            function <span class="apidocSignatureSpan">react-test-renderer.</span>validateDOMNesting
            <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.validateDOMNesting.isTagValidInContext">
            function <span class="apidocSignatureSpan">react-test-renderer.validateDOMNesting.</span>isTagValidInContext
            <span class="apidocSignatureSpan">(tag, ancestorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-test-renderer.validateDOMNesting.updatedAncestorInfo">
            function <span class="apidocSignatureSpan">react-test-renderer.validateDOMNesting.</span>updatedAncestorInfo
            <span class="apidocSignatureSpan">(oldInfo, tag, instance)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer" id="apidoc.module.react-test-renderer">module react-test-renderer</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue" id="apidoc.element.react-test-renderer.CallbackQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>CallbackQueue
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackQueue(arg) {
  _classCallCheck(this, CallbackQueue);

  this._callbacks = null;
  this._contexts = null;
  this._arg = arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree" id="apidoc.element.react-test-renderer.DOMLazyTree">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>DOMLazyTree
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState" id="apidoc.element.react-test-renderer.FallbackCompositionState">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>FallbackCompositionState
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMEmptyComponent
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent" id="apidoc.element.react-test-renderer.ReactDOMTextComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextComponent
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = &#x27;&#x27; + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction" id="apidoc.element.react-test-renderer.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(useCreateElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it&#x27;s
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRenderingTransaction
        <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerUpdateQueue
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerUpdateQueue(transaction) {
  _classCallCheck(this, ReactServerUpdateQueue);

  this.transaction = transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactSimpleEmptyComponent
        <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactSimpleEmptyComponent = function (placeholderElement, instantiate) {
  this._currentElement = null;
  this._renderedComponent = instantiate(placeholderElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestEmptyComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestEmptyComponent() {
  _classCallCheck(this, ReactTestEmptyComponent);

  this._currentElement = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestReconcileTransaction
        <span class="apidocSignatureSpan">(testOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestReconcileTransaction(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue.getPooled(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent" id="apidoc.element.react-test-renderer.ReactTestTextComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestTextComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestTextComponent(element) {
  _classCallCheck(this, ReactTestTextComponent);

  this._currentElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderSyntheticEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticAnimationEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticClipboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticCompositionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent" id="apidoc.element.react-test-renderer.SyntheticDragEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticDragEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent" id="apidoc.element.react-test-renderer.SyntheticEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticEvent
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent" id="apidoc.element.react-test-renderer.SyntheticFocusEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticFocusEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent" id="apidoc.element.react-test-renderer.SyntheticInputEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticInputEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticKeyboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent" id="apidoc.element.react-test-renderer.SyntheticMouseEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticMouseEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent" id="apidoc.element.react-test-renderer.SyntheticTouchEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTouchEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTransitionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent" id="apidoc.element.react-test-renderer.SyntheticUIEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticUIEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent" id="apidoc.element.react-test-renderer.SyntheticWheelEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticWheelEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.create" id="apidoc.element.react-test-renderer.create">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>create
        <span class="apidocSignatureSpan">(nextElement, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (nextElement, options) {
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

  var instance = instantiateReactComponent(nextWrappedElement, false);

  // The initial render is synchronous but any updates that happen during
  // rendering, in componentWillMount or componentDidMount, will be batched
  // according to the current batching strategy.
  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, instance, _assign({}, defaultTestOptions, options));
  return new ReactTestInstance(instance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Test renderer

Renders React components to pure JavaScript objects without depending on the DOM or a native mobile environment. This makes it easy
 to grab a snapshot of the &#x22;DOM tree&#x22; rendered by a React DOM or React Native component without using a browser or jsdom
.

```jsx
const ReactTestRenderer = require(&#x27;react-test-renderer&#x27;);

const renderer = ReactTestRenderer.<span class="apidocCodeKeywordSpan">create</span>(
  &#x3c;Link page=&#x22;https://www.facebook.com/&#x22;&#x3e;Facebook&#x3c;/Link&#x3e;
);

console.log(renderer.toJSON());
// { type: &#x27;a&#x27;,
//   props: { href: &#x27;https://www.facebook.com/&#x27; },
//   children: [ &#x27;Facebook&#x27; ] }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow" id="apidoc.element.react-test-renderer.shallow">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>shallow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);

  this._instance = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.unstable_batchedUpdates" id="apidoc.element.react-test-renderer.unstable_batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>unstable_batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.validateDOMNesting" id="apidoc.element.react-test-renderer.validateDOMNesting">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>validateDOMNesting
        <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &#x26;&#x26; parentInfo.tag;

  if (childText != null) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(childTag == null, &#x27;validateDOMNesting: when childText is passed, childTag should
 be null&#x27;) : void 0;
    childTag = &#x27;#text&#x27;;
  }

  var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
  var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
  var problematic = invalidParent || invalidAncestor;

  if (problematic) {
    var ancestorTag = problematic.tag;
    var ancestorInstance = problematic.instance;

    var childOwner = childInstance &#x26;&#x26; childInstance._currentElement._owner;
    var ancestorOwner = ancestorInstance &#x26;&#x26; ancestorInstance._currentElement._owner;

    var childOwners = findOwnerStack(childOwner);
    var ancestorOwners = findOwnerStack(ancestorOwner);

    var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
    var i;

    var deepestCommon = -1;
    for (i = 0; i &#x3c; minStackLen; i++) {
      if (childOwners[i] === ancestorOwners[i]) {
        deepestCommon = i;
      } else {
        break;
      }
    }

    var UNKNOWN = &#x27;(unknown)&#x27;;
    var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ownerInfo = [].concat(
    // If the parent and child instances have a common owner ancestor, start
    // with that -- otherwise we just start with the parent&#x27;s owners.
    deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
    // If we&#x27;re warning about an invalid (non-parent) ancestry, add &#x27;...&#x27;
    invalidAncestor ? [&#x27;...&#x27;] : [], childOwnerNames, childTag).join(&#x27; &#x3e; &#x27;);

    var warnKey = !!invalidParent + &#x27;|&#x27; + childTag + &#x27;|&#x27; + ancestorTag + &#x27;|&#x27; + ownerInfo;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = &#x27;&#x27;;
    if (childTag === &#x27;#text&#x27;) {
      if (/\S/.test(childText)) {
        tagDisplayName = &#x27;Text nodes&#x27;;
      } else {
        tagDisplayName = &#x27;Whitespace text nodes&#x27;;
        whitespaceInfo = &#x27; Make sure you don\&#x27;t have any extra whitespace between tags on &#x27; + &#x27;each line of your source code.&#x27;;
      }
    } else {
      tagDisplayName = &#x27;&#x3c;&#x27; + childTag + &#x27;&#x3e;&#x27;;
    }

    if (invalidParent) {
      var info = &#x27;&#x27;;
      if (ancestorTag === &#x27;table&#x27; &#x26;&#x26; childTag === &#x27;tr&#x27;) {
        info += &#x27; Add a &#x3c;tbody&#x3e; to your code to match the DOM tree generated by &#x27; + &#x27;the browser.&#x27;;
      }
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;validateDOMNesting(...): %s cannot appear as a child of &#x3c;%s&#x3e;.%s &#x27; + &#x27;
See %s.%s&#x27;, tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
    } else {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;validateDOMNesting(...): %s cannot appear as a descendant of &#x27; + &#x27;&#x3c;%
s&#x3e;. See %s.&#x27;, tagDisplayName, ancestorTag, ownerInfo) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.AutoFocusUtils" id="apidoc.module.react-test-renderer.AutoFocusUtils">module react-test-renderer.AutoFocusUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.AutoFocusUtils.focusDOMComponent" id="apidoc.element.react-test-renderer.AutoFocusUtils.focusDOMComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.AutoFocusUtils.</span>focusDOMComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">focusDOMComponent = function () {
  focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.BeforeInputEventPlugin" id="apidoc.module.react-test-renderer.BeforeInputEventPlugin">module react-test-renderer.BeforeInputEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.BeforeInputEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.BeforeInputEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.BeforeInputEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType
, targetInst, nativeEvent, nativeEventTarget)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.CSSPropertyOperations" id="apidoc.module.react-test-renderer.CSSPropertyOperations">module react-test-renderer.CSSPropertyOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.CSSPropertyOperations.createMarkupForStyles" id="apidoc.element.react-test-renderer.CSSPropertyOperations.createMarkupForStyles">
        function <span class="apidocSignatureSpan">react-test-renderer.CSSPropertyOperations.</span>createMarkupForStyles
        <span class="apidocSignatureSpan">(styles, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForStyles = function (styles, component) {
  var serialized = &#x27;&#x27;;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var styleValue = styles[styleName];
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      warnValidStyle(styleName, styleValue, component);
    }
    if (styleValue != null) {
      serialized += processStyleName(styleName) + &#x27;:&#x27;;
      serialized += dangerousStyleValue(styleName, styleValue, component) + &#x27;;&#x27;;
    }
  }
  return serialized || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (propValue) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      // See `_updateDOMProperties`. style block
      this._previousStyle = propValue;
    }
    propValue = this._previousStyleCopy = _assign({}, props.style);
  }
  propValue = CSSPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForStyles</span>(propValue, this);
}
var markup = null;
if (this._tag != null &#x26;&#x26; isCustomComponent(this._tag, props)) {
  if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
    markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
  }
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CSSPropertyOperations.setValueForStyles" id="apidoc.element.react-test-renderer.CSSPropertyOperations.setValueForStyles">
        function <span class="apidocSignatureSpan">react-test-renderer.CSSPropertyOperations.</span>setValueForStyles
        <span class="apidocSignatureSpan">(node, styles, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForStyles = function (node, styles, component) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: component._debugID,
      type: &#x27;update styles&#x27;,
      payload: styles
    });
  }

  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      warnValidStyle(styleName, styles[styleName], component);
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
    if (styleName === &#x27;float&#x27; || styleName === &#x27;cssFloat&#x27;) {
      styleName = styleFloatAccessor;
    }
    if (styleValue) {
      style[styleName] = styleValue;
    } else {
      var expansion = hasShorthandPropertyBug &#x26;&#x26; CSSProperty.shorthandPropertyExpansions[styleName];
      if (expansion) {
        // Shorthand property that IE8 won&#x27;t like unsetting, so unset each
        // component to placate it
        for (var individualStyleName in expansion) {
          style[individualStyleName] = &#x27;&#x27;;
        }
      } else {
        style[styleName] = &#x27;&#x27;;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
  }
  if (styleUpdates) {
    CSSPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForStyles</span>(getNode(this), styleUpdates, this);
  }
},

/**
 * Reconciles the children with the various properties that affect the
 * children content.
 *
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.CallbackQueue" id="apidoc.module.react-test-renderer.CallbackQueue">module react-test-renderer.CallbackQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.CallbackQueue" id="apidoc.element.react-test-renderer.CallbackQueue.CallbackQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>CallbackQueue
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackQueue(arg) {
  _classCallCheck(this, CallbackQueue);

  this._callbacks = null;
  this._contexts = null;
  this._arg = arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.getPooled" id="apidoc.element.react-test-renderer.CallbackQueue.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.release" id="apidoc.element.react-test-renderer.CallbackQueue.release">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.CallbackQueue.prototype" id="apidoc.module.react-test-renderer.CallbackQueue.prototype">module react-test-renderer.CallbackQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.checkpoint" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkpoint() {
  return this._callbacks ? this._callbacks.length : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.destructor" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destructor() {
  this.reset();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.enqueue" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.enqueue">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueue(callback, context) {
  this._callbacks = this._callbacks || [];
  this._callbacks.push(callback);
  this._contexts = this._contexts || [];
  this._contexts.push(context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.getReactMountReady().<span class="apidocCodeKeywordSpan">enqueue</span>(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, &#x27;componentDidMount&#x27;);
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.notifyAll" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.notifyAll">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>notifyAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notifyAll() {
  var callbacks = this._callbacks;
  var contexts = this._contexts;
  var arg = this._arg;
  if (callbacks &#x26;&#x26; contexts) {
    !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Mismatched list of contexts
 in callback queue&#x27;) : _prodInvariant(&#x27;24&#x27;) : void 0;
    this._callbacks = null;
    this._contexts = null;
    for (var i = 0; i &#x3c; callbacks.length; i++) {
      callbacks[i].call(contexts[i], arg);
    }
    callbacks.length = 0;
    contexts.length = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.reactMountReady.reset();
 },

 /**
  * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
  */
 close: function () {
   this.reactMountReady.<span class="apidocCodeKeywordSpan">notifyAll</span>();
 }
};

/**
* Executed within the scope of the `Transaction` instance. Consider these as
* being member methods, but with an implied ordering while being isolated from
* each other.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.reset" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.reset">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  this._callbacks = null;
  this._contexts = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.<span class="apidocCodeKeywordSpan">reset</span>();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.CallbackQueue.prototype.rollback" id="apidoc.element.react-test-renderer.CallbackQueue.prototype.rollback">
        function <span class="apidocSignatureSpan">react-test-renderer.CallbackQueue.prototype.</span>rollback
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rollback(len) {
  if (this._callbacks &#x26;&#x26; this._contexts) {
    this._callbacks.length = len;
    this._contexts.length = len;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ChangeEventPlugin" id="apidoc.module.react-test-renderer.ChangeEventPlugin">module react-test-renderer.ChangeEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ChangeEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.ChangeEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.ChangeEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

  var getTargetInstFunc, handleEventFunc;
  if (shouldUseChangeEvent(targetNode)) {
    if (doesChangeEventBubble) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else {
      handleEventFunc = handleEventsForChangeEventIE8;
    }
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventIE;
      handleEventFunc = handleEventsForInputEventIE;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(topLevelType, targetInst);
    if (inst) {
      var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
      event.type = &#x27;change&#x27;;
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(topLevelType, targetNode, targetInst);
  }

  // When blurring, set the value attribute for number inputs
  if (topLevelType === &#x27;topBlur&#x27;) {
    handleControlledInputBlur(targetInst, targetNode);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.DOMChildrenOperations" id="apidoc.module.react-test-renderer.DOMChildrenOperations">module react-test-renderer.DOMChildrenOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup" id="apidoc.element.react-test-renderer.DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>dangerouslyReplaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: &#x27;replace with&#x27;,
      payload: markup.toString()
    });
  } else {
    var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
    if (nextInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: nextInstance._debugID,
        type: &#x27;mount&#x27;,
        payload: markup.toString()
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.<span class="apidocCodeKeywordSpan">dangerouslyReplaceNodeWithMarkup</span>(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: &#x27;replace with&#x27;,
      payload: markup.toString()
    });
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMChildrenOperations.processUpdates" id="apidoc.element.react-test-renderer.DOMChildrenOperations.processUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>processUpdates
        <span class="apidocSignatureSpan">(parentNode, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processUpdates = function (parentNode, updates) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
  }

  for (var k = 0; k &#x3c; updates.length; k++) {
    var update = updates[k];
    switch (update.type) {
      case &#x27;INSERT_MARKUP&#x27;:
        insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: &#x27;insert child&#x27;,
            payload: { toIndex: update.toIndex, content: update.content.toString() }
          });
        }
        break;
      case &#x27;MOVE_EXISTING&#x27;:
        moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: &#x27;move child&#x27;,
            payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
          });
        }
        break;
      case &#x27;SET_MARKUP&#x27;:
        setInnerHTML(parentNode, update.content);
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: &#x27;replace children&#x27;,
            payload: update.content.toString()
          });
        }
        break;
      case &#x27;TEXT_CONTENT&#x27;:
        setTextContent(parentNode, update.content);
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: &#x27;replace text&#x27;,
            payload: update.content.toString()
          });
        }
        break;
      case &#x27;REMOVE_NODE&#x27;:
        removeChild(parentNode, update.fromNode);
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: parentNodeDebugID,
            type: &#x27;remove child&#x27;,
            payload: { fromIndex: update.fromIndex }
          });
        }
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Updates a component&#x27;s children by processing a series of updates.
   *
   * @param {array&#x3c;object&#x3e;} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.<span class="apidocCodeKeywordSpan">processUpdates</span>(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMChildrenOperations.replaceDelimitedText" id="apidoc.element.react-test-renderer.DOMChildrenOperations.replaceDelimitedText">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMChildrenOperations.</span>replaceDelimitedText
        <span class="apidocSignatureSpan">(openingComment, closingComment, stringText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn&#x27;t empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: &#x27;replace text&#x27;,
      payload: stringText
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var nextStringText = &#x27;&#x27; + nextText;
    if (nextStringText !== this._stringText) {
      // TODO: Save this as pending props and use performUpdateIfNecessary
      // and/or updateComponent to do the actual update for consistency with
      // other component types?
      this._stringText = nextStringText;
      var commentNodes = this.getHostNode();
      DOMChildrenOperations.<span class="apidocCodeKeywordSpan">replaceDelimitedText</span>(commentNodes[0], commentNodes[1], nextStringText
);
    }
  }
},

getHostNode: function () {
  var hostNode = this._commentNodes;
  if (hostNode) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.DOMLazyTree" id="apidoc.module.react-test-renderer.DOMLazyTree">module react-test-renderer.DOMLazyTree</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.DOMLazyTree" id="apidoc.element.react-test-renderer.DOMLazyTree.DOMLazyTree">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>DOMLazyTree
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.insertTreeBefore" id="apidoc.element.react-test-renderer.DOMLazyTree.insertTreeBefore">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>insertTreeBefore
        <span class="apidocSignatureSpan">(parentNode, tree, referenceNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertTreeBefore = function (parentNode, tree, referenceNode) {
  // DocumentFragments aren&#x27;t actually part of the DOM after insertion so
  // appending children won&#x27;t update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some &#x3c;object&#x3e; plugins (like Flash Player) will read
  // &#x3c;param&#x3e; nodes immediately upon insertion into the DOM, so &#x3c;object&#x3e;
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE &#x26;&#x26; tree.node.nodeName.toLowerCase
() === &#x27;object&#x27; &#x26;&#x26; (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// We rely exclusively on `insertBefore(node, null)` instead of also using
// `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
// we are careful to use `null`.)
parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
DOMLazyTree.<span class="apidocCodeKeywordSpan">insertTreeBefore</span>(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
if (Array.isArray(childNode)) {
  moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
} else {
  insertChildAt(parentNode, childNode, referenceNode);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.queueChild" id="apidoc.element.react-test-renderer.DOMLazyTree.queueChild">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueChild
        <span class="apidocSignatureSpan">(parentTree, childTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          setAndValidateContentChildDev.call(this, contentToUse);
        }
        DOMLazyTree.queueText(lazyTree, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      for (var i = 0; i &#x3c; mountImages.length; i++) {
        DOMLazyTree.<span class="apidocCodeKeywordSpan">queueChild</span>(lazyTree, mountImages[i]);
      }
    }
  }
},

/**
 * Receives a next element and updates the component.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.queueHTML" id="apidoc.element.react-test-renderer.DOMLazyTree.queueHTML">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueHTML
        <span class="apidocSignatureSpan">(tree, html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

_createInitialChildren: function (transaction, props, context, lazyTree) {
  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      DOMLazyTree.<span class="apidocCodeKeywordSpan">queueHTML</span>(lazyTree, innerHTML.__html);
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    // TODO: Validate that text is allowed as a child of this node
    if (contentToUse != null) {
      // Avoid setting textContent when the text is empty. In IE11 setting
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.queueText" id="apidoc.element.react-test-renderer.DOMLazyTree.queueText">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>queueText
        <span class="apidocSignatureSpan">(tree, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // textContent on a text area will cause the placeholder to not
  // show within the textarea until it has been focused and blurred again.
  // https://github.com/facebook/react/issues/6731#issuecomment-254874553
  if (contentToUse !== &#x27;&#x27;) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      setAndValidateContentChildDev.call(this, contentToUse);
    }
    DOMLazyTree.<span class="apidocCodeKeywordSpan">queueText</span>(lazyTree, contentToUse);
  }
} else if (childrenToUse != null) {
  var mountImages = this.mountChildren(childrenToUse, transaction, context);
  for (var i = 0; i &#x3c; mountImages.length; i++) {
    DOMLazyTree.queueChild(lazyTree, mountImages[i]);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMLazyTree.replaceChildWithTree" id="apidoc.element.react-test-renderer.DOMLazyTree.replaceChildWithTree">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMLazyTree.</span>replaceChildWithTree
        <span class="apidocSignatureSpan">(oldNode, newTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    !markup ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...): Missing
 markup.&#x27;) : _prodInvariant(&#x27;57&#x27;) : void 0;
    !(oldChild.nodeName !== &#x27;HTML&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup
(...): Cannot replace markup of the &#x3c;html&#x3e; node. This is because browser quirks make this unreliable and/or slow. If you
 want to render to the root you must use server rendering. See ReactDOMServer.renderToString().&#x27;) : _prodInvariant(&#x27;58
&#x27;) : void 0;

    if (typeof markup === &#x27;string&#x27;) {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.<span class="apidocCodeKeywordSpan">replaceChildWithTree</span>(oldChild, markup);
    }
  }

};

module.exports = Danger;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.DOMProperty" id="apidoc.module.react-test-renderer.DOMProperty">module react-test-renderer.DOMProperty</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMProperty.isCustomAttribute" id="apidoc.element.react-test-renderer.DOMProperty.isCustomAttribute">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMProperty.</span>isCustomAttribute
        <span class="apidocSignatureSpan">(attributeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCustomAttribute = function (attributeName) {
  for (var i = 0; i &#x3c; DOMProperty._isCustomAttributeFunctions.length; i++) {
    var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
    if (isCustomAttributeFn(attributeName)) {
      return true;
    }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return &#x27;&#x27;;
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &#x26;&#x26; value === true) {
      return attributeName + &#x27;=&#x22;&#x22;&#x27;;
    }
    return attributeName + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.<span class="apidocCodeKeywordSpan">isCustomAttribute</span>(name)) {
    if (value == null) {
      return &#x27;&#x27;;
    }
    return name + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  }
  return null;
},
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.DOMPropertyOperations" id="apidoc.module.react-test-renderer.DOMPropertyOperations">module react-test-renderer.DOMPropertyOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForCustomAttribute" id="apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForCustomAttribute">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForCustomAttribute
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForCustomAttribute = function (name, value) {
  if (!isAttributeNameSafe(name) || value == null) {
    return &#x27;&#x27;;
  }
  return name + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    propValue = this._previousStyleCopy = _assign({}, props.style);
  }
  propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
}
var markup = null;
if (this._tag != null &#x26;&#x26; isCustomComponent(this._tag, props)) {
  if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
    markup = DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForCustomAttribute</span>(propKey, propValue);
  }
} else {
  markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
}
if (markup) {
  ret += &#x27; &#x27; + markup;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForID" id="apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForID">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForID = function (id) {
  return DOMProperty.ID_ATTRIBUTE_NAME + &#x27;=&#x27; + quoteAttributeValueForBrowser(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += &#x27; &#x27; + DOMPropertyOperations.createMarkupForRoot();
  }
  ret += &#x27; &#x27; + DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForID</span>(this._domID);
  return ret;
},

/**
 * Creates markup for the content between the tags.
 *
 * @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForProperty" id="apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForProperty">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForProperty
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForProperty = function (name, value) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    if (shouldIgnoreValue(propertyInfo, value)) {
      return &#x27;&#x27;;
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &#x26;&#x26; value === true) {
      return attributeName + &#x27;=&#x22;&#x22;&#x27;;
    }
    return attributeName + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.isCustomAttribute(name)) {
    if (value == null) {
      return &#x27;&#x27;;
    }
    return name + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    var markup = null;
    if (this._tag != null &#x26;&#x26; isCustomComponent(this._tag, props)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
      }
    } else {
      markup = DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForProperty</span>(propKey, propValue);
    }
    if (markup) {
      ret += &#x27; &#x27; + markup;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForRoot" id="apidoc.element.react-test-renderer.DOMPropertyOperations.createMarkupForRoot">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>createMarkupForRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createMarkupForRoot = function () {
  return DOMProperty.ROOT_ATTRIBUTE_NAME + &#x27;=&#x22;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += &#x27; &#x27; + DOMPropertyOperations.<span class="apidocCodeKeywordSpan">createMarkupForRoot</span>();
  }
  ret += &#x27; &#x27; + DOMPropertyOperations.createMarkupForID(this._domID);
  return ret;
},

/**
 * Creates markup for the content between the tags.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForAttribute" id="apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForAttribute">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>deleteValueForAttribute
        <span class="apidocSignatureSpan">(node, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteValueForAttribute = function (node, name) {
  node.removeAttribute(name);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: &#x27;remove attribute&#x27;,
      payload: name
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // Only call deleteListener if there was a listener previously or
      // else willDeleteListener gets called when there wasn&#x27;t actually a
      // listener (e.g., onClick={null})
      deleteListener(this, propKey);
    }
  } else if (isCustomComponent(this._tag, lastProps)) {
    if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
      DOMPropertyOperations.<span class="apidocCodeKeywordSpan">deleteValueForAttribute</span>(getNode(this), propKey);
    }
  } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
    DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
  }
}
for (propKey in nextProps) {
  var nextProp = nextProps[propKey];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForProperty" id="apidoc.element.react-test-renderer.DOMPropertyOperations.deleteValueForProperty">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>deleteValueForProperty
        <span class="apidocSignatureSpan">(node, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteValueForProperty = function (node, name) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = &#x27;&#x27;;
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else if (DOMProperty.isCustomAttribute(name)) {
    node.removeAttribute(name);
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: &#x27;remove attribute&#x27;,
      payload: name
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setValueForProperty: function (node, name, value) {
var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
if (propertyInfo) {
  var mutationMethod = propertyInfo.mutationMethod;
  if (mutationMethod) {
    mutationMethod(node, value);
  } else if (shouldIgnoreValue(propertyInfo, value)) {
    this.<span class="apidocCodeKeywordSpan">deleteValueForProperty</span>(node, name);
    return;
  } else if (propertyInfo.mustUseProperty) {
    // Contrary to `setAttribute`, object properties are properly
    // `toString`ed by IE8/9.
    node[propertyInfo.propertyName] = value;
  } else {
    var attributeName = propertyInfo.attributeName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForID" id="apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForID">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setAttributeForID
        <span class="apidocSignatureSpan">(node, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAttributeForID = function (node, id) {
  node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForRoot" id="apidoc.element.react-test-renderer.DOMPropertyOperations.setAttributeForRoot">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setAttributeForRoot
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAttributeForRoot = function (node) {
  node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  } else {
    el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
  }
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setAttributeForRoot</span>(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForAttribute" id="apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForAttribute">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setValueForAttribute
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForAttribute = function (node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, &#x27;&#x27; + value);
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var payload = {};
    payload[name] = value;
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: &#x27;update attribute&#x27;,
      payload: payload
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &#x26;&#x26; value === true) {
      node.setAttribute(attributeName, &#x27;&#x27;);
    } else {
      node.setAttribute(attributeName, &#x27;&#x27; + value);
    }
  }
} else if (DOMProperty.isCustomAttribute(name)) {
  DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForAttribute</span>(node, name, value);
  return;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  var payload = {};
  payload[name] = value;
  ReactInstrumentation.debugTool.onHostOperation({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForProperty" id="apidoc.element.react-test-renderer.DOMPropertyOperations.setValueForProperty">
        function <span class="apidocSignatureSpan">react-test-renderer.DOMPropertyOperations.</span>setValueForProperty
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValueForProperty = function (node, name, value) {
  var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      this.deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // (&#x27;&#x27; + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, &#x27;&#x27; + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &#x26;&#x26; value === true) {
        node.setAttribute(attributeName, &#x27;&#x27;);
      } else {
        node.setAttribute(attributeName, &#x27;&#x27; + value);
      }
    }
  } else if (DOMProperty.isCustomAttribute(name)) {
    DOMPropertyOperations.setValueForAttribute(node, name, value);
    return;
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var payload = {};
    payload[name] = value;
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
      type: &#x27;update attribute&#x27;,
      payload: payload
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
    var node = getNode(this);
    // If we&#x27;re updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertently setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (nextProp != null) {
      DOMPropertyOperations.<span class="apidocCodeKeywordSpan">setValueForProperty</span>(node, propKey, nextProp);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, propKey);
    }
  }
}
if (styleUpdates) {
  CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.Danger" id="apidoc.module.react-test-renderer.Danger">module react-test-renderer.Danger</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.Danger.dangerouslyReplaceNodeWithMarkup" id="apidoc.element.react-test-renderer.Danger.dangerouslyReplaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.Danger.</span>dangerouslyReplaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyReplaceNodeWithMarkup = function (oldChild, markup) {
  !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...):
Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit
 testing or use ReactDOMServer.renderToString() for server rendering.&#x27;) : _prodInvariant(&#x27;56&#x27;) : void 0;
  !markup ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...): Missing markup.&#x27;) :
_prodInvariant(&#x27;57&#x27;) : void 0;
  !(oldChild.nodeName !== &#x27;HTML&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...):
Cannot replace markup of the &#x3c;html&#x3e; node. This is because browser quirks make this unreliable and/or slow. If you want to render
 to the root you must use server rendering. See ReactDOMServer.renderToString().&#x27;) : _prodInvariant(&#x27;58&#x27;) : void 0;

  if (typeof markup === &#x27;string&#x27;) {
    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  } else {
    DOMLazyTree.replaceChildWithTree(oldChild, markup);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.<span class="apidocCodeKeywordSpan">dangerouslyReplaceNodeWithMarkup</span>(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: &#x27;replace with&#x27;,
      payload: markup.toString()
    });
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.EnterLeaveEventPlugin" id="apidoc.module.react-test-renderer.EnterLeaveEventPlugin">module react-test-renderer.EnterLeaveEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.EnterLeaveEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.EnterLeaveEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.EnterLeaveEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (topLevelType === &#x27;topMouseOver&#x27; &#x26;&#x26; (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
    return null;
  }
  if (topLevelType !== &#x27;topMouseOut&#x27; &#x26;&#x26; topLevelType !== &#x27;topMouseOver&#x27;) {
    // Must not be a mouse in or mouse out - ignoring.
    return null;
  }

  var win;
  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;
    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;
  if (topLevelType === &#x27;topMouseOut&#x27;) {
    from = targetInst;
    var related = nativeEvent.relatedTarget || nativeEvent.toElement;
    to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return null;
  }

  var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
  var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

  var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
  leave.type = &#x27;mouseleave&#x27;;
  leave.target = fromNode;
  leave.relatedTarget = toNode;

  var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
  enter.type = &#x27;mouseenter&#x27;;
  enter.target = toNode;
  enter.relatedTarget = fromNode;

  EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

  return [leave, enter];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.EventPluginHub" id="apidoc.module.react-test-renderer.EventPluginHub">module react-test-renderer.EventPluginHub</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.__getListenerBank" id="apidoc.element.react-test-renderer.EventPluginHub.__getListenerBank">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>__getListenerBank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__getListenerBank = function () {
  return listenerBank;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.__purge" id="apidoc.element.react-test-renderer.EventPluginHub.__purge">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>__purge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__purge = function () {
  listenerBank = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.deleteAllListeners" id="apidoc.element.react-test-renderer.EventPluginHub.deleteAllListeners">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>deleteAllListeners
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteAllListeners = function (inst) {
  var key = getDictionaryKey(inst);
  for (var registrationName in listenerBank) {
    if (!listenerBank.hasOwnProperty(registrationName)) {
      continue;
    }

    if (!listenerBank[registrationName][key]) {
      continue;
    }

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule &#x26;&#x26; PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    delete listenerBank[registrationName][key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;&#x3c;%s&#x3e; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &#x3c;html&#x3e;, &#x3c;head&#x3e;, and &#x3c;body
&#x3e;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.&#x27
;, this._tag) : _prodInvariant(&#x27;66&#x27;, this._tag) : void 0;
    break;
}

this.unmountChildren(safely);
ReactDOMComponentTree.uncacheNode(this);
EventPluginHub.<span class="apidocCodeKeywordSpan">deleteAllListeners</span>(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  setAndValidateContentChildDev.call(this, null);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.deleteListener" id="apidoc.element.react-test-renderer.EventPluginHub.deleteListener">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>deleteListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteListener = function (inst, registrationName) {
  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &#x26;&#x26; PluginModule.willDeleteListener) {
    PluginModule.willDeleteListener(inst, registrationName);
  }

  var bankForRegistrationName = listenerBank[registrationName];
  // TODO: This should never be null -- when is it?
  if (bankForRegistrationName) {
    var key = getDictionaryKey(inst);
    delete bankForRegistrationName[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.enqueueEvents" id="apidoc.element.react-test-renderer.EventPluginHub.enqueueEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>enqueueEvents
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueEvents = function (events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

&#x27;use strict&#x27;;

var EventPluginHub = require(&#x27;./EventPluginHub&#x27;);

function runEventQueueInBatch(events) {
EventPluginHub.<span class="apidocCodeKeywordSpan">enqueueEvents</span>(events);
EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.extractEvents" id="apidoc.element.react-test-renderer.EventPluginHub.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.getListener" id="apidoc.element.react-test-renderer.EventPluginHub.getListener">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>getListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getListener = function (inst, registrationName) {
  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var bankForRegistrationName = listenerBank[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
    return null;
  }
  var key = getDictionaryKey(inst);
  return bankForRegistrationName &#x26;&#x26; bankForRegistrationName[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.processEventQueue" id="apidoc.element.react-test-renderer.EventPluginHub.processEventQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>processEventQueue
        <span class="apidocSignatureSpan">(simulated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processEventQueue = function (simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;
  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;processEventQueue(): Additional events were enqueued
while processing an event queue. Support for this has not yet been implemented.&#x27;) : _prodInvariant(&#x27;95&#x27;) : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x27;use strict&#x27;;

var EventPluginHub = require(&#x27;./EventPluginHub&#x27;);

function runEventQueueInBatch(events) {
EventPluginHub.enqueueEvents(events);
EventPluginHub.<span class="apidocCodeKeywordSpan">processEventQueue</span>(false);
}

var ReactEventEmitterMixin = {

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginHub.putListener" id="apidoc.element.react-test-renderer.EventPluginHub.putListener">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginHub.</span>putListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putListener = function (inst, registrationName, listener) {
  !(typeof listener === &#x27;function&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Expected %s listener to be a function
, instead got type %s&#x27;, registrationName, typeof listener) : _prodInvariant(&#x27;94&#x27;, registrationName, typeof listener) : void 0;

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &#x26;&#x26; PluginModule.didPutListener) {
    PluginModule.didPutListener(inst, registrationName, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.<span class="apidocCodeKeywordSpan">putListener</span>(&#x27;myID&#x27;, &#x27;onClick&#x27;, myFunction);
 *
 * This would allocate a &#x22;registration&#x22; of `(&#x27;onClick&#x27;, myFunction)` on &#x27;myID&#x27;.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.EventPluginRegistry" id="apidoc.module.react-test-renderer.EventPluginRegistry">module react-test-renderer.EventPluginRegistry</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginRegistry._resetEventPlugins" id="apidoc.element.react-test-renderer.EventPluginRegistry._resetEventPlugins">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>_resetEventPlugins
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resetEventPlugins = function () {
  eventPluginOrder = null;
  for (var pluginName in namesToPlugins) {
    if (namesToPlugins.hasOwnProperty(pluginName)) {
      delete namesToPlugins[pluginName];
    }
  }
  EventPluginRegistry.plugins.length = 0;

  var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
  for (var eventName in eventNameDispatchConfigs) {
    if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
      delete eventNameDispatchConfigs[eventName];
    }
  }

  var registrationNameModules = EventPluginRegistry.registrationNameModules;
  for (var registrationName in registrationNameModules) {
    if (registrationNameModules.hasOwnProperty(registrationName)) {
      delete registrationNameModules[registrationName];
    }
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
    for (var lowerCasedName in possibleRegistrationNames) {
      if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
        delete possibleRegistrationNames[lowerCasedName];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginRegistry.getPluginModuleForEvent" id="apidoc.element.react-test-renderer.EventPluginRegistry.getPluginModuleForEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>getPluginModuleForEvent
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPluginModuleForEvent = function (event) {
  var dispatchConfig = event.dispatchConfig;
  if (dispatchConfig.registrationName) {
    return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
  }
  if (dispatchConfig.phasedRegistrationNames !== undefined) {
    // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
    // that it is not undefined.
    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

    for (var phase in phasedRegistrationNames) {
      if (!phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
      if (pluginModule) {
        return pluginModule;
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginOrder" id="apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginOrder">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>injectEventPluginOrder
        <span class="apidocSignatureSpan">(injectedEventPluginOrder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">injectEventPluginOrder = function (injectedEventPluginOrder) {
  !!eventPluginOrder ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;EventPluginRegistry: Cannot inject event plugin
 ordering more than once. You are likely trying to load more than one copy of React.&#x27;) : _prodInvariant(&#x27;101&#x27;) : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
alreadyInjected = true;

ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
ReactInjection.EventPluginHub.<span class="apidocCodeKeywordSpan">injectEventPluginOrder</span>(DefaultEventPluginOrder);
ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginsByName" id="apidoc.element.react-test-renderer.EventPluginRegistry.injectEventPluginsByName">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginRegistry.</span>injectEventPluginsByName
        <span class="apidocSignatureSpan">(injectedNamesToPlugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">injectEventPluginsByName = function (injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;EventPluginRegistry: Cannot inject
 two different event plugins using the same name, `%s`.&#x27;, pluginName) : _prodInvariant(&#x27;102&#x27;, pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
ReactInjection.EventPluginHub.<span class="apidocCodeKeywordSpan">injectEventPluginsByName</span>({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.EventPluginUtils" id="apidoc.module.react-test-renderer.EventPluginUtils">module react-test-renderer.EventPluginUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDirectDispatch" id="apidoc.element.react-test-renderer.EventPluginUtils.executeDirectDispatch">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDirectDispatch
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;executeDirectDispatch(...): Invalid
 `event`.&#x27;) : _prodInvariant(&#x27;103&#x27;) : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrder" id="apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrder">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDispatchesInOrder
        <span class="apidocSignatureSpan">(event, simulated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i &#x3c; dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.<span class="apidocCodeKeywordSpan">executeDispatchesInOrder</span>(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrderStopAtTrue" id="apidoc.element.react-test-renderer.EventPluginUtils.executeDispatchesInOrderStopAtTrue">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>executeDispatchesInOrderStopAtTrue
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.getInstanceFromNode" id="apidoc.element.react-test-renderer.EventPluginUtils.getInstanceFromNode">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInstanceFromNode = function (node) {
  return ComponentTree.getInstanceFromNode(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

executeDirectDispatch: executeDirectDispatch,
executeDispatchesInOrder: executeDispatchesInOrder,
executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
hasDispatches: hasDispatches,

getInstanceFromNode: function (node) {
  return ComponentTree.<span class="apidocCodeKeywordSpan">getInstanceFromNode</span>(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.getLowestCommonAncestor" id="apidoc.element.react-test-renderer.EventPluginUtils.getLowestCommonAncestor">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getLowestCommonAncestor
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowestCommonAncestor = function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getLowestCommonAncestor</span>(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.getNodeFromInstance" id="apidoc.element.react-test-renderer.EventPluginUtils.getNodeFromInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getNodeFromInstance
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeFromInstance = function (node) {
  return ComponentTree.getNodeFromInstance(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || &#x27;unknown-event&#x27;;
  event.currentTarget = EventPluginUtils.<span class="apidocCodeKeywordSpan">getNodeFromInstance</span>(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.getParentInstance" id="apidoc.element.react-test-renderer.EventPluginUtils.getParentInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>getParentInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParentInstance = function (inst) {
  return TreeTraversal.getParentInstance(inst);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getParentInstance</span>(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.hasDispatches" id="apidoc.element.react-test-renderer.EventPluginUtils.hasDispatches">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>hasDispatches
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasDispatches(event) {
  return !!event._dispatchListeners;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.isAncestor" id="apidoc.element.react-test-renderer.EventPluginUtils.isAncestor">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isAncestor
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAncestor = function (a, b) {
  return TreeTraversal.isAncestor(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getInstanceFromNode: function (node) {
  return ComponentTree.getInstanceFromNode(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">isAncestor</span>(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.isEndish" id="apidoc.element.react-test-renderer.EventPluginUtils.isEndish">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isEndish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEndish(topLevelType) {
  return topLevelType === &#x27;topMouseUp&#x27; || topLevelType === &#x27;topTouchEnd&#x27; || topLevelType === &#x27;topTouchCancel&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.isMoveish" id="apidoc.element.react-test-renderer.EventPluginUtils.isMoveish">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isMoveish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMoveish(topLevelType) {
  return topLevelType === &#x27;topMouseMove&#x27; || topLevelType === &#x27;topTouchMove&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.isStartish" id="apidoc.element.react-test-renderer.EventPluginUtils.isStartish">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>isStartish
        <span class="apidocSignatureSpan">(topLevelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStartish(topLevelType) {
  return topLevelType === &#x27;topMouseDown&#x27; || topLevelType === &#x27;topTouchStart&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.traverseEnterLeave" id="apidoc.element.react-test-renderer.EventPluginUtils.traverseEnterLeave">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>traverseEnterLeave
        <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseEnterLeave = function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseEnterLeave</span>(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPluginUtils.traverseTwoPhase" id="apidoc.element.react-test-renderer.EventPluginUtils.traverseTwoPhase">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPluginUtils.</span>traverseTwoPhase
        <span class="apidocSignatureSpan">(target, fn, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseTwoPhase = function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseTwoPhase</span>(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.EventPropagators" id="apidoc.module.react-test-renderer.EventPropagators">module react-test-renderer.EventPropagators</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPropagators.accumulateDirectDispatches" id="apidoc.element.react-test-renderer.EventPropagators.accumulateDirectDispatches">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateDirectDispatches
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!wantsResponderInst || wantsResponderInst === responderInst) {
return null;
  }
  var extracted;
  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget
);
  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

  EventPropagators.<span class="apidocCodeKeywordSpan">accumulateDirectDispatches</span>(grantEvent);
  var blockHostResponder = executeDirectDispatch(grantEvent) === true;
  if (responderInst) {

var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent
, nativeEventTarget);
terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
EventPropagators.accumulateDirectDispatches(terminationRequestEvent);
var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPropagators.accumulateEnterLeaveDispatches" id="apidoc.element.react-test-renderer.EventPropagators.accumulateEnterLeaveDispatches">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateEnterLeaveDispatches
        <span class="apidocSignatureSpan">(leave, enter, from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = &#x27;mouseenter&#x27;;
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.<span class="apidocCodeKeywordSpan">accumulateEnterLeaveDispatches</span>(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatches" id="apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatches">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateTwoPhaseDispatches
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// the responder.
var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
if (skipOverBubbleShouldSetFrom) {
  EventPropagators.accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
} else {
  EventPropagators.<span class="apidocCodeKeywordSpan">accumulateTwoPhaseDispatches</span>(shouldSetEvent);
}
var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
if (!shouldSetEvent.isPersistent()) {
  shouldSetEvent.constructor.release(shouldSetEvent);
}

if (!wantsResponderInst || wantsResponderInst === responderInst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget" id="apidoc.element.react-test-renderer.EventPropagators.accumulateTwoPhaseDispatchesSkipTarget">
        function <span class="apidocSignatureSpan">react-test-renderer.EventPropagators.</span>accumulateTwoPhaseDispatchesSkipTarget
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// (deepest ID) if it happens to be the current responder. The reasoning:
// It&#x27;s strange to get an `onMoveShouldSetResponder` when you&#x27;re *already*
// the responder.
var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
if (skipOverBubbleShouldSetFrom) {
  EventPropagators.<span class="apidocCodeKeywordSpan">accumulateTwoPhaseDispatchesSkipTarget</span>(shouldSetEvent);
} else {
  EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);
}
var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
if (!shouldSetEvent.isPersistent()) {
  shouldSetEvent.constructor.release(shouldSetEvent);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.FallbackCompositionState" id="apidoc.module.react-test-renderer.FallbackCompositionState">module react-test-renderer.FallbackCompositionState</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.FallbackCompositionState" id="apidoc.element.react-test-renderer.FallbackCompositionState.FallbackCompositionState">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>FallbackCompositionState
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.getPooled" id="apidoc.element.react-test-renderer.FallbackCompositionState.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.release" id="apidoc.element.react-test-renderer.FallbackCompositionState.release">
        function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.FallbackCompositionState.prototype" id="apidoc.module.react-test-renderer.FallbackCompositionState.prototype">module react-test-renderer.FallbackCompositionState.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.destructor" id="apidoc.element.react-test-renderer.FallbackCompositionState.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  this._root = null;
  this._startText = null;
  this._fallbackText = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getData" id="apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getData">
        function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>getData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getData = function () {
  if (this._fallbackText) {
    return this._fallbackText;
  }

  var start;
  var startValue = this._startText;
  var startLength = startValue.length;
  var end;
  var endValue = this.getText();
  var endLength = endValue.length;

  for (start = 0; start &#x3c; startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end &#x3c;= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end &#x3e; 1 ? 1 - end : undefined;
  this._fallbackText = endValue.slice(start, sliceTail);
  return this._fallbackText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (useFallbackCompositionData) {
  // The current composition is stored statically and must not be
  // overwritten while composition continues.
  if (!currentComposition &#x26;&#x26; eventType === eventTypes.compositionStart) {
    currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
  } else if (eventType === eventTypes.compositionEnd) {
    if (currentComposition) {
      fallbackData = currentComposition.<span class="apidocCodeKeywordSpan">getData</span>();
    }
  }
}

var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

if (fallbackData) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getText" id="apidoc.element.react-test-renderer.FallbackCompositionState.prototype.getText">
        function <span class="apidocSignatureSpan">react-test-renderer.FallbackCompositionState.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  if (&#x27;value&#x27; in this._root) {
    return this._root.value;
  }
  return this._root[getTextContentAccessor()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getTreeSnapshot(registeredIDs) {
return registeredIDs.reduce(function (tree, id) {
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var parentID = ReactComponentTreeHook.getParentID(id);
  tree[id] = {
    displayName: ReactComponentTreeHook.getDisplayName(id),
    text: ReactComponentTreeHook.<span class="apidocCodeKeywordSpan">getText</span>(id),
    updateCount: ReactComponentTreeHook.getUpdateCount(id),
    childIDs: ReactComponentTreeHook.getChildIDs(id),
    // Text nodes don&#x27;t have owners but this is close enough.
    ownerID: ownerID || parentID &#x26;&#x26; ReactComponentTreeHook.getOwnerID(parentID) || 0,
    parentID: parentID
  };
  return tree;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.HTMLDOMPropertyConfig" id="apidoc.module.react-test-renderer.HTMLDOMPropertyConfig">module react-test-renderer.HTMLDOMPropertyConfig</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.HTMLDOMPropertyConfig.isCustomAttribute" id="apidoc.element.react-test-renderer.HTMLDOMPropertyConfig.isCustomAttribute">
        function <span class="apidocSignatureSpan">react-test-renderer.HTMLDOMPropertyConfig.</span>isCustomAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCustomAttribute = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return &#x27;&#x27;;
    }
    var attributeName = propertyInfo.attributeName;
    if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue &#x26;&#x26; value === true) {
      return attributeName + &#x27;=&#x22;&#x22;&#x27;;
    }
    return attributeName + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  } else if (DOMProperty.<span class="apidocCodeKeywordSpan">isCustomAttribute</span>(name)) {
    if (value == null) {
      return &#x27;&#x27;;
    }
    return name + &#x27;=&#x27; + quoteAttributeValueForBrowser(value);
  }
  return null;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.KeyEscapeUtils" id="apidoc.module.react-test-renderer.KeyEscapeUtils">module react-test-renderer.KeyEscapeUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.KeyEscapeUtils.escape" id="apidoc.element.react-test-renderer.KeyEscapeUtils.escape">
        function <span class="apidocSignatureSpan">react-test-renderer.KeyEscapeUtils.</span>escape
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    &#x27;=&#x27;: &#x27;=0&#x27;,
    &#x27;:&#x27;: &#x27;=2&#x27;
  };
  var escapedString = (&#x27;&#x27; + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return &#x27;$&#x27; + escapedString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {string}
*/
function getComponentKey(component, index) {
 // Do some typechecking here since we call this blindly. We want to ensure
 // that we don&#x27;t block potential future ES APIs.
 if (component &#x26;&#x26; typeof component === &#x27;object&#x27; &#x26;&#x26; component.key != null) {
   // Explicit key
   return KeyEscapeUtils.<span class="apidocCodeKeywordSpan">escape</span>(component.key);
 }
 // Implicit key determined by the index in the set
 return index.toString(36);
}

/**
* @param {?*} children Children tree container.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.KeyEscapeUtils.unescape" id="apidoc.element.react-test-renderer.KeyEscapeUtils.unescape">
        function <span class="apidocSignatureSpan">react-test-renderer.KeyEscapeUtils.</span>unescape
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    &#x27;=0&#x27;: &#x27;=&#x27;,
    &#x27;=2&#x27;: &#x27;:&#x27;
  };
  var keySubstring = key[0] === &#x27;.&#x27; &#x26;&#x26; key[1] === &#x27;$&#x27; ? key.substring(2) : key.substring(1);

  return (&#x27;&#x27; + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = require(&#x27;react/lib/ReactComponentTreeHook&#x27;);
      }
      if (!keyUnique) {
        process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;flattenChildren(...): Encountered two children with
 the same key, &#x27; + &#x27;`%s`. Child keys must be unique; when two children share a key, only &#x27; + &#x27;the first child
 will be used.%s&#x27;, KeyEscapeUtils.<span class="apidocCodeKeywordSpan">unescape</span>(name), ReactComponentTreeHook.getStackAddendumByID
(selfDebugID)) : void 0;
      }
    }
    if (keyUnique &#x26;&#x26; child != null) {
      result[name] = child;
    }
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.LinkedValueUtils" id="apidoc.module.react-test-renderer.LinkedValueUtils">module react-test-renderer.LinkedValueUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.LinkedValueUtils.checkPropTypes" id="apidoc.element.react-test-renderer.LinkedValueUtils.checkPropTypes">
        function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>checkPropTypes
        <span class="apidocSignatureSpan">(tagName, props, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPropTypes = function (tagName, props, owner) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error = propTypes[propName](props, propName, tagName, &#x27;prop&#x27;, null, ReactPropTypesSecret);
    }
    if (error instanceof Error &#x26;&#x26; !(error.message in loggedTypeFailures)) {
      // Only monitor this failure once because there tends to be a lot of the
      // same error.
      loggedTypeFailures[error.message] = true;

      var addendum = getDeclarationErrorAddendum(owner);
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;Failed form propType: %s%s&#x27;, error.message, addendum) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
LinkedValueUtils.<span class="apidocCodeKeywordSpan">checkPropTypes</span>(&#x27;input&#x27;, props, inst._currentElement._owner
);

var owner = inst._currentElement._owner;

if (props.valueLink !== undefined &#x26;&#x26; !didWarnValueLink) {
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;`valueLink` prop on `input` is deprecated; set `value`
and `onChange` instead.&#x27;) : void 0;
  didWarnValueLink = true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.LinkedValueUtils.executeOnChange" id="apidoc.element.react-test-renderer.LinkedValueUtils.executeOnChange">
        function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>executeOnChange
        <span class="apidocSignatureSpan">(inputProps, event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnChange = function (inputProps, event) {
  if (inputProps.valueLink) {
    _assertValueLink(inputProps);
    return inputProps.valueLink.requestChange(event.target.value);
  } else if (inputProps.checkedLink) {
    _assertCheckedLink(inputProps);
    return inputProps.checkedLink.requestChange(event.target.checked);
  } else if (inputProps.onChange) {
    return inputProps.onChange.call(undefined, event);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
};

function _handleChange(event) {
var props = this._currentElement.props;

var returnValue = LinkedValueUtils.<span class="apidocCodeKeywordSpan">executeOnChange</span>(props, event);

// Here we use asap to wait until all updates have propagated, which
// is important when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
ReactUpdates.asap(forceUpdateIfMounted, this);

var name = props.name;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.LinkedValueUtils.getChecked" id="apidoc.element.react-test-renderer.LinkedValueUtils.getChecked">
        function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>getChecked
        <span class="apidocSignatureSpan">(inputProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChecked = function (inputProps) {
  if (inputProps.checkedLink) {
    _assertCheckedLink(inputProps);
    return inputProps.checkedLink.value;
  }
  return inputProps.checked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
var value = LinkedValueUtils.getValue(props);
var checked = LinkedValueUtils.<span class="apidocCodeKeywordSpan">getChecked</span>(props);

var hostProps = _assign({
  // Make sure we set .type before any other properties (setting .value
  // before .type means .value is lost in IE11 and below)
  type: undefined,
  // Make sure we set .step before .value (setting .value before .step
  // means .value is rounded on mount, based upon step precision)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.LinkedValueUtils.getValue" id="apidoc.element.react-test-renderer.LinkedValueUtils.getValue">
        function <span class="apidocSignatureSpan">react-test-renderer.LinkedValueUtils.</span>getValue
        <span class="apidocSignatureSpan">(inputProps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function (inputProps) {
  if (inputProps.valueLink) {
    _assertValueLink(inputProps);
    return inputProps.valueLink.value;
  }
  return inputProps.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
var value = LinkedValueUtils.<span class="apidocCodeKeywordSpan">getValue</span>(props);
var checked = LinkedValueUtils.getChecked(props);

var hostProps = _assign({
  // Make sure we set .type before any other properties (setting .value
  // before .type means .value is lost in IE11 and below)
  type: undefined,
  // Make sure we set .step before .value (setting .value before .step
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.PooledClass" id="apidoc.module.react-test-renderer.PooledClass">module react-test-renderer.PooledClass</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.PooledClass.addPoolingTo" id="apidoc.element.react-test-renderer.PooledClass.addPoolingTo">
        function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>addPoolingTo
        <span class="apidocSignatureSpan">(CopyConstructor, pooler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.<span class="apidocCodeKeywordSpan">addPoolingTo</span>(CallbackQueue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.PooledClass.fourArgumentPooler" id="apidoc.element.react-test-renderer.PooledClass.fourArgumentPooler">
        function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>fourArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.PooledClass.oneArgumentPooler" id="apidoc.element.react-test-renderer.PooledClass.oneArgumentPooler">
        function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>oneArgumentPooler
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.PooledClass.threeArgumentPooler" id="apidoc.element.react-test-renderer.PooledClass.threeArgumentPooler">
        function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>threeArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2, a3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.PooledClass.twoArgumentPooler" id="apidoc.element.react-test-renderer.PooledClass.twoArgumentPooler">
        function <span class="apidocSignatureSpan">react-test-renderer.PooledClass.</span>twoArgumentPooler
        <span class="apidocSignatureSpan">(a1, a2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactBrowserEventEmitter" id="apidoc.module.react-test-renderer.ReactBrowserEventEmitter">module react-test-renderer.ReactBrowserEventEmitter</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.ensureScrollValueMonitoring" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.ensureScrollValueMonitoring">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>ensureScrollValueMonitoring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureScrollValueMonitoring = function () {
  if (hasEventPageXY === undefined) {
    hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
  }
  if (!hasEventPageXY &#x26;&#x26; !isMonitoringScrollValue) {
    var refresh = ViewportMetrics.refreshScrollValues;
    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
    isMonitoringScrollValue = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Various parts of our code (such as ReactCompositeComponent&#x27;s
// _renderValidatedComponent) assume that calls to render aren&#x27;t nested;
// verify that that&#x27;s the case.
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(ReactCurrentOwner.current == null, &#x27;_renderNewRootComponent(): Render
 methods should be a pure function &#x27; + &#x27;of props and state; triggering nested component updates from &#x27; + &#x27;render
 is not allowed. If necessary, trigger nested updates in &#x27; + &#x27;componentDidUpdate. Check the render method of %s.&#x27;,
ReactCurrentOwner.current &#x26;&#x26; ReactCurrentOwner.current.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;

!isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;_registerComponent(...):
Target container is not a DOM element.&#x27;) : _prodInvariant(&#x27;37&#x27;) : void 0;

ReactBrowserEventEmitter.<span class="apidocCodeKeywordSpan">ensureScrollValueMonitoring</span>();
var componentInstance = instantiateReactComponent(nextElement, false);

// The initial render is synchronous but any updates that happen during
// rendering, in componentWillMount or componentDidMount, will be batched
// according to the current batching strategy.

ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.handleTopLevel" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.handleTopLevel">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.isEnabled" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.isEnabled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>isEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnabled = function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &#x26;&#x26; ReactBrowserEventEmitter.ReactEventListener.isEnabled());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &#x26;&#x26; ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan
">isEnabled</span>());
},

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.listenTo" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.listenTo">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>listenTo
        <span class="apidocSignatureSpan">(registrationName, contentDocumentHandle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenTo = function (registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

  for (var i = 0; i &#x3c; dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) &#x26;&#x26; isListening[dependency])) {
      if (dependency === &#x27;topWheel&#x27;) {
        if (isEventSupported(&#x27;wheel&#x27;)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;wheel&#x27;, mountAt);
        } else if (isEventSupported(&#x27;mousewheel&#x27;)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;mousewheel&#x27;, mountAt);
        } else {
          // Firefox needs to capture a different mouse scroll event.
          // @see http://www.quirksmode.org/dom/events/tests/scroll.html
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;DOMMouseScroll&#x27;, mountAt);
        }
      } else if (dependency === &#x27;topScroll&#x27;) {

        if (isEventSupported(&#x27;scroll&#x27;, true)) {
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(&#x27;topScroll&#x27;, &#x27;scroll&#x27;, mountAt);
        } else {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topScroll&#x27;, &#x27;scroll&#x27;, ReactBrowserEventEmitter.ReactEventListener
.WINDOW_HANDLE);
        }
      } else if (dependency === &#x27;topFocus&#x27; || dependency === &#x27;topBlur&#x27;) {

        if (isEventSupported(&#x27;focus&#x27;, true)) {
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(&#x27;topFocus&#x27;, &#x27;focus&#x27;, mountAt);
          ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(&#x27;topBlur&#x27;, &#x27;blur&#x27;, mountAt);
        } else if (isEventSupported(&#x27;focusin&#x27;)) {
          // IE has `focusin` and `focusout` events which bubble.
          // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topFocus&#x27;, &#x27;focusin&#x27;, mountAt);
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topBlur&#x27;, &#x27;focusout&#x27;, mountAt);
        }

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (topEventMapping.hasOwnProperty(dependency)) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.setEnabled" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.setEnabled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>setEnabled
        <span class="apidocSignatureSpan">(enabled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnabled = function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sets whether or not any created callbacks should be enabled.
 *
 * @param {boolean} enabled True if callbacks should be enabled.
 */
setEnabled: function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">setEnabled</span>(enabled);
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.supportsEventPageXY" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.supportsEventPageXY">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>supportsEventPageXY
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supportsEventPageXY = function () {
  if (!document.createEvent) {
    return false;
  }
  var ev = document.createEvent(&#x27;MouseEvent&#x27;);
  return ev != null &#x26;&#x26; &#x27;pageX&#x27; in ev;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * NOTE: Scroll events do not bubble.
 *
 * @see http://www.quirksmode.org/dom/events/scroll.html
 */
ensureScrollValueMonitoring: function () {
  if (hasEventPageXY === undefined) {
    hasEventPageXY = ReactBrowserEventEmitter.<span class="apidocCodeKeywordSpan">supportsEventPageXY</span>();
  }
  if (!hasEventPageXY &#x26;&#x26; !isMonitoringScrollValue) {
    var refresh = ViewportMetrics.refreshScrollValues;
    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
    isMonitoringScrollValue = true;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapBubbledEvent" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapBubbledEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>trapBubbledEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapBubbledEvent = function (topLevelType, handlerBaseName, handle) {
  return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

for (var i = 0; i &#x3c; dependencies.length; i++) {
  var dependency = dependencies[i];
  if (!(isListening.hasOwnProperty(dependency) &#x26;&#x26; isListening[dependency])) {
    if (dependency === &#x27;topWheel&#x27;) {
      if (isEventSupported(&#x27;wheel&#x27;)) {
        ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapBubbledEvent</span>(&#x27;topWheel&#
x27;, &#x27;wheel&#x27;, mountAt);
      } else if (isEventSupported(&#x27;mousewheel&#x27;)) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;mousewheel&#x27;, mountAt);
      } else {
        // Firefox needs to capture a different mouse scroll event.
        // @see http://www.quirksmode.org/dom/events/tests/scroll.html
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;DOMMouseScroll&#x27;, mountAt);
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapCapturedEvent" id="apidoc.element.react-test-renderer.ReactBrowserEventEmitter.trapCapturedEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactBrowserEventEmitter.</span>trapCapturedEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapCapturedEvent = function (topLevelType, handlerBaseName, handle) {
  return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Firefox needs to capture a different mouse scroll event.
  // @see http://www.quirksmode.org/dom/events/tests/scroll.html
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;DOMMouseScroll&#x27;, mountAt);
}
        } else if (dependency === &#x27;topScroll&#x27;) {

if (isEventSupported(&#x27;scroll&#x27;, true)) {
  ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapCapturedEvent</span>(&#x27;topScroll&#x27;, &#
x27;scroll&#x27;, mountAt);
} else {
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topScroll&#x27;, &#x27;scroll&#x27;, ReactBrowserEventEmitter
.ReactEventListener.WINDOW_HANDLE);
}
        } else if (dependency === &#x27;topFocus&#x27; || dependency === &#x27;topBlur&#x27;) {

if (isEventSupported(&#x27;focus&#x27;, true)) {
  ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(&#x27;topFocus&#x27;, &#x27;focus&#x27;, mountAt);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactChildFiber" id="apidoc.module.react-test-renderer.ReactChildFiber">module react-test-renderer.ReactChildFiber</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildFiber.cloneChildFibers" id="apidoc.element.react-test-renderer.ReactChildFiber.cloneChildFibers">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>cloneChildFibers
        <span class="apidocSignatureSpan">(current, workInProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneChildFibers = function (current, workInProgress) {
  if (!workInProgress.child) {
    return;
  }
  if (current &#x26;&#x26; workInProgress.child === current.child) {
    // We use workInProgress.child since that lets Flow know that it can&#x27;t be
    // null since we validated that already. However, as the line above suggests
    // they&#x27;re actually the same thing.
    var currentChild = workInProgress.child;
    // TODO: This used to reset the pending priority. Not sure if that is needed.
    // workInProgress.pendingWorkPriority = current.pendingWorkPriority;
    // TODO: The below priority used to be set to NoWork which would&#x27;ve
    // dropped work. This is currently unobservable but will become
    // observable when the first sibling has lower priority work remaining
    // than the next sibling. At that point we should add tests that catches
    // this.
    var newChild = cloneFiber(currentChild, currentChild.pendingWorkPriority);
    workInProgress.child = newChild;
    cloneSiblings(currentChild, newChild, workInProgress);
  }

  // If there is no alternate, then we don&#x27;t need to clone the children.
  // If the children of the alternate fiber is a different set, then we don&#x27;t
  // need to clone. We need to reset the return fiber though since we&#x27;ll
  // traverse down into them.
  var child = workInProgress.child;
  while (child) {
    child[&#x27;return&#x27;] = workInProgress;
    child = child.sibling;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibers" id="apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibers">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>reconcileChildFibers
        <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconcileChildFibers(returnFiber, currentFirstChild, newChildren, priority) {
  return createFirstChild(returnFiber, currentFirstChild, newChildren, priority);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibersInPlace" id="apidoc.element.react-test-renderer.ReactChildFiber.reconcileChildFibersInPlace">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildFiber.</span>reconcileChildFibersInPlace
        <span class="apidocSignatureSpan">(returnFiber, currentFirstChild, newChildren, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconcileChildFibers(returnFiber, currentFirstChild, newChildren, priority) {
  return createFirstChild(returnFiber, currentFirstChild, newChildren, priority);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactChildReconciler" id="apidoc.module.react-test-renderer.ReactChildReconciler">module react-test-renderer.ReactChildReconciler</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildReconciler.instantiateChildren" id="apidoc.element.react-test-renderer.ReactChildReconciler.instantiateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>instantiateChildren
        <span class="apidocSignatureSpan">(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instantiateChildren = function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots ) {
  if (nestedChildNodes == null) {
    return null;
  }
  var childInstances = {};

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
      return instantiateChild(childInsts, child, name, selfDebugID);
    }, childInstances);
  } else {
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
  }
  return childInstances;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        return ReactChildReconciler.<span class="apidocCodeKeywordSpan">instantiateChildren</span>(nestedChildren, transaction,
context, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
    }
  }
  return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildReconciler.unmountChildren" id="apidoc.element.react-test-renderer.ReactChildReconciler.unmountChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>unmountChildren
        <span class="apidocSignatureSpan">(renderedChildren, safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountChildren = function (renderedChildren, safely) {
  for (var name in renderedChildren) {
    if (renderedChildren.hasOwnProperty(name)) {
      var renderedChild = renderedChildren[name];
      ReactReconciler.unmountComponent(renderedChild, safely);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} nextContent String of content.
 * @internal
 */
updateTextContent: function (nextContent) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.<span class="apidocCodeKeywordSpan">unmountChildren</span>(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;updateTextContent called on non-empty component
.&#x27;) : _prodInvariant(&#x27;118&#x27;) : void 0;
    }
  }
  // Set new text content.
  var updates = [makeTextContent(nextContent)];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactChildReconciler.updateChildren" id="apidoc.element.react-test-renderer.ReactChildReconciler.updateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactChildReconciler.</span>updateChildren
        <span class="apidocSignatureSpan">(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateChildren = function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots ) {
  // We currently don&#x27;t have a way to track moves here but if we use iterators
  // instead of for..in we can zip the iterators and check if an item has
  // moved.
  // TODO: If nothing has changed, return the prevChildren object so that we
  // can quickly bailout if nothing has changed.
  if (!nextChildren &#x26;&#x26; !prevChildren) {
    return;
  }
  var name;
  var prevChild;
  for (name in nextChildren) {
    if (!nextChildren.hasOwnProperty(name)) {
      continue;
    }
    prevChild = prevChildren &#x26;&#x26; prevChildren[name];
    var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
    var nextElement = nextChildren[name];
    if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
      ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
      nextChildren[name] = prevChild;
    } else {
      if (prevChild) {
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
      // The child must be instantiated before it&#x27;s mounted.
      var nextChildInstance = instantiateReactComponent(nextElement, true);
      nextChildren[name] = nextChildInstance;
      // Creating mount image now ensures refs are resolved in right order
      // (see https://github.com/facebook/react/pull/7101 for explanation).
      var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
      mountImages.push(nextChildMountImage);
    }
  }
  // Unmount children that are no longer present.
  for (name in prevChildren) {
    if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
      prevChild = prevChildren[name];
      removedNodes[name] = ReactReconciler.getHostNode(prevChild);
      ReactReconciler.unmountComponent(prevChild, false);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
      ReactChildReconciler.<span class="apidocCodeKeywordSpan">updateChildren</span>(prevChildren, nextChildren, mountImages, removedNodes
, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    }
  }
  nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
  ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
  return nextChildren;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactComponentBrowserEnvironment" id="apidoc.module.react-test-renderer.ReactComponentBrowserEnvironment">module react-test-renderer.ReactComponentBrowserEnvironment</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.processChildrenUpdates" id="apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.processChildrenUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentBrowserEnvironment.</span>processChildrenUpdates
        <span class="apidocSignatureSpan">(parentInst, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChildrenUpdates = function (parentInst, updates) {
  var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
  DOMChildrenOperations.processUpdates(node, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">processChildrenUpdates</span>(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
var getDebugID = function (inst) {
  if (!inst._debugID) {
    // Check for ART-like instances. TODO: This is silly/gross.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.replaceNodeWithMarkup" id="apidoc.element.react-test-renderer.ReactComponentBrowserEnvironment.replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentBrowserEnvironment.</span>replaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldChild, markup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
  Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
  if (prevInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: prevInstance._debugID,
      type: &#x27;replace with&#x27;,
      payload: markup.toString()
    });
  } else {
    var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
    if (nextInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: nextInstance._debugID,
        type: &#x27;mount&#x27;,
        payload: markup.toString()
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Overridden in shallow rendering.
 *
 * @protected
 */
_replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevInstance
);
},

/**
 * @protected
 */
_renderValidatedComponentWithoutOwnerOrContext: function () {
  var inst = this._instance;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactComponentEnvironment" id="apidoc.module.react-test-renderer.ReactComponentEnvironment">module react-test-renderer.ReactComponentEnvironment</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactComponentEnvironment.processChildrenUpdates" id="apidoc.element.react-test-renderer.ReactComponentEnvironment.processChildrenUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentEnvironment.</span>processChildrenUpdates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processChildrenUpdates = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">processChildrenUpdates</span>(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
var getDebugID = function (inst) {
  if (!inst._debugID) {
    // Check for ART-like instances. TODO: This is silly/gross.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactComponentEnvironment.replaceNodeWithMarkup" id="apidoc.element.react-test-renderer.ReactComponentEnvironment.replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactComponentEnvironment.</span>replaceNodeWithMarkup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceNodeWithMarkup = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Overridden in shallow rendering.
 *
 * @protected
 */
_replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.<span class="apidocCodeKeywordSpan">replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevInstance
);
},

/**
 * @protected
 */
_renderValidatedComponentWithoutOwnerOrContext: function () {
  var inst = this._instance;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactCompositeComponent" id="apidoc.module.react-test-renderer.ReactCompositeComponent">module react-test-renderer.ReactCompositeComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._checkContextTypes" id="apidoc.element.react-test-renderer.ReactCompositeComponent._checkContextTypes">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_checkContextTypes
        <span class="apidocSignatureSpan">(typeSpecs, values, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkContextTypes = function (typeSpecs, values, location) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
_processContext: function (context) {
  var maskedContext = this._maskContext(context);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this.<span class="apidocCodeKeywordSpan">_checkContextTypes</span>(Component.contextTypes, maskedContext, &#x27;context&#x27
;);
    }
  }
  return maskedContext;
},

/**
 * @param {object} currentContext
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_constructComponent
        <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_constructComponent = function (doConstruct, publicProps, publicContext, updateQueue) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactCurrentOwner.current = this;
    try {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var Component = this._currentElement.type;

var updateQueue = transaction.getUpdateQueue();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this.<span class="apidocCodeKeywordSpan">_constructComponent</span>(doConstruct, publicProps, publicContext, updateQueue
);
var renderedElement;

// Support functional components
if (!doConstruct &#x26;&#x26; (inst == null || inst.render == null)) {
  renderedElement = inst;
  warnIfInvalidElement(Component, renderedElement);
  !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant
(false, &#x27;%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other
 invalid object.&#x27;, Component.displayName || Component.name || &#x27;Component&#x27;) : _prodInvariant(&#x27;105&#x27;, Component
.displayName || Component.name || &#x27;Component&#x27;) : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponentWithoutOwner" id="apidoc.element.react-test-renderer.ReactCompositeComponent._constructComponentWithoutOwner">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_constructComponentWithoutOwner
        <span class="apidocSignatureSpan">(doConstruct, publicProps, publicContext, updateQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_constructComponentWithoutOwner = function (doConstruct, publicProps, publicContext, updateQueue) {
  var Component = this._currentElement.type;

  if (doConstruct) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      return measureLifeCyclePerf(function () {
        return new Component(publicProps, publicContext, updateQueue);
      }, this._debugID, &#x27;ctor&#x27;);
    } else {
      return new Component(publicProps, publicContext, updateQueue);
    }
  }

  // This can still be an instance in case of factory components
  // but we&#x27;ll count this as time spent rendering as the more common case.
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    return measureLifeCyclePerf(function () {
      return Component(publicProps, publicContext, updateQueue);
    }, this._debugID, &#x27;render&#x27;);
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return markup;
},

_constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactCurrentOwner.current = this;
    try {
      return this.<span class="apidocCodeKeywordSpan">_constructComponentWithoutOwner</span>(doConstruct, publicProps, publicContext
, updateQueue);
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._maskContext" id="apidoc.element.react-test-renderer.ReactCompositeComponent._maskContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_maskContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_maskContext = function (context) {
  var Component = this._currentElement.type;
  var contextTypes = Component.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }
  var maskedContext = {};
  for (var contextName in contextTypes) {
    maskedContext[contextName] = context[contextName];
  }
  return maskedContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * `contextTypes`, and asserts that they are valid.
 *
 * @param {object} context
 * @return {?object}
 * @private
 */
_processContext: function (context) {
  var maskedContext = this.<span class="apidocCodeKeywordSpan">_maskContext</span>(context);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this._checkContextTypes(Component.contextTypes, maskedContext, &#x27;context&#x27;);
    }
  }
  return maskedContext;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._performComponentUpdate" id="apidoc.element.react-test-renderer.ReactCompositeComponent._performComponentUpdate">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_performComponentUpdate
        <span class="apidocSignatureSpan">(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_performComponentUpdate = function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
  var _this2 = this;

  var inst = this._instance;

  var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
  var prevProps;
  var prevState;
  var prevContext;
  if (hasComponentDidUpdate) {
    prevProps = inst.props;
    prevState = inst.state;
    prevContext = inst.context;
  }

  if (inst.componentWillUpdate) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      measureLifeCyclePerf(function () {
        return inst.componentWillUpdate(nextProps, nextState, nextContext);
      }, this._debugID, &#x27;componentWillUpdate&#x27;);
    } else {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }
  }

  this._currentElement = nextElement;
  this._context = unmaskedContext;
  inst.props = nextProps;
  inst.state = nextState;
  inst.context = nextContext;

  this._updateRenderedComponent(transaction, unmaskedContext);

  if (hasComponentDidUpdate) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      transaction.getReactMountReady().enqueue(function () {
        measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, &#x27;componentDidUpdate
&#x27;);
      });
    } else {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(shouldUpdate !== undefined, &#x27;%s.shouldComponentUpdate(): Returned
 undefined instead of a &#x27; + &#x27;boolean value. Make sure to return true or false.&#x27;, this.getName() || &#x27;ReactCompositeComponent
&#x27;) : void 0;
}

this._updateBatchNumber = null;
if (shouldUpdate) {
  this._pendingForceUpdate = false;
  // Will set `this.props`, `this.state` and `this.context`.
  this.<span class="apidocCodeKeywordSpan">_performComponentUpdate</span>(nextParentElement, nextProps, nextState, nextContext,
transaction, nextUnmaskedContext);
} else {
  // If it&#x27;s determined that a component should not update, we still want
  // to set props and state but we shortcut the rest of the update.
  this._currentElement = nextParentElement;
  this._context = nextUnmaskedContext;
  inst.props = nextProps;
  inst.state = nextState;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processChildContext" id="apidoc.element.react-test-renderer.ReactCompositeComponent._processChildContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processChildContext
        <span class="apidocSignatureSpan">(currentContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processChildContext = function (currentContext) {
  var Component = this._currentElement.type;
  var inst = this._instance;
  var childContext;

  if (inst.getChildContext) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
      try {
        childContext = inst.getChildContext();
      } finally {
        ReactInstrumentation.debugTool.onEndProcessingChildContext();
      }
    } else {
      childContext = inst.getChildContext();
    }
  }

  if (childContext) {
    !(typeof Component.childContextTypes === &#x27;object&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;%s.getChildContext
(): childContextTypes must be defined in order to use getChildContext().&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;) : _prodInvariant
(&#x27;107&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      this._checkContextTypes(Component.childContextTypes, childContext, &#x27;child context&#x27;);
    }
    for (var name in childContext) {
      !(name in Component.childContextTypes) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;%s.getChildContext(): key
 &#x22;%s&#x22; is not defined in childContextTypes.&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;, name) : _prodInvariant(&#x27;108&#x27;, this.getName
() || &#x27;ReactCompositeComponent&#x27;, name) : void 0;
    }
    return _assign({}, currentContext, childContext);
  }
  return currentContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var nodeType = ReactNodeTypes.getType(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;

var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this.<span class="apidocCodeKeywordSpan
">_processChildContext</span>(context), debugID);

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (debugID !== 0) {
    var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
    ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processContext" id="apidoc.element.react-test-renderer.ReactCompositeComponent._processContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processContext = function (context) {
  var maskedContext = this._maskContext(context);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var Component = this._currentElement.type;
    if (Component.contextTypes) {
      this._checkContextTypes(Component.contextTypes, maskedContext, &#x27;context&#x27;);
    }
  }
  return maskedContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._context = context;
this._mountOrder = nextMountID++;
this._hostParent = hostParent;
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this.<span class="apidocCodeKeywordSpan">_processContext</span>(context);

var Component = this._currentElement.type;

var updateQueue = transaction.getUpdateQueue();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._processPendingState" id="apidoc.element.react-test-renderer.ReactCompositeComponent._processPendingState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_processPendingState
        <span class="apidocSignatureSpan">(props, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processPendingState = function (props, context) {
  var inst = this._instance;
  var queue = this._pendingStateQueue;
  var replace = this._pendingReplaceState;
  this._pendingReplaceState = false;
  this._pendingStateQueue = null;

  if (!queue) {
    return inst.state;
  }

  if (replace &#x26;&#x26; queue.length === 1) {
    return queue[0];
  }

  var nextState = _assign({}, replace ? queue[0] : inst.state);
  for (var i = replace ? 1 : 0; i &#x3c; queue.length; i++) {
    var partial = queue[i];
    _assign(nextState, typeof partial === &#x27;function&#x27; ? partial.call(inst, nextState, props, context) : partial);
  }

  return nextState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.rollback(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this.<span class="apidocCodeKeywordSpan">_processPendingState</span>(this._instance.props, this._instance
.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
transaction.rollback(checkpoint);

// Try again - we&#x27;ve informed the component about the error, so they can render an error message this time.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_renderValidatedComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderValidatedComponent = function () {
  var renderedElement;
  if (process.env.NODE_ENV !== &#x27;production&#x27; || this._compositeType !== CompositeTypes.StatelessFunctional) {
    ReactCurrentOwner.current = this;
    try {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
  }
  !(
  // TODO: An `isValidNode` function would probably be more appropriate
  renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== &#x27;production
&#x27; ? invariant(false, &#x27;%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or
 some other invalid object.&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;) : _prodInvariant(&#x27;109&#x27;, this.getName() || &#x27;ReactCompositeComponent
&#x27;) : void 0;

  return renderedElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this._pendingStateQueue) {
    inst.state = this._processPendingState(inst.props, inst.context);
  }
}

// If not a stateless component, we now render
if (renderedElement === undefined) {
  renderedElement = this.<span class="apidocCodeKeywordSpan">_renderValidatedComponent</span>();
}

var nodeType = ReactNodeTypes.getType(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext" id="apidoc.element.react-test-renderer.ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_renderValidatedComponentWithoutOwnerOrContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderValidatedComponentWithoutOwnerOrContext = function () {
  var inst = this._instance;
  var renderedElement;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    renderedElement = measureLifeCyclePerf(function () {
      return inst.render();
    }, this._debugID, &#x27;render&#x27;);
  } else {
    renderedElement = inst.render();
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    // We allow auto-mocks to proceed as if they&#x27;re returning null.
    if (renderedElement === undefined &#x26;&#x26; inst.render._isMockFunction) {
      // This is probably bad practice. Consider warning here and
      // deprecating this convenience.
      renderedElement = null;
    }
  }

  return renderedElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
_renderValidatedComponent: function () {
  var renderedElement;
  if (process.env.NODE_ENV !== &#x27;production&#x27; || this._compositeType !== CompositeTypes.StatelessFunctional) {
    ReactCurrentOwner.current = this;
    try {
      renderedElement = this.<span class="apidocCodeKeywordSpan">_renderValidatedComponentWithoutOwnerOrContext</span>();
    } finally {
      ReactCurrentOwner.current = null;
    }
  } else {
    renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
  }
  !(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._replaceNodeWithMarkup" id="apidoc.element.react-test-renderer.ReactCompositeComponent._replaceNodeWithMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_replaceNodeWithMarkup
        <span class="apidocSignatureSpan">(oldHostNode, nextMarkup, prevInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_replaceNodeWithMarkup = function (oldHostNode, nextMarkup, prevInstance) {
  ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    this.<span class="apidocCodeKeywordSpan">_replaceNodeWithMarkup</span>(oldHostNode, nextMarkup, prevComponentInstance);
  }
},

/**
 * Overridden in shallow rendering.
 *
 * @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent._updateRenderedComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent._updateRenderedComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>_updateRenderedComponent
        <span class="apidocSignatureSpan">(transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateRenderedComponent = function (transaction, context) {
  var prevComponentInstance = this._renderedComponent;
  var prevRenderedElement = prevComponentInstance._currentElement;
  var nextRenderedElement = this._renderValidatedComponent();

  var debugID = 0;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    debugID = this._debugID;
  }

  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
    ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
  } else {
    var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
    ReactReconciler.unmountComponent(prevComponentInstance, false);

    var nodeType = ReactNodeTypes.getType(nextRenderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY<span class="apidocCodeCommentSpan"> /* shouldHaveDebugID */
</span>    );
    this._renderedComponent = child;

    var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext
(context), debugID);

    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._currentElement = nextElement;
this._context = unmaskedContext;
inst.props = nextProps;
inst.state = nextState;
inst.context = nextContext;

this.<span class="apidocCodeKeywordSpan">_updateRenderedComponent</span>(transaction, unmaskedContext);

if (hasComponentDidUpdate) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.getReactMountReady().enqueue(function () {
      measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, &#x27;componentDidUpdate
&#x27;);
    });
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.attachRef" id="apidoc.element.react-test-renderer.ReactCompositeComponent.attachRef">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>attachRef
        <span class="apidocSignatureSpan">(ref, component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachRef = function (ref, component) {
  var inst = this.getPublicInstance();
  !(inst != null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Stateless function components cannot have refs.&#x27;) :
_prodInvariant(&#x27;110&#x27;) : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var componentName = component &#x26;&#x26; component.getName ? component.getName() : &#x27;a component&#x27;;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, &#x27;Stateless function components cannot be given refs &#x27; + &#x27;(See ref &#x22;%s&#x22; in %s created by %s). &#x27; + &#x27;Attempts
 to access this ref will fail.&#x27;, ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
  refs[ref] = publicComponentInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} ref Name by which to refer to the component.
 * @param {ReactOwner} owner Component on which to record the ref.
 * @final
 * @internal
 */
addComponentAsRefTo: function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;addComponentAsRefTo(...): Only
 a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\&#x27;s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).&#x27;) : _prodInvariant(&#x27;119&#x27;) : void 0;
  owner.<span class="apidocCodeKeywordSpan">attachRef</span>(ref, component);
},

/**
 * Removes a component by ref from an owner component.
 *
 * @param {ReactComponent} component Component to dereference.
 * @param {string} ref Name of the ref to remove.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.construct" id="apidoc.element.react-test-renderer.ReactCompositeComponent.construct">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>construct
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">construct = function (element) {
  this._currentElement = element;
  this._rootNodeID = 0;
  this._compositeType = null;
  this._instance = null;
  this._hostParent = null;
  this._hostContainerInfo = null;

  // See ReactUpdateQueue
  this._updateBatchNumber = null;
  this._pendingElement = null;
  this._pendingStateQueue = null;
  this._pendingReplaceState = false;
  this._pendingForceUpdate = false;

  this._renderedNodeType = null;
  this._renderedComponent = null;
  this._context = null;
  this._mountOrder = 0;
  this._topLevelWrapper = null;

  // See ReactUpdates and ReactUpdateQueue.
  this._pendingCallbacks = null;

  // ComponentWillUnmount shall only be called once
  this._calledComponentWillUnmount = false;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    this._warnedAboutRefsInRender = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var getNextDebugID = require(&#x27;react/lib/getNextDebugID&#x27;);
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);
var warning = require(&#x27;fbjs/lib/warning&#x27;);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
this.<span class="apidocCodeKeywordSpan">construct</span>(element);
};

function getDeclarationErrorAddendum(owner) {
if (owner) {
  var name = owner.getName();
  if (name) {
    return &#x27; Check the render method of `&#x27; + name + &#x27;`.&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.detachRef" id="apidoc.element.react-test-renderer.ReactCompositeComponent.detachRef">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>detachRef
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachRef = function (ref) {
  var refs = this.getPublicInstance().refs;
  delete refs[ref];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;removeComponentAsRefFrom(...):
Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\&#x27;s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).&#x27;) : _prodInvariant(&#x27;120&#x27;) : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`&#x27;s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance &#x26;&#x26; ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.<span class="apidocCodeKeywordSpan">detachRef</span>(ref);
    }
  }

};

module.exports = ReactOwner;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getHostNode" id="apidoc.element.react-test-renderer.ReactCompositeComponent.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactReconciler.getHostNode(this._renderedComponent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getName" id="apidoc.element.react-test-renderer.ReactCompositeComponent.getName">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getName = function () {
  var type = this._currentElement.type;
  var constructor = this._instance &#x26;&#x26; this._instance.constructor;
  return type.displayName || constructor &#x26;&#x26; constructor.displayName || type.name || constructor &#x26;&#x26; constructor.name || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.<span class="apidocCodeKeywordSpan">getName</span>();
    if (name) {
      return &#x27; Check the render method of `&#x27; + name + &#x27;`.&#x27;;
    }
  }
  return &#x27;&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.getPublicInstance" id="apidoc.element.react-test-renderer.ReactCompositeComponent.getPublicInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>getPublicInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicInstance = function () {
  var inst = this._instance;
  if (this._compositeType === CompositeTypes.StatelessFunctional) {
    return null;
  }
  return inst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} ref Reference name.
 * @param {component} component Component to store as `ref`.
 * @final
 * @private
 */
attachRef: function (ref, component) {
  var inst = this.<span class="apidocCodeKeywordSpan">getPublicInstance</span>();
  !(inst != null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Stateless function components cannot
 have refs.&#x27;) : _prodInvariant(&#x27;110&#x27;) : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var componentName = component &#x26;&#x26; component.getName ? component.getName() : &#x27;a component&#x27;;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, &#x27;Stateless function components cannot be given refs &#x27; + &#x27;(See ref &#x22;%s&#x22; in %s created
 by %s). &#x27; + &#x27;Attempts to access this ref will fail.&#x27;, ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.mountComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  var _this = this;

  this._context = context;
  this._mountOrder = nextMountID++;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var publicProps = this._currentElement.props;
  var publicContext = this._processContext(context);

  var Component = this._currentElement.type;

  var updateQueue = transaction.getUpdateQueue();

  // Initialize the public class
  var doConstruct = shouldConstruct(Component);
  var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
  var renderedElement;

  // Support functional components
  if (!doConstruct &#x26;&#x26; (inst == null || inst.render == null)) {
    renderedElement = inst;
    warnIfInvalidElement(Component, renderedElement);
    !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;%
s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object
.&#x27;, Component.displayName || Component.name || &#x27;Component&#x27;) : _prodInvariant(&#x27;105&#x27;, Component.displayName || Component.name || &#x27;
Component&#x27;) : void 0;
    inst = new StatelessComponent(Component);
    this._compositeType = CompositeTypes.StatelessFunctional;
  } else {
    if (isPureComponent(Component)) {
      this._compositeType = CompositeTypes.PureClass;
    } else {
      this._compositeType = CompositeTypes.ImpureClass;
    }
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    // This will throw later in _renderValidatedComponent, but add an early
    // warning now to help debugging
    if (inst.render == null) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;%s(...): No `render` method found on the returned component &#x27; + &#x27;instance
: you may have forgotten to define `render`.&#x27;, Component.displayName || Component.name || &#x27;Component&#x27;) : void 0;
    }

    var propsMutated = inst.props !== publicProps;
    var componentName = Component.displayName || Component.name || &#x27;Component&#x27;;

    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(inst.props === undefined || !propsMutated, &#x27;%s(...): When calling super() in
 `%s`, make sure to pass &#x27; + &#x27;up the same props that your component\&#x27;s constructor was passed.&#x27;, componentName, componentName) : void 0;
  }

  // These should be set up in the constructor, but as a convenience for
  // simpler class abstractions, we set them up after the fact.
  inst.props = publicProps;
  inst.context = publicContext;
  inst.refs = emptyObject;
  inst.updater = updateQueue;

  this._instance = inst;

  // Store a reference from the instance back to the internal representation
  ReactInstanceMap.set(inst, this);

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    // Since plain JS classes are defined without any special initialization
    // logic, we can not catch common errors early. Therefore, we have to
    // catch them here, at initialization time, instead.
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state
, &#x27;getInitialState was defined on %s, a plain JavaScript class. &#x27; + &#x27;This is only supported for classes created using React.createClass
. &#x27; + &#x27;Did you mean to define a state property instead?&#x27;, this.getName() || &#x27;a component&#x27;) : void 0;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, &#x27;getDefaultProps
 was defined on %s, a plain JavaScript class. &#x27; + &#x27;This is only supported for classes created using React.createClass. &#x27; + &#x27;Use
a static property to define defaultProps instead.&#x27;, this.getName() || &#x27;a component&#x27;) : void 0;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.propTypes, &#x27;propTypes was defined as an instance property on %s. Use a
 static &#x27; + &#x27;property to define propTypes instead.&#x27;, this.getName() || &#x27;a component&#x27;) : void 0;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.contextTypes, &#x27;contextTypes was defined as an instance property on %s.
U ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMount" id="apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMount">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performInitialMount
        <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performInitialMount = function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var inst = this._instance;

  var debugID = 0;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    debugID = this._debugID;
  }

  if (inst.componentWillMount) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      measureLifeCyclePerf(function () {
        return inst.componentWillMount();
      }, debugID, &#x27;componentWillMount&#x27;);
    } else {
      inst.componentWillMount();
    }
    // When mounting, calls to `setState` by `componentWillMount` will set
    // `this._pendingStateQueue` without triggering a re-render.
    if (this._pendingStateQueue) {
      inst.state = this._processPendingState(inst.props, inst.context);
    }
  }

  // If not a stateless component, we now render
  if (renderedElement === undefined) {
    renderedElement = this._renderValidatedComponent();
  }

  var nodeType = ReactNodeTypes.getType(renderedElement);
  this._renderedNodeType = nodeType;
  var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY<span class="apidocCodeCommentSpan"> /* shouldHaveDebugID */
</span>  );
  this._renderedComponent = child;

  var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (debugID !== 0) {
      var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
      ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
    }
  }

  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._pendingReplaceState = false;
this._pendingForceUpdate = false;

var markup;
if (inst.unstable_handleError) {
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.<span class="apidocCodeKeywordSpan">performInitialMount</span>(renderedElement, hostParent, hostContainerInfo, transaction
, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.getReactMountReady().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMountWithErrorHandling" id="apidoc.element.react-test-renderer.ReactCompositeComponent.performInitialMountWithErrorHandling">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performInitialMountWithErrorHandling
        <span class="apidocSignatureSpan">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performInitialMountWithErrorHandling = function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.checkpoint();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
      this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
    }
    checkpoint = transaction.checkpoint();

    this._renderedComponent.unmountComponent(true);
    transaction.rollback(checkpoint);

    // Try again - we&#x27;ve informed the component about the error, so they can render an error message this time.
    // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  }
  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._pendingStateQueue = null;
this._pendingReplaceState = false;
this._pendingForceUpdate = false;

var markup;
if (inst.unstable_handleError) {
  markup = this.<span class="apidocCodeKeywordSpan">performInitialMountWithErrorHandling</span>(renderedElement, hostParent, hostContainerInfo
, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.getReactMountReady().enqueue(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.performUpdateIfNecessary" id="apidoc.element.react-test-renderer.ReactCompositeComponent.performUpdateIfNecessary">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>performUpdateIfNecessary
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performUpdateIfNecessary = function (transaction) {
  if (this._pendingElement != null) {
    ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
  } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
    this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
  } else {
    this._updateBatchNumber = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.<span class="apidocCodeKeywordSpan">performUpdateIfNecessary</span>(transaction);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.receiveComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextElement, transaction, nextContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.unmountComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>unmountComponent
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (safely) {
  if (!this._renderedComponent) {
    return;
  }

  var inst = this._instance;

  if (inst.componentWillUnmount &#x26;&#x26; !inst._calledComponentWillUnmount) {
    inst._calledComponentWillUnmount = true;

    if (safely) {
      var name = this.getName() + &#x27;.componentWillUnmount()&#x27;;
      ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
    } else {
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        measureLifeCyclePerf(function () {
          return inst.componentWillUnmount();
        }, this._debugID, &#x27;componentWillUnmount&#x27;);
      } else {
        inst.componentWillUnmount();
      }
    }
  }

  if (this._renderedComponent) {
    ReactReconciler.unmountComponent(this._renderedComponent, safely);
    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._instance = null;
  }

  // Reset pending fields
  // Even if this component is scheduled for another update in ReactUpdates,
  // it would still be ignored because these fields are reset.
  this._pendingStateQueue = null;
  this._pendingReplaceState = false;
  this._pendingForceUpdate = false;
  this._pendingCallbacks = null;
  this._pendingElement = null;

  // These fields do not really need to be reset since this object is no
  // longer accessible.
  this._context = null;
  this._rootNodeID = 0;
  this._topLevelWrapper = null;

  // Delete the reference from the instance to this internal representation
  // which allow the internals to be properly cleaned up even if the user
  // leaks a reference to the public instance.
  ReactInstanceMap.remove(inst);

  // Some existing components rely on inst.props even after they&#x27;ve been
  // destroyed (in event handlers).
  // TODO: inst.props = null;
  // TODO: inst.state = null;
  // TODO: inst.context = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCompositeComponent.updateComponent" id="apidoc.element.react-test-renderer.ReactCompositeComponent.updateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCompositeComponent.</span>updateComponent
        <span class="apidocSignatureSpan">(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateComponent = function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
  var inst = this._instance;
  !(inst != null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Attempted to update component `%s` that has already
 been unmounted (or failed to mount).&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;) : _prodInvariant(&#x27;136&#x27;, this.getName() || &#x27;
ReactCompositeComponent&#x27;) : void 0;

  var willReceive = false;
  var nextContext;

  // Determine if the context has changed or not
  if (this._context === nextUnmaskedContext) {
    nextContext = inst.context;
  } else {
    nextContext = this._processContext(nextUnmaskedContext);
    willReceive = true;
  }

  var prevProps = prevParentElement.props;
  var nextProps = nextParentElement.props;

  // Not a simple state update but a props update
  if (prevParentElement !== nextParentElement) {
    willReceive = true;
  }

  // An update here will schedule an update but immediately set
  // _pendingStateQueue which will ensure that any state updates gets
  // immediately reconciled instead of waiting for the next batch.
  if (willReceive &#x26;&#x26; inst.componentWillReceiveProps) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      measureLifeCyclePerf(function () {
        return inst.componentWillReceiveProps(nextProps, nextContext);
      }, this._debugID, &#x27;componentWillReceiveProps&#x27;);
    } else {
      inst.componentWillReceiveProps(nextProps, nextContext);
    }
  }

  var nextState = this._processPendingState(nextProps, nextContext);
  var shouldUpdate = true;

  if (!this._pendingForceUpdate) {
    if (inst.shouldComponentUpdate) {
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        shouldUpdate = measureLifeCyclePerf(function () {
          return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }, this._debugID, &#x27;shouldComponentUpdate&#x27;);
      } else {
        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
      }
    } else {
      if (this._compositeType === CompositeTypes.PureClass) {
        shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
      }
    }
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(shouldUpdate !== undefined, &#x27;%s.shouldComponentUpdate(): Returned undefined
instead of a &#x27; + &#x27;boolean value. Make sure to return true or false.&#x27;, this.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;
  }

  this._updateBatchNumber = null;
  if (shouldUpdate) {
    this._pendingForceUpdate = false;
    // Will set `this.props`, `this.state` and `this.context`.
    this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
  } else {
    // If it&#x27;s determined that a component should not update, we still want
    // to set props and state but we shortcut the rest of the update.
    this._currentElement = nextParentElement;
    this._context = nextUnmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

receiveComponent: function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.<span class="apidocCodeKeywordSpan">updateComponent</span>(transaction, prevElement, nextElement, prevContext, nextContext
);
},

/**
 * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
 * is set, update the component.
 *
 * @param {ReactReconcileTransaction} transaction
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactCoroutine" id="apidoc.module.react-test-renderer.ReactCoroutine">module react-test-renderer.ReactCoroutine</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCoroutine.createCoroutine" id="apidoc.element.react-test-renderer.ReactCoroutine.createCoroutine">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>createCoroutine
        <span class="apidocSignatureSpan">(children, handler, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCoroutine = function (children, handler, props) {
  var key = arguments.length &#x3e; 3 &#x26;&#x26; arguments[3] !== undefined ? arguments[3] : null;

  var coroutine = {
    // This tag allow us to uniquely identify this as a React Coroutine
    $$typeof: REACT_COROUTINE_TYPE,
    key: key == null ? null : &#x27;&#x27; + key,
    children: children,
    handler: handler,
    props: props
  };

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    // TODO: Add _store property for marking this as validated.
    if (Object.freeze) {
      Object.freeze(coroutine.props);
      Object.freeze(coroutine);
    }
  }

  return coroutine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCoroutine.createYield" id="apidoc.element.react-test-renderer.ReactCoroutine.createYield">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>createYield
        <span class="apidocSignatureSpan">(props, continuation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createYield = function (props, continuation) {
  var key = arguments.length &#x3e; 2 &#x26;&#x26; arguments[2] !== undefined ? arguments[2] : null;

  var yieldNode = {
    // This tag allow us to uniquely identify this as a React Yield
    $$typeof: REACT_YIELD_TYPE,
    key: key == null ? null : &#x27;&#x27; + key,
    props: props,
    continuation: continuation
  };

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    // TODO: Add _store property for marking this as validated.
    if (Object.freeze) {
      Object.freeze(yieldNode.props);
      Object.freeze(yieldNode);
    }
  }

  return yieldNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCoroutine.isCoroutine" id="apidoc.element.react-test-renderer.ReactCoroutine.isCoroutine">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>isCoroutine
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCoroutine = function (object) {
  return typeof object === &#x27;object&#x27; &#x26;&#x26; object !== null &#x26;&#x26; object.$$typeof === REACT_COROUTINE_TYPE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactCoroutine.isYield" id="apidoc.element.react-test-renderer.ReactCoroutine.isYield">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactCoroutine.</span>isYield
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isYield = function (object) {
  return typeof object === &#x27;object&#x27; &#x26;&#x26; object !== null &#x26;&#x26; object.$$typeof === REACT_YIELD_TYPE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOM" id="apidoc.module.react-test-renderer.ReactDOM">module react-test-renderer.ReactDOM</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOM.findDOMNode" id="apidoc.element.react-test-renderer.ReactDOM.findDOMNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>findDOMNode
        <span class="apidocSignatureSpan">(componentOrElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(owner._warnedAboutRefsInRender, &#x27;%s is accessing findDOMNode inside its render
(). &#x27; + &#x27;render() should be a pure function of props and state. It should &#x27; + &#x27;never access something that requires stale data from
 the previous &#x27; + &#x27;render, such as refs. Move this logic to componentDidMount and &#x27; + &#x27;componentDidUpdate instead.&#x27;, owner.getName
() || &#x27;A component&#x27;) : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === &#x27;function&#x27;) {
    !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;findDOMNode was called on an unmounted component.&#x27;) : _prodInvariant
(&#x27;44&#x27;) : void 0;
  } else {
    !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Element appears to be neither ReactComponent nor DOMNode (
keys: %s)&#x27;, Object.keys(componentOrElement)) : _prodInvariant(&#x27;45&#x27;, Object.keys(componentOrElement)) : void 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOM.render" id="apidoc.element.react-test-renderer.ReactDOM.render">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>render
        <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (nextElement, container, callback) {
  return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Shallow rendering lets you render a component &#x22;one level deep&#x22; and assert facts about what its render method returns,
without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.

```jsx
const ReactShallowRenderer = require(&#x27;react-test-renderer/shallow&#x27;);

const renderer = new ReactShallowRenderer();
renderer.<span class="apidocCodeKeywordSpan">render</span>(&#x3c;MyComponent /&#x3e;);

const result = renderer.getRenderOutput();
expect(result.type).toBe(&#x27;div&#x27;);
expect(result.props.children).toEqual([
  &#x3c;span className=&#x22;heading&#x22;&#x3e;Title&#x3c;/span&#x3e;,
  &#x3c;Subcomponent foo=&#x22;bar&#x22; /&#x3e;
]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOM.unmountComponentAtNode" id="apidoc.element.react-test-renderer.ReactDOM.unmountComponentAtNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unmountComponentAtNode
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponentAtNode = function (container) {
  // Various parts of our code (such as ReactCompositeComponent&#x27;s
  // _renderValidatedComponent) assume that calls to render aren&#x27;t nested;
  // verify that that&#x27;s the case. (Strictly speaking, unmounting won&#x27;t cause a
  // render but we still don&#x27;t expect to be in a render call here.)
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(ReactCurrentOwner.current == null, &#x27;unmountComponentAtNode(): Render methods should
 be a pure function &#x27; + &#x27;of props and state; triggering nested component updates from render &#x27; + &#x27;is not allowed. If necessary,
trigger nested updates in &#x27; + &#x27;componentDidUpdate. Check the render method of %s.&#x27;, ReactCurrentOwner.current &#x26;&#x26; ReactCurrentOwner
.current.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;unmountComponentAtNode(...): Target container
 is not a DOM element.&#x27;) : _prodInvariant(&#x27;40&#x27;) : void 0;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!nodeIsRenderedByOtherInstance(container), &#x27;unmountComponentAtNode(): The node
 you\&#x27;re attempting to unmount &#x27; + &#x27;was rendered by another copy of React.&#x27;) : void 0;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);
  if (!prevComponent) {
    // Check if the node being unmounted was rendered by React, but isn&#x27;t a
    // root node.
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    // Check if the container itself is a React root node.
    var isContainerReactRoot = container.nodeType === 1 &#x26;&#x26; container.hasAttribute(ROOT_ATTR_NAME);

    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!containerHasNonRootReactChild, &#x27;unmountComponentAtNode(): The node you\&#x27;re
 attempting to unmount &#x27; + &#x27;was rendered by React and is not a top-level container. %s&#x27;, isContainerReactRoot ? &#x27;You may have accidentally
 passed in a React root node instead &#x27; + &#x27;of its container.&#x27; : &#x27;Instead, have the parent component update its state and &#x27; + &#x27;rerender
 in order to remove this component.&#x27;) : void 0;
    }

    return false;
  }
  delete instancesByReactRootID[prevComponent._instance.rootID];
  ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &#x26;&#x26; function () {
      callback.call(publicInst);
    };
    ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
    return publicInst;
  } else {
    ReactMount.<span class="apidocCodeKeywordSpan">unmountComponentAtNode</span>(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
var containerHasReactMarkup = reactRootElement &#x26;&#x26; !!internalGetID(reactRootElement);
var containerHasNonRootReactChild = hasNonRootReactChild(container);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOM.unstable_batchedUpdates" id="apidoc.element.react-test-renderer.ReactDOM.unstable_batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unstable_batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOM.unstable_renderSubtreeIntoContainer" id="apidoc.element.react-test-renderer.ReactDOM.unstable_renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOM.</span>unstable_renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unstable_renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &#x26;&#x26; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;
parentComponent must be a valid React Component&#x27;) : _prodInvariant(&#x27;38&#x27;) : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMComponent" id="apidoc.module.react-test-renderer.ReactDOMComponent">module react-test-renderer.ReactDOMComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.ReactDOMComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent.ReactDOMComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMComponent.prototype" id="apidoc.module.react-test-renderer.ReactDOMComponent.prototype">module react-test-renderer.ReactDOMComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createContentMarkup" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createContentMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createContentMarkup
        <span class="apidocSignatureSpan">(transaction, props, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createContentMarkup = function (transaction, props, context) {
  var ret = &#x27;&#x27;;

  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      ret = innerHTML.__html;
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    if (contentToUse != null) {
      // TODO: Validate that text is allowed as a child of this node
      ret = escapeTextContentForBrowser(contentToUse);
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        setAndValidateContentChildDev.call(this, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      ret = mountImages.join(&#x27;&#x27;);
    }
  }
  if (newlineEatingTags[this._tag] &#x26;&#x26; ret.charAt(0) === &#x27;\n&#x27;) {
    // text/html ignores the first character in these tags if it&#x27;s a newline
    // Prefer to break application/xml over text/html (for now) by adding
    // a newline specifically to get eaten by the parser. (Alternately for
    // textareas, replacing &#x22;^\n&#x22; with &#x22;\r\n&#x22; doesn&#x27;t get eaten, and the first
    // \r is normalized out by HTMLTextAreaElement#value.)
    // See: &#x3c;http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre&#x3e;
    // See: &#x3c;http://www.w3.org/TR/html5/syntax.html#element-restrictions&#x3e;
    // See: &#x3c;http://www.w3.org/TR/html5/syntax.html#newlines&#x3e;
    // See: Parsing of &#x22;textarea&#x22; &#x22;listing&#x22; and &#x22;pre&#x22; elements
    //  from &#x3c;http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody&#x3e;
    return &#x27;\n&#x27; + ret;
  } else {
    return ret;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this.<span class="apidocCodeKeywordSpan">_createContentMarkup</span>(transaction, props, context);
  if (!tagContent &#x26;&#x26; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + &#x27;/&#x3e;&#x27;;
  } else {
    mountImage = tagOpen + &#x27;&#x3e;&#x27; + tagContent + &#x27;&#x3c;/&#x27; + this._currentElement.type + &#x27;&#x3e;&#x27
;;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createInitialChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createInitialChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createInitialChildren
        <span class="apidocSignatureSpan">(transaction, props, context, lazyTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createInitialChildren = function (transaction, props, context, lazyTree) {
  // Intentional use of != to avoid catching zero/false.
  var innerHTML = props.dangerouslySetInnerHTML;
  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;
    // TODO: Validate that text is allowed as a child of this node
    if (contentToUse != null) {
      // Avoid setting textContent when the text is empty. In IE11 setting
      // textContent on a text area will cause the placeholder to not
      // show within the textarea until it has been focused and blurred again.
      // https://github.com/facebook/react/issues/6731#issuecomment-254874553
      if (contentToUse !== &#x27;&#x27;) {
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
        DOMLazyTree.queueText(lazyTree, contentToUse);
      }
    } else if (childrenToUse != null) {
      var mountImages = this.mountChildren(childrenToUse, transaction, context);
      for (var i = 0; i &#x3c; mountImages.length; i++) {
        DOMLazyTree.queueChild(lazyTree, mountImages[i]);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this.<span class="apidocCodeKeywordSpan">_createInitialChildren</span>(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &#x26;&#x26; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + &#x27;/&#x3e;&#x27;;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._createOpenTagMarkupAndPutListeners">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_createOpenTagMarkupAndPutListeners
        <span class="apidocSignatureSpan">(transaction, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createOpenTagMarkupAndPutListeners = function (transaction, props) {
  var ret = &#x27;&#x3c;&#x27; + this._currentElement.type;

  for (var propKey in props) {
    if (!props.hasOwnProperty(propKey)) {
      continue;
    }
    var propValue = props[propKey];
    if (propValue == null) {
      continue;
    }
    if (registrationNameModules.hasOwnProperty(propKey)) {
      if (propValue) {
        enqueuePutListener(this, propKey, propValue, transaction);
      }
    } else {
      if (propKey === STYLE) {
        if (propValue) {
          if (process.env.NODE_ENV !== &#x27;production&#x27;) {
            // See `_updateDOMProperties`. style block
            this._previousStyle = propValue;
          }
          propValue = this._previousStyleCopy = _assign({}, props.style);
        }
        propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
      }
      var markup = null;
      if (this._tag != null &#x26;&#x26; isCustomComponent(this._tag, props)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
        }
      } else {
        markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
      }
      if (markup) {
        ret += &#x27; &#x27; + markup;
      }
    }
  }

  // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  if (!this._hostParent) {
    ret += &#x27; &#x27; + DOMPropertyOperations.createMarkupForRoot();
  }
  ret += &#x27; &#x27; + DOMPropertyOperations.createMarkupForID(this._domID);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this._updateDOMProperties(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this.<span class="apidocCodeKeywordSpan">_createOpenTagMarkupAndPutListeners</span>(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &#x26;&#x26; omittedCloseTags[this._tag]) {
    mountImage = tagOpen + &#x27;/&#x3e;&#x27;;
  } else {
    mountImage = tagOpen + &#x27;&#x3e;&#x27; + tagContent + &#x27;&#x3c;/&#x27; + this._currentElement.type + &#x27;&#x3e;&#x27
;;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._mountChildAtIndex" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._mountChildAtIndex">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_mountChildAtIndex
        <span class="apidocSignatureSpan">(child, mountImage, afterNode, index, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mountChildAtIndex = function (child, mountImage, afterNode, index, transaction, context) {
  child._mountIndex = index;
  return this.createChild(child, afterNode, mountImage);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    if (prevChild) {
      // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
      lastIndex = Math.max(prevChild._mountIndex, lastIndex);
      // The `removedNodes` loop below will actually remove the child.
    }
    // The child must be instantiated before it&#x27;s mounted.
    updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">_mountChildAtIndex</span>(nextChild, mountImages[nextMountIndex
], lastPlacedNode, nextIndex, transaction, context));
    nextMountIndex++;
  }
  nextIndex++;
  lastPlacedNode = ReactReconciler.getHostNode(nextChild);
}
// Remove children that are no longer present.
for (name in removedNodes) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerInstantiateChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerInstantiateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_reconcilerInstantiateChildren
        <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reconcilerInstantiateChildren = function (nestedChildren, transaction, context) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
    }
  }
  return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
var children = this.<span class="apidocCodeKeywordSpan">_reconcilerInstantiateChildren</span>(nestedChildren, transaction, context
);
this._renderedChildren = children;

var mountImages = [];
var index = 0;
for (var name in children) {
  if (children.hasOwnProperty(name)) {
    var child = children[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerUpdateChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._reconcilerUpdateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_reconcilerUpdateChildren
        <span class="apidocSignatureSpan">(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reconcilerUpdateChildren = function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
  var nextChildren;
  var selfDebugID = 0;
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    selfDebugID = getDebugID(this);
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
      return nextChildren;
    }
  }
  nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
  ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
  return nextChildren;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @protected
 */
_updateChildren: function (nextNestedChildrenElements, transaction, context) {
  var prevChildren = this._renderedChildren;
  var removedNodes = {};
  var mountImages = [];
  var nextChildren = this.<span class="apidocCodeKeywordSpan">_reconcilerUpdateChildren</span>(prevChildren, nextNestedChildrenElements
, mountImages, removedNodes, transaction, context);
  if (!nextChildren &#x26;&#x26; !prevChildren) {
    return;
  }
  var updates = null;
  var name;
  // `nextIndex` will increment for each child in `nextChildren`, but
  // `lastIndex` will be the last index visited in `prevChildren`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._unmountChild" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._unmountChild">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_unmountChild
        <span class="apidocSignatureSpan">(child, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unmountChild = function (child, node) {
  var update = this.removeChild(child, node);
  child._mountIndex = null;
  return update;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  nextIndex++;
  lastPlacedNode = ReactReconciler.getHostNode(nextChild);
}
// Remove children that are no longer present.
for (name in removedNodes) {
  if (removedNodes.hasOwnProperty(name)) {
    updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">_unmountChild</span>(prevChildren[name], removedNodes[name
]));
  }
}
if (updates) {
  processQueue(this, updates);
}
this._renderedChildren = nextChildren;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateChildren
        <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateChildren = function (nextNestedChildrenElements, transaction, context) {
  var prevChildren = this._renderedChildren;
  var removedNodes = {};
  var mountImages = [];
  var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction
, context);
  if (!nextChildren &#x26;&#x26; !prevChildren) {
    return;
  }
  var updates = null;
  var name;
  // `nextIndex` will increment for each child in `nextChildren`, but
  // `lastIndex` will be the last index visited in `prevChildren`.
  var nextIndex = 0;
  var lastIndex = 0;
  // `nextMountIndex` will increment for each newly mounted child.
  var nextMountIndex = 0;
  var lastPlacedNode = null;
  for (name in nextChildren) {
    if (!nextChildren.hasOwnProperty(name)) {
      continue;
    }
    var prevChild = prevChildren &#x26;&#x26; prevChildren[name];
    var nextChild = nextChildren[name];
    if (prevChild === nextChild) {
      updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
      lastIndex = Math.max(prevChild._mountIndex, lastIndex);
      prevChild._mountIndex = nextIndex;
    } else {
      if (prevChild) {
        // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
        lastIndex = Math.max(prevChild._mountIndex, lastIndex);
        // The `removedNodes` loop below will actually remove the child.
      }
      // The child must be instantiated before it&#x27;s mounted.
      updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction
, context));
      nextMountIndex++;
    }
    nextIndex++;
    lastPlacedNode = ReactReconciler.getHostNode(nextChild);
  }
  // Remove children that are no longer present.
  for (name in removedNodes) {
    if (removedNodes.hasOwnProperty(name)) {
      updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
    }
  }
  if (updates) {
    processQueue(this, updates);
  }
  this._renderedChildren = nextChildren;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    setChildrenForInstrumentation.call(this, nextChildren);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {?object} nextNestedChildrenElements Nested child element maps.
 * @param {ReactReconcileTransaction} transaction
 * @internal
 */
updateChildren: function (nextNestedChildrenElements, transaction, context) {
  // Hook used by React ART
  this.<span class="apidocCodeKeywordSpan">_updateChildren</span>(nextNestedChildrenElements, transaction, context);
},

/**
 * @param {?object} nextNestedChildrenElements Nested child element maps.
 * @param {ReactReconcileTransaction} transaction
 * @final
 * @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateDOMChildren
        <span class="apidocSignatureSpan">(lastProps, nextProps, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateDOMChildren = function (lastProps, nextProps, transaction, context) {
  var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
  var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

  var lastHtml = lastProps.dangerouslySetInnerHTML &#x26;&#x26; lastProps.dangerouslySetInnerHTML.__html;
  var nextHtml = nextProps.dangerouslySetInnerHTML &#x26;&#x26; nextProps.dangerouslySetInnerHTML.__html;

  // Note the use of `!=` which checks for null or undefined.
  var lastChildren = lastContent != null ? null : lastProps.children;
  var nextChildren = nextContent != null ? null : nextProps.children;

  // If we&#x27;re switching from children to content/html or vice versa, remove
  // the old content
  var lastHasContentOrHtml = lastContent != null || lastHtml != null;
  var nextHasContentOrHtml = nextContent != null || nextHtml != null;
  if (lastChildren != null &#x26;&#x26; nextChildren == null) {
    this.updateChildren(null, transaction, context);
  } else if (lastHasContentOrHtml &#x26;&#x26; !nextHasContentOrHtml) {
    this.updateTextContent(&#x27;&#x27;);
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
    }
  }

  if (nextContent != null) {
    if (lastContent !== nextContent) {
      this.updateTextContent(&#x27;&#x27; + nextContent);
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        setAndValidateContentChildDev.call(this, nextContent);
      }
    }
  } else if (nextHtml != null) {
    if (lastHtml !== nextHtml) {
      this.updateMarkup(&#x27;&#x27; + nextHtml);
    }
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
    }
  } else if (nextChildren != null) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      setAndValidateContentChildDev.call(this, null);
    }

    this.updateChildren(nextChildren, transaction, context);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
    nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
    break;
}

assertValidProps(this, nextProps);
this._updateDOMProperties(lastProps, nextProps, transaction);
this.<span class="apidocCodeKeywordSpan">_updateDOMChildren</span>(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case &#x27;input&#x27;:
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.updateWrapper(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMProperties" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype._updateDOMProperties">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>_updateDOMProperties
        <span class="apidocSignatureSpan">(lastProps, nextProps, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateDOMProperties = function (lastProps, nextProps, transaction) {
  var propKey;
  var styleName;
  var styleUpdates;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = this._previousStyleCopy;
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          styleUpdates = styleUpdates || {};
          styleUpdates[styleName] = &#x27;&#x27;;
        }
      }
      this._previousStyleCopy = null;
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (lastProps[propKey]) {
        // Only call deleteListener if there was a listener previously or
        // else willDeleteListener gets called when there wasn&#x27;t actually a
        // listener (e.g., onClick={null})
        deleteListener(this, propKey);
      }
    } else if (isCustomComponent(this._tag, lastProps)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
      }
    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null &#x26;&#x26; lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      if (nextProp) {
        if (process.env.NODE_ENV !== &#x27;production&#x27;) {
          checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
          this._previousStyle = nextProp;
        }
        nextProp = this._previousStyleCopy = _assign({}, nextProp);
      } else {
        this._previousStyleCopy = null;
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) &#x26;&#x26; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = &#x27;&#x27;;
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) &#x26;&#x26; lastProp[styleName] !== nextProp[styleName]) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        styleUpdates = nextProp;
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp) {
        enqueuePutListener(this, propKey, nextProp, transaction);
      } else if (lastProp) {
        deleteListener(this, propKey);
      }
    } else if (isCustomComponent(this._tag, nextProps)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
      }
    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      var node = getNode(this);
      // If we&#x27;re updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      if (nextProp != null) {
        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
  }
  if (styleUpdates) {
    CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
  }
  ReactDOMComponentTree.precacheNode(this, el);
  this._flags |= Flags.hasCachedChildNodes;
  if (!this._hostParent) {
    DOMPropertyOperations.setAttributeForRoot(el);
  }
  this.<span class="apidocCodeKeywordSpan">_updateDOMProperties</span>(null, props, transaction);
  var lazyTree = DOMLazyTree(el);
  this._createInitialChildren(transaction, props, context, lazyTree);
  mountImage = lazyTree;
} else {
  var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
  var tagContent = this._createContentMarkup(transaction, props, context);
  if (!tagContent &#x26;&#x26; omittedCloseTags[this._tag]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.createChild" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.createChild">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>createChild
        <span class="apidocSignatureSpan">(child, afterNode, mountImage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChild = function (child, afterNode, mountImage) {
  return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} name Name of the child.
 * @param {number} index Index at which to insert the child.
 * @param {ReactReconcileTransaction} transaction
 * @private
 */
_mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
  child._mountIndex = index;
  return this.<span class="apidocCodeKeywordSpan">createChild</span>(child, afterNode, mountImage);
},

/**
 * Unmounts a rendered child.
 *
 * NOTE: This is part of `updateChildren` and is here for readability.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return getNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getPublicInstance" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.getPublicInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>getPublicInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPublicInstance = function () {
  return getNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} ref Reference name.
 * @param {component} component Component to store as `ref`.
 * @final
 * @private
 */
attachRef: function (ref, component) {
  var inst = this.<span class="apidocCodeKeywordSpan">getPublicInstance</span>();
  !(inst != null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Stateless function components cannot
 have refs.&#x27;) : _prodInvariant(&#x27;110&#x27;) : void 0;
  var publicComponentInstance = component.getPublicInstance();
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var componentName = component &#x26;&#x26; component.getName ? component.getName() : &#x27;a component&#x27;;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes
.StatelessFunctional, &#x27;Stateless function components cannot be given refs &#x27; + &#x27;(See ref &#x22;%s&#x22; in %s created
 by %s). &#x27; + &#x27;Attempts to access this ref will fail.&#x27;, ref, componentName, this.getName()) : void 0;
  }
  var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>mountChildren
        <span class="apidocSignatureSpan">(nestedChildren, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountChildren = function (nestedChildren, transaction, context) {
  var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
  this._renderedChildren = children;

  var mountImages = [];
  var index = 0;
  for (var name in children) {
    if (children.hasOwnProperty(name)) {
      var child = children[name];
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        selfDebugID = getDebugID(this);
      }
      var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
      child._mountIndex = index++;
      mountImages.push(mountImage);
    }
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    setChildrenForInstrumentation.call(this, children);
  }

  return mountImages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._hostContainerInfo = null;
}

ReactTestComponent.prototype.mountComponent = function mountComponent(transaction, nativeParent, hostContainerInfo, context) {
  var element = this._currentElement;
  this._hostContainerInfo = hostContainerInfo;
  // $FlowFixMe https://github.com/facebook/flow/issues/1805
  this.<span class="apidocCodeKeywordSpan">mountChildren</span>(element.props.children, transaction, context);
};

ReactTestComponent.prototype.receiveComponent = function receiveComponent(nextElement, transaction, context) {
  this._currentElement = nextElement;
  // $FlowFixMe https://github.com/facebook/flow/issues/1805
  this.updateChildren(nextElement.props.children, transaction, context);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  this._rootNodeID = globalIdCounter++;
  this._domID = hostContainerInfo._idCounter++;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var props = this._currentElement.props;

  switch (this._tag) {
    case &#x27;audio&#x27;:
    case &#x27;form&#x27;:
    case &#x27;iframe&#x27;:
    case &#x27;img&#x27;:
    case &#x27;link&#x27;:
    case &#x27;object&#x27;:
    case &#x27;source&#x27;:
    case &#x27;video&#x27;:
      this._wrapperState = {
        listeners: null
      };
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case &#x27;input&#x27;:
      ReactDOMInput.mountWrapper(this, props, hostParent);
      props = ReactDOMInput.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case &#x27;option&#x27;:
      ReactDOMOption.mountWrapper(this, props, hostParent);
      props = ReactDOMOption.getHostProps(this, props);
      break;
    case &#x27;select&#x27;:
      ReactDOMSelect.mountWrapper(this, props, hostParent);
      props = ReactDOMSelect.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
    case &#x27;textarea&#x27;:
      ReactDOMTextarea.mountWrapper(this, props, hostParent);
      props = ReactDOMTextarea.getHostProps(this, props);
      transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
      break;
  }

  assertValidProps(this, props);

  // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.
  var namespaceURI;
  var parentTag;
  if (hostParent != null) {
    namespaceURI = hostParent._namespaceURI;
    parentTag = hostParent._tag;
  } else if (hostContainerInfo._tag) {
    namespaceURI = hostContainerInfo._namespaceURI;
    parentTag = hostContainerInfo._tag;
  }
  if (namespaceURI == null || namespaceURI === DOMNamespaces.svg &#x26;&#x26; parentTag === &#x27;foreignobject&#x27;) {
    namespaceURI = DOMNamespaces.html;
  }
  if (namespaceURI === DOMNamespaces.html) {
    if (this._tag === &#x27;svg&#x27;) {
      namespaceURI = DOMNamespaces.svg;
    } else if (this._tag === &#x27;math&#x27;) {
      namespaceURI = DOMNamespaces.mathml;
    }
  }
  this._namespaceURI = namespaceURI;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var parentInfo;
    if (hostParent != null) {
      parentInfo = hostParent._ancestorInfo;
    } else if (hostContainerInfo._tag) {
      parentInfo = hostContainerInfo._ancestorInfo;
    }
    if (parentInfo) {
      // parentInfo should always be present except for the top-level
      // component when server rendering
      validateDOMNesting(this._tag, null, this, parentInfo);
    }
    this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
  }

  var mountImage;
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var el;
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === &#x27;script&#x27;) {
        // Create the script via .innerHTML so its &#x22;parser-inserted&#x22; flag is
        // set to true and it does not execute
        var div = ownerDocument.createElement(&#x27;div&#x27;);
        var type = this._currentElement.type;
        div.innerHTML = &#x27;&#x3c;&#x27; + type + &#x27;&#x3e;&#x3c;/&#x27; + type + &#x27;&#x3e;&#x27;;
        el = div.removeChild(div.firstChild);
      } else if (props.is) {
        el = ownerDocument.createElement(this._currentElement.type, props.is);
      } else {
        // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
        // See discussion in https://github.com/facebook/react/pull/6896
        // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
        el = ownerDocument.createElement(this._currentElement.type);
      }
    } else {
      el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
    }
    ReactDOMComponentTree.precacheNode(this, el);
    this._flags |= Flags.hasCachedChildNodes;
    if (!this._hostParent) {
      DOMPropertyOperations.setAttributeForRoot(el);
    }
    this._updateDOMProperties(null, pr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.moveChild" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.moveChild">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>moveChild
        <span class="apidocSignatureSpan">(child, afterNode, toIndex, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveChild = function (child, afterNode, toIndex, lastIndex) {
  // If the index of `child` is less than `lastIndex`, then it needs to
  // be moved. Otherwise, we do not need to move it because a child will be
  // inserted or moved before `child`.
  if (child._mountIndex &#x3c; lastIndex) {
    return makeMove(child, afterNode, toIndex);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      for (name in nextChildren) {
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
var prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var nextChild = nextChildren[name];
if (prevChild === nextChild) {
  updates = enqueue(updates, this.<span class="apidocCodeKeywordSpan">moveChild</span>(prevChild, lastPlacedNode, nextIndex, lastIndex
));
  lastIndex = Math.max(prevChild._mountIndex, lastIndex);
  prevChild._mountIndex = nextIndex;
} else {
  if (prevChild) {
    // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
    // The `removedNodes` loop below will actually remove the child.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextElement, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextElement, transaction, context) {
  var prevElement = this._currentElement;
  this._currentElement = nextElement;
  this.updateComponent(transaction, prevElement, nextElement, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.removeChild" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.removeChild">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>removeChild
        <span class="apidocSignatureSpan">(child, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeChild = function (child, node) {
  return makeRemove(child, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.<span class="apidocCodeKeywordSpan">removeChild</span>(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>unmountChildren
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountChildren = function (safely) {
  var renderedChildren = this._renderedChildren;
  ReactChildReconciler.unmountChildren(renderedChildren, safely);
  this._renderedChildren = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} nextContent String of content.
 * @internal
 */
updateTextContent: function (nextContent) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.<span class="apidocCodeKeywordSpan">unmountChildren</span>(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;updateTextContent called on non-empty component
.&#x27;) : _prodInvariant(&#x27;118&#x27;) : void 0;
    }
  }
  // Set new text content.
  var updates = [makeTextContent(nextContent)];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">(safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (safely) {
  switch (this._tag) {
    case &#x27;audio&#x27;:
    case &#x27;form&#x27;:
    case &#x27;iframe&#x27;:
    case &#x27;img&#x27;:
    case &#x27;link&#x27;:
    case &#x27;object&#x27;:
    case &#x27;source&#x27;:
    case &#x27;video&#x27;:
      var listeners = this._wrapperState.listeners;
      if (listeners) {
        for (var i = 0; i &#x3c; listeners.length; i++) {
          listeners[i].remove();
        }
      }
      break;
    case &#x27;html&#x27;:
    case &#x27;head&#x27;:
    case &#x27;body&#x27;:
<span class="apidocCodeCommentSpan">      /**
       * Components like &#x3c;html&#x3e; &#x3c;head&#x3e; and &#x3c;body&#x3e; can&#x27;t be removed or added
       * easily in a cross-browser way, however it&#x27;s valuable to be able to
       * take advantage of React&#x27;s reconciliation for styling and &#x3c;title&#x3e;
       * management. So we just document it and throw in dangerous cases.
       */
</span>      !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;&#x3c;%s&#x3e; tried to unmount. Because of cross-browser quirks
it is impossible to unmount some top-level components (eg &#x3c;html&#x3e;, &#x3c;head&#x3e;, and &#x3c;body&#x3e;) reliably and efficiently. To fix this, have
 a single top-level component that never unmounts render these elements.&#x27;, this._tag) : _prodInvariant(&#x27;66&#x27;, this._tag) : void 0
;
      break;
  }

  this.unmountChildren(safely);
  ReactDOMComponentTree.uncacheNode(this);
  EventPluginHub.deleteAllListeners(this);
  this._rootNodeID = 0;
  this._domID = 0;
  this._wrapperState = null;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    setAndValidateContentChildDev.call(this, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateChildren" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateChildren
        <span class="apidocSignatureSpan">(nextNestedChildrenElements, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateChildren = function (nextNestedChildrenElements, transaction, context) {
  // Hook used by React ART
  this._updateChildren(nextNestedChildrenElements, transaction, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this._currentElement) {
      try {
        ReactCurrentOwner.current = this._currentElement._owner;
        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      } finally {
        ReactCurrentOwner.current = null;
      }
      ReactChildReconciler.<span class="apidocCodeKeywordSpan">updateChildren</span>(prevChildren, nextChildren, mountImages, removedNodes
, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    }
  }
  nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
  ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo
, context, selfDebugID);
  return nextChildren;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateComponent" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateComponent
        <span class="apidocSignatureSpan">(transaction, prevElement, nextElement, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateComponent = function (transaction, prevElement, nextElement, context) {
  var lastProps = prevElement.props;
  var nextProps = this._currentElement.props;

  switch (this._tag) {
    case &#x27;input&#x27;:
      lastProps = ReactDOMInput.getHostProps(this, lastProps);
      nextProps = ReactDOMInput.getHostProps(this, nextProps);
      break;
    case &#x27;option&#x27;:
      lastProps = ReactDOMOption.getHostProps(this, lastProps);
      nextProps = ReactDOMOption.getHostProps(this, nextProps);
      break;
    case &#x27;select&#x27;:
      lastProps = ReactDOMSelect.getHostProps(this, lastProps);
      nextProps = ReactDOMSelect.getHostProps(this, nextProps);
      break;
    case &#x27;textarea&#x27;:
      lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
      nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
      break;
  }

  assertValidProps(this, nextProps);
  this._updateDOMProperties(lastProps, nextProps, transaction);
  this._updateDOMChildren(lastProps, nextProps, transaction, context);

  switch (this._tag) {
    case &#x27;input&#x27;:
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      ReactDOMInput.updateWrapper(this);
      break;
    case &#x27;textarea&#x27;:
      ReactDOMTextarea.updateWrapper(this);
      break;
    case &#x27;select&#x27;:
      // &#x3c;select&#x3e; value update needs to occur after &#x3c;option&#x3e; children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
      break;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

receiveComponent: function (nextElement, transaction, nextContext) {
  var prevElement = this._currentElement;
  var prevContext = this._context;

  this._pendingElement = null;

  this.<span class="apidocCodeKeywordSpan">updateComponent</span>(transaction, prevElement, nextElement, prevContext, nextContext
);
},

/**
 * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
 * is set, update the component.
 *
 * @param {ReactReconcileTransaction} transaction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateMarkup" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateMarkup
        <span class="apidocSignatureSpan">(nextMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMarkup = function (nextMarkup) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.unmountChildren(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;updateTextContent called on non-empty component.&#x27;) : _prodInvariant
(&#x27;118&#x27;) : void 0;
    }
  }
  var updates = [makeSetMarkup(nextMarkup)];
  processQueue(this, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.updateTextContent(&#x27;&#x27; + nextContent);
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      setAndValidateContentChildDev.call(this, nextContent);
    }
  }
} else if (nextHtml != null) {
  if (lastHtml !== nextHtml) {
    this.<span class="apidocCodeKeywordSpan">updateMarkup</span>(&#x27;&#x27; + nextHtml);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
} else if (nextChildren != null) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    setAndValidateContentChildDev.call(this, null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateTextContent" id="apidoc.element.react-test-renderer.ReactDOMComponent.prototype.updateTextContent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponent.prototype.</span>updateTextContent
        <span class="apidocSignatureSpan">(nextContent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTextContent = function (nextContent) {
  var prevChildren = this._renderedChildren;
  // Remove any rendered children.
  ReactChildReconciler.unmountChildren(prevChildren, false);
  for (var name in prevChildren) {
    if (prevChildren.hasOwnProperty(name)) {
      !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;updateTextContent called on non-empty component.&#x27;) : _prodInvariant
(&#x27;118&#x27;) : void 0;
    }
  }
  // Set new text content.
  var updates = [makeTextContent(nextContent)];
  processQueue(this, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we&#x27;re switching from children to content/html or vice versa, remove
// the old content
var lastHasContentOrHtml = lastContent != null || lastHtml != null;
var nextHasContentOrHtml = nextContent != null || nextHtml != null;
if (lastChildren != null &#x26;&#x26; nextChildren == null) {
  this.updateChildren(null, transaction, context);
} else if (lastHasContentOrHtml &#x26;&#x26; !nextHasContentOrHtml) {
  this.<span class="apidocCodeKeywordSpan">updateTextContent</span>(&#x27;&#x27;);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
  }
}

if (nextContent != null) {
  if (lastContent !== nextContent) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMComponentTree" id="apidoc.module.react-test-renderer.ReactDOMComponentTree">module react-test-renderer.ReactDOMComponentTree</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getClosestInstanceFromNode" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.getClosestInstanceFromNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getClosestInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node &#x26;&#x26; (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var from;
var to;
if (topLevelType === &#x27;topMouseOut&#x27;) {
  from = targetInst;
  var related = nativeEvent.relatedTarget || nativeEvent.toElement;
  to = related ? ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">getClosestInstanceFromNode</span>(related) : null;
} else {
  // Moving to a node from outside the window.
  from = null;
  to = targetInst;
}

if (from === to) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getInstanceFromNode" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.getInstanceFromNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getInstanceFromNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null &#x26;&#x26; inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

executeDirectDispatch: executeDirectDispatch,
executeDispatchesInOrder: executeDispatchesInOrder,
executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
hasDispatches: hasDispatches,

getInstanceFromNode: function (node) {
  return ComponentTree.<span class="apidocCodeKeywordSpan">getInstanceFromNode</span>(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.getNodeFromInstance" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.getNodeFromInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>getNodeFromInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;getNodeFromInstance: Invalid argument
.&#x27;) : _prodInvariant(&#x27;33&#x27;) : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;React DOM tree root should always have a node
reference.&#x27;) : _prodInvariant(&#x27;34&#x27;) : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || &#x27;unknown-event&#x27;;
  event.currentTarget = EventPluginUtils.<span class="apidocCodeKeywordSpan">getNodeFromInstance</span>(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheChildNodes" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheChildNodes">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>precacheChildNodes
        <span class="apidocSignatureSpan">(inst, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function precacheChildNodes(inst, node) {
  if (inst._flags &#x26; Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We&#x27;re currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Unable to find element with ID %s.&#x27;, childID) : _prodInvariant
(&#x27;32&#x27;, childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheNode" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.precacheNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>precacheNode
        <span class="apidocSignatureSpan">(inst, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // See discussion in https://github.com/facebook/react/pull/6896
    // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
    el = ownerDocument.createElement(this._currentElement.type);
  }
} else {
  el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
}
ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">precacheNode</span>(this, el);
this._flags |= Flags.hasCachedChildNodes;
if (!this._hostParent) {
  DOMPropertyOperations.setAttributeForRoot(el);
}
this._updateDOMProperties(null, props, transaction);
var lazyTree = DOMLazyTree(el);
this._createInitialChildren(transaction, props, context, lazyTree);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMComponentTree.uncacheNode" id="apidoc.element.react-test-renderer.ReactDOMComponentTree.uncacheNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMComponentTree.</span>uncacheNode
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * management. So we just document it and throw in dangerous cases.
     */
    !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;&#x3c;%s&#x3e; tried to unmount. Because of
 cross-browser quirks it is impossible to unmount some top-level components (eg &#x3c;html&#x3e;, &#x3c;head&#x3e;, and &#x3c;body
&#x3e;) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.&#x27
;, this._tag) : _prodInvariant(&#x27;66&#x27;, this._tag) : void 0;
    break;
}

this.unmountChildren(safely);
ReactDOMComponentTree.<span class="apidocCodeKeywordSpan">uncacheNode</span>(this);
EventPluginHub.deleteAllListeners(this);
this._rootNodeID = 0;
this._domID = 0;
this._wrapperState = null;

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  setAndValidateContentChildDev.call(this, null);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMEmptyComponent" id="apidoc.module.react-test-renderer.ReactDOMEmptyComponent">module react-test-renderer.ReactDOMEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.ReactDOMEmptyComponent" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent.ReactDOMEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMEmptyComponent
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMEmptyComponent.prototype" id="apidoc.module.react-test-renderer.ReactDOMEmptyComponent.prototype">module react-test-renderer.ReactDOMEmptyComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactDOMComponentTree.getNodeFromInstance(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  var domID = hostContainerInfo._idCounter++;
  this._domID = domID;
  this._hostParent = hostParent;
  this._hostContainerInfo = hostContainerInfo;

  var nodeValue = &#x27; react-empty: &#x27; + this._domID + &#x27; &#x27;;
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var node = ownerDocument.createComment(nodeValue);
    ReactDOMComponentTree.precacheNode(this, node);
    return DOMLazyTree(node);
  } else {
    if (transaction.renderToStaticMarkup) {
      // Normally we&#x27;d insert a comment node, but since this is a situation
      // where React won&#x27;t take over (static pages), we can simply return
      // nothing.
      return &#x27;&#x27;;
    }
    return &#x27;&#x3c;!--&#x27; + nodeValue + &#x27;--&#x3e;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactDOMEmptyComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMEmptyComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  ReactDOMComponentTree.uncacheNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMIDOperations" id="apidoc.module.react-test-renderer.ReactDOMIDOperations">module react-test-renderer.ReactDOMIDOperations</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates" id="apidoc.element.react-test-renderer.ReactDOMIDOperations.dangerouslyProcessChildrenUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMIDOperations.</span>dangerouslyProcessChildrenUpdates
        <span class="apidocSignatureSpan">(parentInst, updates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dangerouslyProcessChildrenUpdates = function (parentInst, updates) {
  var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
  DOMChildrenOperations.processUpdates(node, updates);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMInput" id="apidoc.module.react-test-renderer.ReactDOMInput">module react-test-renderer.ReactDOMInput</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInput.getHostProps" id="apidoc.element.react-test-renderer.ReactDOMInput.getHostProps">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  var value = LinkedValueUtils.getValue(props);
  var checked = LinkedValueUtils.getChecked(props);

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min &#x26; .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : inst._wrapperState.initialValue,
    checked: checked != null ? checked : inst._wrapperState.initialChecked,
    onChange: inst._wrapperState.onChange
  });

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case &#x27;select&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInput.mountWrapper" id="apidoc.element.react-test-renderer.ReactDOMInput.mountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    LinkedValueUtils.checkPropTypes(&#x27;input&#x27;, props, inst._currentElement._owner);

    var owner = inst._currentElement._owner;

    if (props.valueLink !== undefined &#x26;&#x26; !didWarnValueLink) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;`valueLink` prop on `input` is deprecated; set `value` and `onChange
` instead.&#x27;) : void 0;
      didWarnValueLink = true;
    }
    if (props.checkedLink !== undefined &#x26;&#x26; !didWarnCheckedLink) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;`checkedLink` prop on `input` is deprecated; set `value` and `onChange
` instead.&#x27;) : void 0;
      didWarnCheckedLink = true;
    }
    if (props.checked !== undefined &#x26;&#x26; props.defaultChecked !== undefined &#x26;&#x26; !didWarnCheckedDefaultChecked) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;%s contains an input of type %s with both checked and defaultChecked
 props. &#x27; + &#x27;Input elements must be either controlled or uncontrolled &#x27; + &#x27;(specify either the checked prop, or the defaultChecked
 prop, but not &#x27; + &#x27;both). Decide between using a controlled or uncontrolled input &#x27; + &#x27;element and remove one of these props. More
 info: &#x27; + &#x27;https://fb.me/react-controlled-components&#x27;, owner &#x26;&#x26; owner.getName() || &#x27;A component&#x27;, props.type) : void 0;
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined &#x26;&#x26; props.defaultValue !== undefined &#x26;&#x26; !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;%s contains an input of type %s with both value and defaultValue props
. &#x27; + &#x27;Input elements must be either controlled or uncontrolled &#x27; + &#x27;(specify either the value prop, or the defaultValue prop, but
 not &#x27; + &#x27;both). Decide between using a controlled or uncontrolled input &#x27; + &#x27;element and remove one of these props. More info: &#x27; + &#x27;
https://fb.me/react-controlled-components&#x27;, owner &#x26;&#x26; owner.getName() || &#x27;A component&#x27;, props.type) : void 0;
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  inst._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    listeners: null,
    onChange: _handleChange.bind(inst),
    controlled: isControlled(props)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;video&#x27;:
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInput.postMountWrapper" id="apidoc.element.react-test-renderer.ReactDOMInput.postMountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  var props = inst._currentElement.props;

  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var node = ReactDOMComponentTree.getNodeFromInstance(inst);

  // Detach value from defaultValue. We won&#x27;t do anything if we&#x27;re working on
  // submit or reset inputs as those values &#x26; defaultValues are linked. They
  // are not resetable nodes so this operation doesn&#x27;t matter and actually
  // removes browser-default values (eg &#x22;Submit Query&#x22;) when no value is
  // provided.

  switch (props.type) {
    case &#x27;submit&#x27;:
    case &#x27;reset&#x27;:
      break;
    case &#x27;color&#x27;:
    case &#x27;date&#x27;:
    case &#x27;datetime&#x27;:
    case &#x27;datetime-local&#x27;:
    case &#x27;month&#x27;:
    case &#x27;time&#x27;:
    case &#x27;week&#x27;:
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = &#x27;&#x27;;
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we&#x27;d just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== &#x27;&#x27;) {
    node.name = &#x27;&#x27;;
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== &#x27;&#x27;) {
    node.name = name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInput.updateWrapper" id="apidoc.element.react-test-renderer.ReactDOMInput.updateWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInput.</span>updateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateWrapper = function (inst) {
  var props = inst._currentElement.props;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var controlled = isControlled(props);
    var owner = inst._currentElement._owner;

    if (!inst._wrapperState.controlled &#x26;&#x26; controlled &#x26;&#x26; !didWarnUncontrolledToControlled) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;%s is changing an uncontrolled input of type %s to be controlled. &#x27; + &#x27;
Input elements should not switch from uncontrolled to controlled (or vice versa). &#x27; + &#x27;Decide between using a controlled or uncontrolled
 input &#x27; + &#x27;element for the lifetime of the component. More info: https://fb.me/react-controlled-components&#x27;, owner &#x26;&#x26; owner.getName
() || &#x27;A component&#x27;, props.type) : void 0;
      didWarnUncontrolledToControlled = true;
    }
    if (inst._wrapperState.controlled &#x26;&#x26; !controlled &#x26;&#x26; !didWarnControlledToUncontrolled) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;%s is changing a controlled input of type %s to be uncontrolled. &#x27; + &#x27;
Input elements should not switch from controlled to uncontrolled (or vice versa). &#x27; + &#x27;Decide between using a controlled or uncontrolled
 input &#x27; + &#x27;element for the lifetime of the component. More info: https://fb.me/react-controlled-components&#x27;, owner &#x26;&#x26; owner.getName
() || &#x27;A component&#x27;, props.type) : void 0;
      didWarnControlledToUncontrolled = true;
    }
  }

  // TODO: Shouldn&#x27;t this be getChecked(props)?
  var checked = props.checked;
  if (checked != null) {
    DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), &#x27;checked&#x27;, checked || false);
  }

  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    if (value === 0 &#x26;&#x26; node.value === &#x27;&#x27;) {
      node.value = &#x27;0&#x27;;
      // Note: IE9 reports a number inputs as &#x27;text&#x27;, so check props instead.
    } else if (props.type === &#x27;number&#x27;) {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value, 10) || 0;

      // eslint-disable-next-line
      if (value != valueAsNumber) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn&#x27;t.
        node.value = &#x27;&#x27; + value;
      }
      // eslint-disable-next-line
    } else if (value != node.value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn&#x27;t.
      node.value = &#x27;&#x27; + value;
    }
  } else {
    if (props.value == null &#x26;&#x26; props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises &#x22;The specified value &#x3c;x&#x3e; is not a valid email address&#x22;.
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== &#x27;&#x27; + props.defaultValue) {
        node.defaultValue = &#x27;&#x27; + props.defaultValue;
      }
    }
    if (props.checked == null &#x26;&#x26; props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._updateDOMChildren(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case &#x27;input&#x27;:
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.<span class="apidocCodeKeywordSpan">updateWrapper</span>(this);
    break;
  case &#x27;textarea&#x27;:
    ReactDOMTextarea.updateWrapper(this);
    break;
  case &#x27;select&#x27;:
    // &#x3c;select&#x3e; value update needs to occur after &#x3c;option&#x3e; children
    // reconciliation
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMInvalidARIAHook" id="apidoc.module.react-test-renderer.ReactDOMInvalidARIAHook">module react-test-renderer.ReactDOMInvalidARIAHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeMountComponent" id="apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInvalidARIAHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    handleElement(debugID, element);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @internal
 */
mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production
 and for roots
) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(internalInstance._debugID
, internalInstance._currentElement, parentDebugID);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeUpdateComponent" id="apidoc.element.react-test-renderer.ReactDOMInvalidARIAHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMInvalidARIAHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    handleElement(debugID, element);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // TODO: Bailing out early is just a perf optimization right?
  // TODO: Removing the return statement should affect correctness?
  return;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(internalInstance._debugID,
nextElement);
  }
}

var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMNullInputValuePropHook" id="apidoc.module.react-test-renderer.ReactDOMNullInputValuePropHook">module react-test-renderer.ReactDOMNullInputValuePropHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeMountComponent" id="apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMNullInputValuePropHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @internal
 */
mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production
 and for roots
) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(internalInstance._debugID
, internalInstance._currentElement, parentDebugID);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent" id="apidoc.element.react-test-renderer.ReactDOMNullInputValuePropHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMNullInputValuePropHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // TODO: Bailing out early is just a perf optimization right?
  // TODO: Removing the return statement should affect correctness?
  return;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(internalInstance._debugID,
nextElement);
  }
}

var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMOption" id="apidoc.module.react-test-renderer.ReactDOMOption">module react-test-renderer.ReactDOMOption</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMOption.getHostProps" id="apidoc.element.react-test-renderer.ReactDOMOption.getHostProps">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  var hostProps = _assign({ selected: undefined, children: undefined }, props);

  // Read state only from initial mount because &#x3c;select&#x3e; updates value
  // manually; we need the initial state only for server rendering
  if (inst._wrapperState.selected != null) {
    hostProps.selected = inst._wrapperState.selected;
  }

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case &#x27;select&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMOption.mountWrapper" id="apidoc.element.react-test-renderer.ReactDOMOption.mountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props, hostParent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props, hostParent) {
  // TODO (yungsters): Remove support for `selected` in &#x3c;option&#x3e;.
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(props.selected == null, &#x27;Use the `defaultValue` or `value` props on &#x3c;select&#x3e;
instead of &#x27; + &#x27;setting `selected` on &#x3c;option&#x3e;.&#x27;) : void 0;
  }

  // Look up whether this option is &#x27;selected&#x27;
  var selectValue = null;
  if (hostParent != null) {
    var selectParent = hostParent;

    if (selectParent._tag === &#x27;optgroup&#x27;) {
      selectParent = selectParent._hostParent;
    }

    if (selectParent != null &#x26;&#x26; selectParent._tag === &#x27;select&#x27;) {
      selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
    }
  }

  // If the value is null (e.g., no specified value or after initial mount)
  // or missing (e.g., for &#x3c;datalist&#x3e;), we don&#x27;t change props.selected
  var selected = null;
  if (selectValue != null) {
    var value;
    if (props.value != null) {
      value = props.value + &#x27;&#x27;;
    } else {
      value = flattenChildren(props.children);
    }
    selected = false;
    if (Array.isArray(selectValue)) {
      // multiple
      for (var i = 0; i &#x3c; selectValue.length; i++) {
        if (&#x27;&#x27; + selectValue[i] === value) {
          selected = true;
          break;
        }
      }
    } else {
      selected = &#x27;&#x27; + selectValue === value;
    }
  }

  inst._wrapperState = { selected: selected };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;video&#x27;:
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMOption.postMountWrapper" id="apidoc.element.react-test-renderer.ReactDOMOption.postMountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMOption.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  // value=&#x22;&#x22; should make a value attribute (#6219)
  var props = inst._currentElement.props;
  if (props.value != null) {
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    node.setAttribute(&#x27;value&#x27;, props.value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMSelect" id="apidoc.module.react-test-renderer.ReactDOMSelect">module react-test-renderer.ReactDOMSelect</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelect.getHostProps" id="apidoc.element.react-test-renderer.ReactDOMSelect.getHostProps">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  return _assign({}, props, {
    onChange: inst._wrapperState.onChange,
    value: undefined
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case &#x27;select&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelect.getSelectValueContext" id="apidoc.element.react-test-renderer.ReactDOMSelect.getSelectValueContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>getSelectValueContext
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelectValueContext = function (inst) {
  // ReactDOMOption looks at this initial value so the initial generated
  // markup has correct `selected` attributes
  return inst._wrapperState.initialValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var selectParent = hostParent;

  if (selectParent._tag === &#x27;optgroup&#x27;) {
    selectParent = selectParent._hostParent;
  }

  if (selectParent != null &#x26;&#x26; selectParent._tag === &#x27;select&#x27;) {
    selectValue = ReactDOMSelect.<span class="apidocCodeKeywordSpan">getSelectValueContext</span>(selectParent);
  }
}

// If the value is null (e.g., no specified value or after initial mount)
// or missing (e.g., for &#x3c;datalist&#x3e;), we don&#x27;t change props.selected
var selected = null;
if (selectValue != null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelect.mountWrapper" id="apidoc.element.react-test-renderer.ReactDOMSelect.mountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    checkSelectPropTypes(inst, props);
  }

  var value = LinkedValueUtils.getValue(props);
  inst._wrapperState = {
    pendingUpdate: false,
    initialValue: value != null ? value : props.defaultValue,
    listeners: null,
    onChange: _handleChange.bind(inst),
    wasMultiple: Boolean(props.multiple)
  };

  if (props.value !== undefined &#x26;&#x26; props.defaultValue !== undefined &#x26;&#x26; !didWarnValueDefaultValue) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;Select elements must be either controlled or uncontrolled &#x27; + &#x27;(specify
 either the value prop, or the defaultValue prop, but not &#x27; + &#x27;both). Decide between using a controlled or uncontrolled select &#x27; + &#x27;
element and remove one of these props. More info: &#x27; + &#x27;https://fb.me/react-controlled-components&#x27;) : void 0;
    didWarnValueDefaultValue = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;video&#x27;:
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelect.postUpdateWrapper" id="apidoc.element.react-test-renderer.ReactDOMSelect.postUpdateWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelect.</span>postUpdateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postUpdateWrapper = function (inst) {
  var props = inst._currentElement.props;

  // After the initial mount, we control selected-ness manually so don&#x27;t pass
  // this value down
  inst._wrapperState.initialValue = undefined;

  var wasMultiple = inst._wrapperState.wasMultiple;
  inst._wrapperState.wasMultiple = Boolean(props.multiple);

  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    inst._wrapperState.pendingUpdate = false;
    updateOptions(inst, Boolean(props.multiple), value);
  } else if (wasMultiple !== Boolean(props.multiple)) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(inst, Boolean(props.multiple), props.defaultValue);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : &#x27;&#x27;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case &#x27;textarea&#x27;:
    inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(&#x27;topInvalid&#x27;, &#x27;invalid&#x27;, node)];
    break;
}
}

function postUpdateSelectWrapper() {
ReactDOMSelect.<span class="apidocCodeKeywordSpan">postUpdateWrapper</span>(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
&#x27;area&#x27;: true,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMSelection" id="apidoc.module.react-test-renderer.ReactDOMSelection">module react-test-renderer.ReactDOMSelection</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelection.getOffsets" id="apidoc.element.react-test-renderer.ReactDOMSelection.getOffsets">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelection.</span>getOffsets
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getModernOffsets(node) {
  var selection = window.getSelection &#x26;&#x26; window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be &#x22;anonymous
  // divs&#x22;, e.g. the up/down buttons on an &#x3c;input type=&#x22;number&#x22;&#x3e;. Anonymous
  // divs do not seem to expose properties, triggering a &#x22;Permission denied
  // error&#x22; if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
<span class="apidocCodeCommentSpan">    /* eslint-disable no-unused-expressions */
</span>    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset
);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset
);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      selection = {
        start: -range.moveStart(&#x27;character&#x27;, -input.value.length),
        end: -range.moveEnd(&#x27;character&#x27;, -input.value.length)
      };
    }
  } else {
    // Content editable or old IE textarea.
    selection = ReactDOMSelection.<span class="apidocCodeKeywordSpan">getOffsets</span>(input);
  }

  return selection || { start: 0, end: 0 };
},

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMSelection.setOffsets" id="apidoc.element.react-test-renderer.ReactDOMSelection.setOffsets">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMSelection.</span>setOffsets
        <span class="apidocSignatureSpan">(node, offsets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn&#x27;t support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend &#x26;&#x26; start &#x3e; end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker &#x26;&#x26; endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start &#x3e; end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (document.selection &#x26;&#x26; input.nodeName &#x26;&#x26; input.nodeName.toLowerCase() === &#x27;input&#x27;) {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart(&#x27;character&#x27;, start);
      range.moveEnd(&#x27;character&#x27;, end - start);
      range.select();
    } else {
      ReactDOMSelection.<span class="apidocCodeKeywordSpan">setOffsets</span>(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMServer" id="apidoc.module.react-test-renderer.ReactDOMServer">module react-test-renderer.ReactDOMServer</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMServer.renderToStaticMarkup" id="apidoc.element.react-test-renderer.ReactDOMServer.renderToStaticMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMServer.</span>renderToStaticMarkup
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToStaticMarkup(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;renderToStaticMarkup(): You must pass
 a valid ReactElement.&#x27;) : _prodInvariant(&#x27;47&#x27;) : void 0;
  return renderToStringImpl(element, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMServer.renderToString" id="apidoc.element.react-test-renderer.ReactDOMServer.renderToString">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMServer.</span>renderToString
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToString(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;renderToString(): You must pass a valid
 ReactElement.&#x27;) : _prodInvariant(&#x27;46&#x27;) : void 0;
  return renderToStringImpl(element, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
!ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup
(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React
when unit testing or use ReactDOMServer.<span class="apidocCodeKeywordSpan">renderToString</span>() for server rendering.&#x27;) :
_prodInvariant(&#x27;56&#x27;) : void 0;
!markup ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...): Missing
 markup.&#x27;) : _prodInvariant(&#x27;57&#x27;) : void 0;
!(oldChild.nodeName !== &#x27;HTML&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup
(...): Cannot replace markup of the &#x3c;html&#x3e; node. This is because browser quirks make this unreliable and/or slow. If you
 want to render to the root you must use server rendering. See ReactDOMServer.renderToString().&#x27;) : _prodInvariant(&#x27;58
&#x27;) : void 0;

if (typeof markup === &#x27;string&#x27;) {
  var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
  oldChild.parentNode.replaceChild(newChild, oldChild);
} else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMTextComponent" id="apidoc.module.react-test-renderer.ReactDOMTextComponent">module react-test-renderer.ReactDOMTextComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.ReactDOMTextComponent" id="apidoc.element.react-test-renderer.ReactDOMTextComponent.ReactDOMTextComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactDOMTextComponent
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = &#x27;&#x27; + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMTextComponent.prototype" id="apidoc.module.react-test-renderer.ReactDOMTextComponent.prototype">module react-test-renderer.ReactDOMTextComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  var hostNode = this._commentNodes;
  if (hostNode) {
    return hostNode;
  }
  if (!this._closingComment) {
    var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
    var node = openingComment.nextSibling;
    while (true) {
      !(node != null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Missing closing comment for text component %s&#x27;,
this._domID) : _prodInvariant(&#x27;67&#x27;, this._domID) : void 0;
      if (node.nodeType === 8 &#x26;&#x26; node.nodeValue === &#x27; /react-text &#x27;) {
        this._closingComment = node;
        break;
      }
      node = node.nextSibling;
    }
  }
  hostNode = [this._hostNode, this._closingComment];
  this._commentNodes = hostNode;
  return hostNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var parentInfo;
    if (hostParent != null) {
      parentInfo = hostParent._ancestorInfo;
    } else if (hostContainerInfo != null) {
      parentInfo = hostContainerInfo._ancestorInfo;
    }
    if (parentInfo) {
      // parentInfo should always be present except for the top-level
      // component when server rendering
      validateDOMNesting(null, this._stringText, this, parentInfo);
    }
  }

  var domID = hostContainerInfo._idCounter++;
  var openingValue = &#x27; react-text: &#x27; + domID + &#x27; &#x27;;
  var closingValue = &#x27; /react-text &#x27;;
  this._domID = domID;
  this._hostParent = hostParent;
  if (transaction.useCreateElement) {
    var ownerDocument = hostContainerInfo._ownerDocument;
    var openingComment = ownerDocument.createComment(openingValue);
    var closingComment = ownerDocument.createComment(closingValue);
    var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
    DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
    if (this._stringText) {
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
    }
    DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
    ReactDOMComponentTree.precacheNode(this, openingComment);
    this._closingComment = closingComment;
    return lazyTree;
  } else {
    var escapedText = escapeTextContentForBrowser(this._stringText);

    if (transaction.renderToStaticMarkup) {
      // Normally we&#x27;d wrap this between comment nodes for the reasons stated
      // above, but since this is a situation where React won&#x27;t take over
      // (static pages), we can simply return the text as it is.
      return escapedText;
    }

    return &#x27;&#x3c;!--&#x27; + openingValue + &#x27;--&#x3e;&#x27; + escapedText + &#x27;&#x3c;!--&#x27; + closingValue + &#x27;--&#x3e;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextText, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (nextText, transaction) {
  if (nextText !== this._currentElement) {
    this._currentElement = nextText;
    var nextStringText = &#x27;&#x27; + nextText;
    if (nextStringText !== this._stringText) {
      // TODO: Save this as pending props and use performUpdateIfNecessary
      // and/or updateComponent to do the actual update for consistency with
      // other component types?
      this._stringText = nextStringText;
      var commentNodes = this.getHostNode();
      DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactDOMTextComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  this._closingComment = null;
  this._commentNodes = null;
  ReactDOMComponentTree.uncacheNode(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMTextarea" id="apidoc.module.react-test-renderer.ReactDOMTextarea">module react-test-renderer.ReactDOMTextarea</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextarea.getHostProps" id="apidoc.element.react-test-renderer.ReactDOMTextarea.getHostProps">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>getHostProps
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostProps = function (inst, props) {
  !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;`dangerouslySetInnerHTML`
does not make sense on &#x3c;textarea&#x3e;.&#x27;) : _prodInvariant(&#x27;91&#x27;) : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
  // The value can be a boolean or object so that&#x27;s why it&#x27;s forced to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: &#x27;&#x27; + inst._wrapperState.initialValue,
    onChange: inst._wrapperState.onChange
  });

  return hostProps;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.mountWrapper(this, props, hostParent);
  props = ReactDOMInput.<span class="apidocCodeKeywordSpan">getHostProps</span>(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
case &#x27;select&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextarea.mountWrapper" id="apidoc.element.react-test-renderer.ReactDOMTextarea.mountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>mountWrapper
        <span class="apidocSignatureSpan">(inst, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountWrapper = function (inst, props) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    LinkedValueUtils.checkPropTypes(&#x27;textarea&#x27;, props, inst._currentElement._owner);
    if (props.valueLink !== undefined &#x26;&#x26; !didWarnValueLink) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;`valueLink` prop on `textarea` is deprecated; set `value` and `onChange
` instead.&#x27;) : void 0;
      didWarnValueLink = true;
    }
    if (props.value !== undefined &#x26;&#x26; props.defaultValue !== undefined &#x26;&#x26; !didWarnValDefaultVal) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;Textarea elements must be either controlled or uncontrolled &#x27; + &#x27;(
specify either the value prop, or the defaultValue prop, but not &#x27; + &#x27;both). Decide between using a controlled or uncontrolled textarea
 &#x27; + &#x27;and remove one of these props. More info: &#x27; + &#x27;https://fb.me/react-controlled-components&#x27;) : void 0;
      didWarnValDefaultVal = true;
    }
  }

  var value = LinkedValueUtils.getValue(props);
  var initialValue = value;

  // Only bother fetching default value if we&#x27;re going to use it
  if (value == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in &#x3c;textarea&#x3e;.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;Use the `defaultValue` or `value` props instead of setting &#x27; + &#x27;
children on &#x3c;textarea&#x3e;.&#x27;) : void 0;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;If you supply `defaultValue` on a &#x3c;textarea
&#x3e;, do not pass children.&#x27;) : _prodInvariant(&#x27;92&#x27;) : void 0;
      if (Array.isArray(children)) {
        !(children.length &#x3c;= 1) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;&#x3c;textarea&#x3e; can only have at most one
 child.&#x27;) : _prodInvariant(&#x27;93&#x27;) : void 0;
        children = children[0];
      }

      defaultValue = &#x27;&#x27; + children;
    }
    if (defaultValue == null) {
      defaultValue = &#x27;&#x27;;
    }
    initialValue = defaultValue;
  }

  inst._wrapperState = {
    initialValue: &#x27;&#x27; + initialValue,
    listeners: null,
    onChange: _handleChange.bind(inst)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;video&#x27;:
  this._wrapperState = {
    listeners: null
  };
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;input&#x27;:
  ReactDOMInput.<span class="apidocCodeKeywordSpan">mountWrapper</span>(this, props, hostParent);
  props = ReactDOMInput.getHostProps(this, props);
  transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
  break;
case &#x27;option&#x27;:
  ReactDOMOption.mountWrapper(this, props, hostParent);
  props = ReactDOMOption.getHostProps(this, props);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextarea.postMountWrapper" id="apidoc.element.react-test-renderer.ReactDOMTextarea.postMountWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>postMountWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postMountWrapper = function (inst) {
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === inst._wrapperState.initialValue) {
    node.value = textContent;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.<span class="apidocCodeKeywordSpan">postMountWrapper</span>(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTextarea.updateWrapper" id="apidoc.element.react-test-renderer.ReactDOMTextarea.updateWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTextarea.</span>updateWrapper
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateWrapper = function (inst) {
  var props = inst._currentElement.props;

  var node = ReactDOMComponentTree.getNodeFromInstance(inst);
  var value = LinkedValueUtils.getValue(props);
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn&#x27;t.
    var newValue = &#x27;&#x27; + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._updateDOMChildren(lastProps, nextProps, transaction, context);

switch (this._tag) {
  case &#x27;input&#x27;:
    // Update the wrapper around inputs *after* updating props. This has to
    // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
    // raise warnings and prevent the new value from being assigned.
    ReactDOMInput.<span class="apidocCodeKeywordSpan">updateWrapper</span>(this);
    break;
  case &#x27;textarea&#x27;:
    ReactDOMTextarea.updateWrapper(this);
    break;
  case &#x27;select&#x27;:
    // &#x3c;select&#x3e; value update needs to occur after &#x3c;option&#x3e; children
    // reconciliation
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMTreeTraversal" id="apidoc.module.react-test-renderer.ReactDOMTreeTraversal">module react-test-renderer.ReactDOMTreeTraversal</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getLowestCommonAncestor" id="apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getLowestCommonAncestor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>getLowestCommonAncestor
        <span class="apidocSignatureSpan">(instA, instB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowestCommonAncestor(instA, instB) {
  !(&#x27;_hostNode&#x27; in instA) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;getNodeFromInstance: Invalid argument.&#x27;) :
_prodInvariant(&#x27;33&#x27;) : void 0;
  !(&#x27;_hostNode&#x27; in instB) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;getNodeFromInstance: Invalid argument.&#x27;) :
_prodInvariant(&#x27;33&#x27;) : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB &#x3e; 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA &#x3e; 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getLowestCommonAncestor</span>(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getParentInstance" id="apidoc.element.react-test-renderer.ReactDOMTreeTraversal.getParentInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>getParentInstance
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getParentInstance(inst) {
  !(&#x27;_hostNode&#x27; in inst) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;getParentInstance: Invalid argument.&#x27;) : _prodInvariant
(&#x27;36&#x27;) : void 0;

  return inst._hostParent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAncestor: function (a, b) {
  return TreeTraversal.isAncestor(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">getParentInstance</span>(inst);
},
traverseTwoPhase: function (target, fn, arg) {
  return TreeTraversal.traverseTwoPhase(target, fn, arg);
},
traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
  return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.isAncestor" id="apidoc.element.react-test-renderer.ReactDOMTreeTraversal.isAncestor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>isAncestor
        <span class="apidocSignatureSpan">(instA, instB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAncestor(instA, instB) {
  !(&#x27;_hostNode&#x27; in instA) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;isAncestor: Invalid argument.&#x27;) : _prodInvariant
(&#x27;35&#x27;) : void 0;
  !(&#x27;_hostNode&#x27; in instB) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;isAncestor: Invalid argument.&#x27;) : _prodInvariant
(&#x27;35&#x27;) : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getInstanceFromNode: function (node) {
  return ComponentTree.getInstanceFromNode(node);
},
getNodeFromInstance: function (node) {
  return ComponentTree.getNodeFromInstance(node);
},
isAncestor: function (a, b) {
  return TreeTraversal.<span class="apidocCodeKeywordSpan">isAncestor</span>(a, b);
},
getLowestCommonAncestor: function (a, b) {
  return TreeTraversal.getLowestCommonAncestor(a, b);
},
getParentInstance: function (inst) {
  return TreeTraversal.getParentInstance(inst);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseEnterLeave" id="apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseEnterLeave">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>traverseEnterLeave
        <span class="apidocSignatureSpan">(from, to, fn, argFrom, argTo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from &#x26;&#x26; to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from &#x26;&#x26; from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to &#x26;&#x26; to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i &#x3c; pathFrom.length; i++) {
    fn(pathFrom[i], &#x27;bubbled&#x27;, argFrom);
  }
  for (i = pathTo.length; i-- &#x3e; 0;) {
    fn(pathTo[i], &#x27;captured&#x27;, argTo);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseEnterLeave</span>(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseTwoPhase" id="apidoc.element.react-test-renderer.ReactDOMTreeTraversal.traverseTwoPhase">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMTreeTraversal.</span>traverseTwoPhase
        <span class="apidocSignatureSpan">(inst, fn, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- &#x3e; 0;) {
    fn(path[i], &#x27;captured&#x27;, arg);
  }
  for (i = 0; i &#x3c; path.length; i++) {
    fn(path[i], &#x27;bubbled&#x27;, arg);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.<span class="apidocCodeKeywordSpan">traverseTwoPhase</span>(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDOMUnknownPropertyHook" id="apidoc.module.react-test-renderer.ReactDOMUnknownPropertyHook">module react-test-renderer.ReactDOMUnknownPropertyHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeMountComponent" id="apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMUnknownPropertyHook.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @internal
 */
mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production
 and for roots
) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(internalInstance._debugID
, internalInstance._currentElement, parentDebugID);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent" id="apidoc.element.react-test-renderer.ReactDOMUnknownPropertyHook.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDOMUnknownPropertyHook.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  handleElement(debugID, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // TODO: Bailing out early is just a perf optimization right?
  // TODO: Removing the return statement should affect correctness?
  return;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(internalInstance._debugID,
nextElement);
  }
}

var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDebugTool" id="apidoc.module.react-test-renderer.ReactDebugTool">module react-test-renderer.ReactDebugTool</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.addDevtool" id="apidoc.element.react-test-renderer.ReactDebugTool.addDevtool">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>addDevtool
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDevtool = function (hook) {
  hooks.push(hook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.addHook" id="apidoc.element.react-test-renderer.ReactDebugTool.addHook">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>addHook
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHook = function (hook) {
  hooks.push(hook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (isProfiling) {
  return;
}

isProfiling = true;
flushHistory.length = 0;
resetMeasurements();
ReactDebugTool.<span class="apidocCodeKeywordSpan">addHook</span>(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
if (!isProfiling) {
  return;
}

isProfiling = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.beginProfiling" id="apidoc.element.react-test-renderer.ReactDebugTool.beginProfiling">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>beginProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginProfiling = function () {
  if (isProfiling) {
    return;
  }

  isProfiling = true;
  flushHistory.length = 0;
  resetMeasurements();
  ReactDebugTool.addHook(ReactHostOperationHistoryHook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM &#x26;&#x26; window.location.href || &#x27;&#x27;;
if (/[?&#x26;]react_perf\b/.test(url)) {
  ReactDebugTool.<span class="apidocCodeKeywordSpan">beginProfiling</span>();
}

module.exports = ReactDebugTool;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.endProfiling" id="apidoc.element.react-test-renderer.ReactDebugTool.endProfiling">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>endProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endProfiling = function () {
  if (!isProfiling) {
    return;
  }

  isProfiling = false;
  resetMeasurements();
  ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function stop() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
  return;
}

ReactDebugTool.<span class="apidocCodeKeywordSpan">endProfiling</span>();
}

function isRunning() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.getFlushHistory" id="apidoc.element.react-test-renderer.ReactDebugTool.getFlushHistory">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>getFlushHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFlushHistory = function () {
  return flushHistory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getLastMeasurements() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
  return [];
}

return ReactDebugTool.<span class="apidocCodeKeywordSpan">getFlushHistory</span>();
}

function getExclusive() {
var flushHistory = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.isProfiling" id="apidoc.element.react-test-renderer.ReactDebugTool.isProfiling">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>isProfiling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProfiling = function () {
  return isProfiling;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function isRunning() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
  return false;
}

return ReactDebugTool.<span class="apidocCodeKeywordSpan">isProfiling</span>();
}

var ReactPerfAnalysis = {
getLastMeasurements: getLastMeasurements,
getExclusive: getExclusive,
getInclusive: getInclusive,
getWasted: getWasted,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeMountComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeforeMountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeMountComponent
        <span class="apidocSignatureSpan">(debugID, element, parentDebugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeMountComponent = function (debugID, element, parentDebugID) {
  checkDebugID(debugID);
  checkDebugID(parentDebugID, true);
  emitEvent(&#x27;onBeforeMountComponent&#x27;, debugID, element, parentDebugID);
  markBegin(debugID, &#x27;mount&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @final
 * @internal
 */
mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production
 and for roots
) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeMountComponent</span>(internalInstance._debugID
, internalInstance._currentElement, parentDebugID);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUnmountComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUnmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeUnmountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUnmountComponent = function (debugID) {
  checkDebugID(debugID);
  emitEvent(&#x27;onBeforeUnmountComponent&#x27;, debugID);
  markBegin(debugID, &#x27;unmount&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @final
 * @internal
 */
unmountComponent: function (internalInstance, safely) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUnmountComponent</span>(internalInstance._debugID
);
    }
  }
  ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUpdateComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeforeUpdateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeforeUpdateComponent
        <span class="apidocSignatureSpan">(debugID, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeforeUpdateComponent = function (debugID, element) {
  checkDebugID(debugID);
  emitEvent(&#x27;onBeforeUpdateComponent&#x27;, debugID, element);
  markBegin(debugID, &#x27;update&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // TODO: Bailing out early is just a perf optimization right?
  // TODO: Removing the return statement should affect correctness?
  return;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeforeUpdateComponent</span>(internalInstance._debugID,
nextElement);
  }
}

var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginFlush" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeginFlush">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginFlush = function () {
  currentFlushNesting++;
  resetMeasurements();
  pauseCurrentLifeCycleTimer();
  emitEvent(&#x27;onBeginFlush&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginFlush</span>();
}
ReactReconciler.unmountComponent(instance, safely);
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.onEndFlush();
}

if (container.nodeType === DOC_NODE_TYPE) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginLifeCycleTimer" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeginLifeCycleTimer">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginLifeCycleTimer
        <span class="apidocSignatureSpan">(debugID, timerType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginLifeCycleTimer = function (debugID, timerType) {
  checkDebugID(debugID);
  emitEvent(&#x27;onBeginLifeCycleTimer&#x27;, debugID, timerType);
  markBegin(debugID, timerType);
  beginLifeCycleTimer(debugID, timerType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginLifeCycleTimer</span>(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onBeginProcessingChildContext" id="apidoc.element.react-test-renderer.ReactDebugTool.onBeginProcessingChildContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onBeginProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginProcessingChildContext = function () {
  emitEvent(&#x27;onBeginProcessingChildContext&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _processChildContext: function (currentContext) {
var Component = this._currentElement.type;
var inst = this._instance;
var childContext;

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginProcessingChildContext</span>();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.onEndProcessingChildContext();
    }
  } else {
    childContext = inst.getChildContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndFlush" id="apidoc.element.react-test-renderer.ReactDebugTool.onEndFlush">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndFlush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndFlush = function () {
  resetMeasurements();
  currentFlushNesting--;
  resumeCurrentLifeCycleTimer();
  emitEvent(&#x27;onEndFlush&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function unmountComponentFromNode(instance, container, safely) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.onBeginFlush();
}
ReactReconciler.unmountComponent(instance, safely);
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndFlush</span>();
}

if (container.nodeType === DOC_NODE_TYPE) {
  container = container.documentElement;
}

// http://jsperf.com/emptying-a-node
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndLifeCycleTimer" id="apidoc.element.react-test-renderer.ReactDebugTool.onEndLifeCycleTimer">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndLifeCycleTimer
        <span class="apidocSignatureSpan">(debugID, timerType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndLifeCycleTimer = function (debugID, timerType) {
  checkDebugID(debugID);
  endLifeCycleTimer(debugID, timerType);
  markEnd(debugID, timerType);
  emitEvent(&#x27;onEndLifeCycleTimer&#x27;, debugID, timerType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return fn();
 }

 ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
 try {
   return fn();
 } finally {
   ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndLifeCycleTimer</span>(debugID, timerType);
 }
}

/**
* ------------------ The Life-Cycle of a Composite Component ------------------
*
* - constructor: Initialization of state. The instance is now retained.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onEndProcessingChildContext" id="apidoc.element.react-test-renderer.ReactDebugTool.onEndProcessingChildContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onEndProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndProcessingChildContext = function () {
  emitEvent(&#x27;onEndProcessingChildContext&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onBeginProcessingChildContext();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndProcessingChildContext</span>();
    }
  } else {
    childContext = inst.getChildContext();
  }
}

if (childContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onHostOperation" id="apidoc.element.react-test-renderer.ReactDebugTool.onHostOperation">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onHostOperation
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onHostOperation = function (operation) {
  checkDebugID(operation.instanceID);
  emitEvent(&#x27;onHostOperation&#x27;, operation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onHostOperation</span>({
    instanceID: component._debugID,
    type: &#x27;update styles&#x27;,
    payload: styles
  });
}

var style = node.style;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onMountComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onMountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onMountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onMountComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, &#x27;mount&#x27;);
  emitEvent(&#x27;onMountComponent&#x27;, debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onMountComponent</span>(internalInstance._debugID);
    }
  }
  return markup;
},

/**
 * Returns a value that can be passed to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onSetChildren" id="apidoc.element.react-test-renderer.ReactDebugTool.onSetChildren">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onSetChildren
        <span class="apidocSignatureSpan">(debugID, childDebugIDs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetChildren = function (debugID, childDebugIDs) {
  checkDebugID(debugID);
  childDebugIDs.forEach(checkDebugID);
  emitEvent(&#x27;onSetChildren&#x27;, debugID, childDebugIDs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._renderedComponent = child;

  var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (debugID !== 0) {
      var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetChildren</span>(debugID, childDebugIDs);
    }
  }

  return markup;
},

getHostNode: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onSetState" id="apidoc.element.react-test-renderer.ReactDebugTool.onSetState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onSetState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetState = function () {
  emitEvent(&#x27;onSetState&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetState</span>();
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(partialState != null, &#x27;setState(...): You passed an undefined or
 null state object; &#x27; + &#x27;instead, use forceUpdate().&#x27;) : void 0;
}

var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;setState&#x27;);

if (!internalInstance) {
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onTestEvent" id="apidoc.element.react-test-renderer.ReactDebugTool.onTestEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onTestEvent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onTestEvent = function () {
  emitEvent(&#x27;onTestEvent&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onUnmountComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onUnmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onUnmountComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onUnmountComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, &#x27;unmount&#x27;);
  emitEvent(&#x27;onUnmountComponent&#x27;, debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
    }
  }
  ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onUnmountComponent</span>(internalInstance._debugID);
    }
  }
},

/**
 * Update a component using a new element.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.onUpdateComponent" id="apidoc.element.react-test-renderer.ReactDebugTool.onUpdateComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>onUpdateComponent
        <span class="apidocSignatureSpan">(debugID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onUpdateComponent = function (debugID) {
  checkDebugID(debugID);
  markEnd(debugID, &#x27;update&#x27;);
  emitEvent(&#x27;onUpdateComponent&#x27;, debugID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (refsChanged &#x26;&#x26; internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onUpdateComponent</span>(internalInstance._debugID);
    }
  }
},

/**
 * Flush any dirty changes in a component.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.removeDevtool" id="apidoc.element.react-test-renderer.ReactDebugTool.removeDevtool">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>removeDevtool
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDevtool = function (hook) {
  for (var i = 0; i &#x3c; hooks.length; i++) {
    if (hooks[i] === hook) {
      hooks.splice(i, 1);
      i--;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDebugTool.removeHook" id="apidoc.element.react-test-renderer.ReactDebugTool.removeHook">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDebugTool.</span>removeHook
        <span class="apidocSignatureSpan">(hook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeHook = function (hook) {
  for (var i = 0; i &#x3c; hooks.length; i++) {
    if (hooks[i] === hook) {
      hooks.splice(i, 1);
      i--;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
endProfiling: function () {
  if (!isProfiling) {
    return;
  }

  isProfiling = false;
  resetMeasurements();
  ReactDebugTool.<span class="apidocCodeKeywordSpan">removeHook</span>(ReactHostOperationHistoryHook);
},
getFlushHistory: function () {
  return flushHistory;
},
onBeginFlush: function () {
  currentFlushNesting++;
  resetMeasurements();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDefaultBatchingStrategy" id="apidoc.module.react-test-renderer.ReactDefaultBatchingStrategy">module react-test-renderer.ReactDefaultBatchingStrategy</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDefaultBatchingStrategy.batchedUpdates" id="apidoc.element.react-test-renderer.ReactDefaultBatchingStrategy.batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDefaultBatchingStrategy.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batchedUpdates = function (callback, a, b, c, d, e) {
  var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

  ReactDefaultBatchingStrategy.isBatchingUpdates = true;

  // The code is written this way to avoid extra allocations
  if (alreadyBatchingUpdates) {
    return callback(a, b, c, d, e);
  } else {
    return transaction.perform(callback, null, a, b, c, d, e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactTestInstance.prototype.getInstance = function () {
  return this._component._renderedComponent.getPublicInstance();
};
ReactTestInstance.prototype.update = function (nextElement) {
  !this._component ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactTestRenderer: .update() can\&#
x27;t be called after unmount.&#x27;) : _prodInvariant(&#x27;139&#x27;) : void 0;
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
  var component = this._component;
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(function () {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    transaction.perform(function () {
      ReactReconciler.receiveComponent(component, nextWrappedElement, transaction, emptyObject);
    });
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactDefaultInjection" id="apidoc.module.react-test-renderer.ReactDefaultInjection">module react-test-renderer.ReactDefaultInjection</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactDefaultInjection.inject" id="apidoc.element.react-test-renderer.ReactDefaultInjection.inject">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactDefaultInjection.</span>inject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

<span class="apidocCodeCommentSpan">  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
</span>  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReactVersion = require(&#x27;./ReactVersion&#x27;);

var findDOMNode = require(&#x27;./findDOMNode&#x27;);
var getHostComponentFromComposite = require(&#x27;./getHostComponentFromComposite&#x27;);
var renderSubtreeIntoContainer = require(&#x27;./renderSubtreeIntoContainer&#x27;);
var warning = require(&#x27;fbjs/lib/warning&#x27;);

ReactDefaultInjection.<span class="apidocCodeKeywordSpan">inject</span>();

var ReactDOM = {
findDOMNode: findDOMNode,
render: ReactMount.render,
unmountComponentAtNode: ReactMount.unmountComponentAtNode,
version: ReactVersion,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactEmptyComponent" id="apidoc.module.react-test-renderer.ReactEmptyComponent">module react-test-renderer.ReactEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEmptyComponent.create" id="apidoc.element.react-test-renderer.ReactEmptyComponent.create">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEmptyComponent.</span>create
        <span class="apidocSignatureSpan">(instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (instantiate) {
  return emptyComponentFactory(instantiate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Test renderer

Renders React components to pure JavaScript objects without depending on the DOM or a native mobile environment. This makes it easy
 to grab a snapshot of the &#x22;DOM tree&#x22; rendered by a React DOM or React Native component without using a browser or jsdom
.

```jsx
const ReactTestRenderer = require(&#x27;react-test-renderer&#x27;);

const renderer = ReactTestRenderer.<span class="apidocCodeKeywordSpan">create</span>(
  &#x3c;Link page=&#x22;https://www.facebook.com/&#x22;&#x3e;Facebook&#x3c;/Link&#x3e;
);

console.log(renderer.toJSON());
// { type: &#x27;a&#x27;,
//   props: { href: &#x27;https://www.facebook.com/&#x27; },
//   children: [ &#x27;Facebook&#x27; ] }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactErrorUtils" id="apidoc.module.react-test-renderer.ReactErrorUtils">module react-test-renderer.ReactErrorUtils</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallback" id="apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>invokeGuardedCallback
        <span class="apidocSignatureSpan">(name, func, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
function executeDispatch(event, simulated, listener, inst) {
 var type = event.type || &#x27;unknown-event&#x27;;
 event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
 if (simulated) {
   ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
 } else {
   ReactErrorUtils.<span class="apidocCodeKeywordSpan">invokeGuardedCallback</span>(type, listener, event);
 }
 event.currentTarget = null;
}

/**
* Standard/simple iteration through an event&#x27;s collected dispatches.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallbackWithCatch" id="apidoc.element.react-test-renderer.ReactErrorUtils.invokeGuardedCallbackWithCatch">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>invokeGuardedCallbackWithCatch
        <span class="apidocSignatureSpan">(name, func, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || &#x27;unknown-event&#x27;;
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.<span class="apidocCodeKeywordSpan">invokeGuardedCallbackWithCatch</span>(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactErrorUtils.rethrowCaughtError" id="apidoc.element.react-test-renderer.ReactErrorUtils.rethrowCaughtError">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactErrorUtils.</span>rethrowCaughtError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rethrowCaughtError = function () {
  if (caughtError) {
    var error = caughtError;
    caughtError = null;
    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;processEventQueue(): Additional events
 were enqueued while processing an event queue. Support for this has not yet been implemented.&#x27;) : _prodInvariant(&#x27;95&#
x27;) : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.<span class="apidocCodeKeywordSpan">rethrowCaughtError</span>();
},

/**
 * These are needed for tests only. Do not use!
 */
__purge: function () {
  listenerBank = {};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactEventEmitterMixin" id="apidoc.module.react-test-renderer.ReactEventEmitterMixin">module react-test-renderer.ReactEventEmitterMixin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventEmitterMixin.handleTopLevel" id="apidoc.element.react-test-renderer.ReactEventEmitterMixin.handleTopLevel">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventEmitterMixin.</span>handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactEventListener" id="apidoc.module.react-test-renderer.ReactEventListener">module react-test-renderer.ReactEventListener</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener._handleTopLevel" id="apidoc.element.react-test-renderer.ReactEventListener._handleTopLevel">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>_handleTopLevel
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleTopLevel = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &#x26;&#x26; findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i &#x3c; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener.<span class="apidocCodeKeywordSpan">_handleTopLevel</span>(bookKeeping.topLevelType, targetInst, bookKeeping
.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.dispatchEvent" id="apidoc.element.react-test-renderer.ReactEventListener.dispatchEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>dispatchEvent
        <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatchEvent = function (topLevelType, nativeEvent) {
  if (!ReactEventListener._enabled) {
    return;
  }

  var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    TopLevelCallbackBookKeeping.release(bookKeeping);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var fakeNode = document.createElement(&#x27;react&#x27;);
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = &#x27;react-&#x27; + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent(&#x27;Event&#x27;);
      evt.initEvent(evtType, false, false);
      fakeNode.<span class="apidocCodeKeywordSpan">dispatchEvent</span>(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.isEnabled" id="apidoc.element.react-test-renderer.ReactEventListener.isEnabled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>isEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEnabled = function () {
  return ReactEventListener._enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
  return !!(ReactBrowserEventEmitter.ReactEventListener &#x26;&#x26; ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan
">isEnabled</span>());
},

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.monitorScrollValue" id="apidoc.element.react-test-renderer.ReactEventListener.monitorScrollValue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>monitorScrollValue
        <span class="apidocSignatureSpan">(refresh)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monitorScrollValue = function (refresh) {
  var callback = scrollValueMonitor.bind(null, refresh);
  EventListener.listen(window, &#x27;scroll&#x27;, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY &#x26;&#x26; !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">monitorScrollValue</span>(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.setEnabled" id="apidoc.element.react-test-renderer.ReactEventListener.setEnabled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>setEnabled
        <span class="apidocSignatureSpan">(enabled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEnabled = function (enabled) {
  ReactEventListener._enabled = !!enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sets whether or not any created callbacks should be enabled.
 *
 * @param {boolean} enabled True if callbacks should be enabled.
 */
setEnabled: function (enabled) {
  if (ReactBrowserEventEmitter.ReactEventListener) {
    ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">setEnabled</span>(enabled);
  }
},

/**
 * @return {boolean} True if callbacks are enabled.
 */
isEnabled: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.setHandleTopLevel" id="apidoc.element.react-test-renderer.ReactEventListener.setHandleTopLevel">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>setHandleTopLevel
        <span class="apidocSignatureSpan">(handleTopLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHandleTopLevel = function (handleTopLevel) {
  ReactEventListener._handleTopLevel = handleTopLevel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactEventListener: null,

injection: {
  /**
   * @param {object} ReactEventListener
   */
  injectReactEventListener: function (ReactEventListener) {
    ReactEventListener.<span class="apidocCodeKeywordSpan">setHandleTopLevel</span>(ReactBrowserEventEmitter.handleTopLevel);
    ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
  }
},

/**
 * Sets whether or not any created callbacks should be enabled.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.trapBubbledEvent" id="apidoc.element.react-test-renderer.ReactEventListener.trapBubbledEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>trapBubbledEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapBubbledEvent = function (topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

for (var i = 0; i &#x3c; dependencies.length; i++) {
  var dependency = dependencies[i];
  if (!(isListening.hasOwnProperty(dependency) &#x26;&#x26; isListening[dependency])) {
    if (dependency === &#x27;topWheel&#x27;) {
      if (isEventSupported(&#x27;wheel&#x27;)) {
        ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapBubbledEvent</span>(&#x27;topWheel&#
x27;, &#x27;wheel&#x27;, mountAt);
      } else if (isEventSupported(&#x27;mousewheel&#x27;)) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;mousewheel&#x27;, mountAt);
      } else {
        // Firefox needs to capture a different mouse scroll event.
        // @see http://www.quirksmode.org/dom/events/tests/scroll.html
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;DOMMouseScroll&#x27;, mountAt);
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactEventListener.trapCapturedEvent" id="apidoc.element.react-test-renderer.ReactEventListener.trapCapturedEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactEventListener.</span>trapCapturedEvent
        <span class="apidocSignatureSpan">(topLevelType, handlerBaseName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trapCapturedEvent = function (topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Firefox needs to capture a different mouse scroll event.
  // @see http://www.quirksmode.org/dom/events/tests/scroll.html
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topWheel&#x27;, &#x27;DOMMouseScroll&#x27;, mountAt);
}
        } else if (dependency === &#x27;topScroll&#x27;) {

if (isEventSupported(&#x27;scroll&#x27;, true)) {
  ReactBrowserEventEmitter.ReactEventListener.<span class="apidocCodeKeywordSpan">trapCapturedEvent</span>(&#x27;topScroll&#x27;, &#
x27;scroll&#x27;, mountAt);
} else {
  ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(&#x27;topScroll&#x27;, &#x27;scroll&#x27;, ReactBrowserEventEmitter
.ReactEventListener.WINDOW_HANDLE);
}
        } else if (dependency === &#x27;topFocus&#x27; || dependency === &#x27;topBlur&#x27;) {

if (isEventSupported(&#x27;focus&#x27;, true)) {
  ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(&#x27;topFocus&#x27;, &#x27;focus&#x27;, mountAt);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactFiber" id="apidoc.module.react-test-renderer.ReactFiber">module react-test-renderer.ReactFiber</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.cloneFiber" id="apidoc.element.react-test-renderer.ReactFiber.cloneFiber">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>cloneFiber
        <span class="apidocSignatureSpan">(fiber, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneFiber = function (fiber, priorityLevel) {
  // We clone to get a work in progress. That means that this fiber is the
  // current. To make it safe to reuse that fiber later on as work in progress
  // we need to reset its work in progress flag now. We don&#x27;t have an
  // opportunity to do this earlier since we don&#x27;t traverse the tree when
  // the work in progress tree becomes the current tree.
  // fiber.progressedPriority = NoWork;
  // fiber.progressedChild = null;

  // We use a double buffering pooling technique because we know that we&#x27;ll only
  // ever need at most two versions of a tree. We pool the &#x22;other&#x22; unused node
  // that we&#x27;re free to reuse. This is lazily created to avoid allocating extra
  // objects for things that are never updated. It also allow us to reclaim the
  // extra memory if needed.
  var alt = fiber.alternate;
  if (alt) {
    // Whenever we clone, we do so to get a new work in progress.
    // This ensures that we&#x27;ve reset these in the new tree.
    alt.nextEffect = null;
    alt.firstEffect = null;
    alt.lastEffect = null;
  } else {
    // This should not have an alternate already
    alt = createFiber(fiber.tag, fiber.key);
    alt.type = fiber.type;

    alt.progressedChild = fiber.progressedChild;
    alt.progressedPriority = fiber.progressedPriority;

    alt.alternate = fiber;
    fiber.alternate = alt;
  }

  alt.stateNode = fiber.stateNode;
  alt.child = fiber.child;
  alt.sibling = fiber.sibling; // This should always be overridden. TODO: null
  alt.ref = fiber.ref;
  // pendingProps is here for symmetry but is unnecessary in practice for now.
  // TODO: Pass in the new pendingProps as an argument maybe?
  alt.pendingProps = fiber.pendingProps;
  alt.updateQueue = fiber.updateQueue;
  alt.callbackList = fiber.callbackList;
  alt.pendingWorkPriority = priorityLevel;

  alt.memoizedProps = fiber.memoizedProps;
  alt.output = fiber.output;

  return alt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromCoroutine" id="apidoc.element.react-test-renderer.ReactFiber.createFiberFromCoroutine">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromCoroutine
        <span class="apidocSignatureSpan">(coroutine, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromCoroutine = function (coroutine, priorityLevel) {
  var fiber = createFiber(CoroutineComponent, coroutine.key);
  fiber.type = coroutine.handler;
  fiber.pendingProps = coroutine;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromElement" id="apidoc.element.react-test-renderer.ReactFiber.createFiberFromElement">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromElement
        <span class="apidocSignatureSpan">(element, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromElement = function (element, priorityLevel) {
  // $FlowFixMe: ReactElement.key is currently defined as ?string but should be defined as null | string in Flow.
  var fiber = createFiberFromElementType(element.type, element.key);
  fiber.pendingProps = element.props;
  fiber.pendingWorkPriority = priorityLevel;
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromElementType" id="apidoc.element.react-test-renderer.ReactFiber.createFiberFromElementType">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromElementType
        <span class="apidocSignatureSpan">(type, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFiberFromElementType(type, key) {
  var fiber = void 0;
  if (typeof type === &#x27;function&#x27;) {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key) : createFiber(IndeterminateComponent, key);
    fiber.type = type;
  } else if (typeof type === &#x27;string&#x27;) {
    fiber = createFiber(HostComponent, key);
    fiber.type = type;
  } else if (typeof type === &#x27;object&#x27; &#x26;&#x26; type !== null) {
    // Currently assumed to be a continuation and therefore is a fiber already.
    fiber = type;
  } else {
    throw new Error(&#x27;Unknown component type: &#x27; + typeof type);
  }
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.createFiberFromYield" id="apidoc.element.react-test-renderer.ReactFiber.createFiberFromYield">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createFiberFromYield
        <span class="apidocSignatureSpan">(yieldNode, priorityLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberFromYield = function (yieldNode, priorityLevel) {
  var fiber = createFiber(YieldComponent, yieldNode.key);
  fiber.pendingProps = {};
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiber.createHostContainerFiber" id="apidoc.element.react-test-renderer.ReactFiber.createHostContainerFiber">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiber.</span>createHostContainerFiber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createHostContainerFiber = function () {
  var fiber = createFiber(HostContainer, null);
  return fiber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactFiberRoot" id="apidoc.module.react-test-renderer.ReactFiberRoot">module react-test-renderer.ReactFiberRoot</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberRoot.createFiberRoot" id="apidoc.element.react-test-renderer.ReactFiberRoot.createFiberRoot">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberRoot.</span>createFiberRoot
        <span class="apidocSignatureSpan">(containerInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFiberRoot = function (containerInfo) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostContainerFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    isScheduled: false,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactFiberUpdateQueue" id="apidoc.module.react-test-renderer.ReactFiberUpdateQueue">module react-test-renderer.ReactFiberUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addCallbackToQueue" id="apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addCallbackToQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>addCallbackToQueue
        <span class="apidocSignatureSpan">(queue, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCallbackToQueue = function (queue, callback) {
  if (queue.tail.callback) {
    // If the tail already as a callback, add an empty node to queue
    exports.addToQueue(queue, null);
  }
  queue.tail.callback = callback;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addToQueue" id="apidoc.element.react-test-renderer.ReactFiberUpdateQueue.addToQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>addToQueue
        <span class="apidocSignatureSpan">(queue, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToQueue = function (queue, partialState) {
  var node = {
    partialState: partialState,
    callback: null,
    callbackWasCalled: false,
    next: null
  };
  queue.tail.next = node;
  queue.tail = node;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queue.tail = node;
return queue;
};

exports.addCallbackToQueue = function (queue, callback) {
if (queue.tail.callback) {
  // If the tail already as a callback, add an empty node to queue
  exports.<span class="apidocCodeKeywordSpan">addToQueue</span>(queue, null);
}
queue.tail.callback = callback;
return queue;
};

exports.callCallbacks = function (queue, context) {
var node = queue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.callCallbacks" id="apidoc.element.react-test-renderer.ReactFiberUpdateQueue.callCallbacks">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>callCallbacks
        <span class="apidocSignatureSpan">(queue, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callCallbacks = function (queue, context) {
  var node = queue;
  while (node) {
    if (node.callback &#x26;&#x26; !node.callbackWasCalled) {
      node.callbackWasCalled = true;
      node.callback.call(context);
    }
    node = node.next;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.createUpdateQueue" id="apidoc.element.react-test-renderer.ReactFiberUpdateQueue.createUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>createUpdateQueue
        <span class="apidocSignatureSpan">(partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdateQueue = function (partialState) {
  var queue = {
    partialState: partialState,
    callback: null,
    callbackWasCalled: false,
    next: null,
    isReplace: false,
    isForced: false,
    tail: null
  };
  queue.tail = queue;
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactFiberUpdateQueue.mergeUpdateQueue" id="apidoc.element.react-test-renderer.ReactFiberUpdateQueue.mergeUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactFiberUpdateQueue.</span>mergeUpdateQueue
        <span class="apidocSignatureSpan">(queue, prevState, props)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeUpdateQueue = function (queue, prevState, props) {
  var node = queue;
  var state = queue.isReplace ? null : _assign({}, prevState);
  while (node) {
    var _partialState = void 0;
    if (typeof node.partialState === &#x27;function&#x27;) {
      var updateFn = node.partialState;
      _partialState = updateFn(state, props);
    } else {
      _partialState = node.partialState;
    }
    state = _assign(state || {}, _partialState);
    node = node.next;
  }
  return state;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactHostComponent" id="apidoc.module.react-test-renderer.ReactHostComponent">module react-test-renderer.ReactHostComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostComponent.createInstanceForText" id="apidoc.element.react-test-renderer.ReactHostComponent.createInstanceForText">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>createInstanceForText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createInstanceForText(text) {
  return new textComponentClass(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!instance.getHostNode) {
      instance.getHostNode = instance.getNativeNode;
    }
  } else {
    instance = new ReactCompositeComponentWrapper(element);
  }
} else if (typeof node === &#x27;string&#x27; || typeof node === &#x27;number&#x27;) {
  instance = ReactHostComponent.<span class="apidocCodeKeywordSpan">createInstanceForText</span>(node);
} else {
  !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Encountered invalid React node of type %s&#x27
;, typeof node) : _prodInvariant(&#x27;131&#x27;, typeof node) : void 0;
}

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(typeof instance.mountComponent === &#x27;function&#x27; &#x26;&#x26;
typeof instance.receiveComponent === &#x27;function&#x27; &#x26;&#x26; typeof instance.getHostNode === &#x27;function&#x27; &#x26
;&#x26; typeof instance.unmountComponent === &#x27;function&#x27;, &#x27;Only React Components can be mounted.&#x27;) : void 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostComponent.createInternalComponent" id="apidoc.element.react-test-renderer.ReactHostComponent.createInternalComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>createInternalComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;There is no registered component for the tag
 %s&#x27;, element.type) : _prodInvariant(&#x27;111&#x27;, element.type) : void 0;
  return new genericComponentClass(element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
info += getDeclarationErrorAddendum(element._owner);
!false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Element type is invalid: expected a string (for
 built-in components) or a class/function (for composite components) but got: %s.%s&#x27;, type == null ? type : typeof type, info
) : _prodInvariant(&#x27;130&#x27;, type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === &#x27;string&#x27;) {
instance = ReactHostComponent.<span class="apidocCodeKeywordSpan">createInternalComponent</span>(element);
    } else if (isInternalComponentType(element.type)) {
// This is temporarily available for custom components that are not string
// representations. I.e. ART. Once those are updated to use the string
// representation, we can drop this code path.
instance = new element.type(element);

// We renamed this. Allow the old name for compat. :(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostComponent.isTextComponent" id="apidoc.element.react-test-renderer.ReactHostComponent.isTextComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostComponent.</span>isTextComponent
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isTextComponent(component) {
  return component instanceof textComponentClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactHostOperationHistoryHook" id="apidoc.module.react-test-renderer.ReactHostOperationHistoryHook">module react-test-renderer.ReactHostOperationHistoryHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.clearHistory" id="apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.clearHistory">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>clearHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearHistory = function () {
  if (ReactHostOperationHistoryHook._preventClearing) {
    // Should only be used for tests.
    return;
  }

  history = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
ReactComponentTreeHook.purgeUnmountedComponents();
ReactHostOperationHistoryHook.<span class="apidocCodeKeywordSpan">clearHistory</span>();
}

function getTreeSnapshot(registeredIDs) {
return registeredIDs.reduce(function (tree, id) {
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var parentID = ReactComponentTreeHook.getParentID(id);
  tree[id] = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.getHistory" id="apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.getHistory">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>getHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHistory = function () {
  return history;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return tree;
}, {});
}

function resetMeasurements() {
var previousStartTime = currentFlushStartTime;
var previousMeasurements = currentFlushMeasurements;
var previousOperations = ReactHostOperationHistoryHook.<span class="apidocCodeKeywordSpan">getHistory</span>();

if (currentFlushNesting === 0) {
  currentFlushStartTime = 0;
  currentFlushMeasurements = [];
  clearHistory();
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.onHostOperation" id="apidoc.element.react-test-renderer.ReactHostOperationHistoryHook.onHostOperation">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactHostOperationHistoryHook.</span>onHostOperation
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onHostOperation = function (operation) {
  history.push(operation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onHostOperation</span>({
    instanceID: component._debugID,
    type: &#x27;update styles&#x27;,
    payload: styles
  });
}

var style = node.style;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactInputSelection" id="apidoc.module.react-test-renderer.ReactInputSelection">module react-test-renderer.ReactInputSelection</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInputSelection.getSelection" id="apidoc.element.react-test-renderer.ReactInputSelection.getSelection">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>getSelection
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelection = function (input) {
  var selection;

  if (&#x27;selectionStart&#x27; in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else if (document.selection &#x26;&#x26; input.nodeName &#x26;&#x26; input.nodeName.toLowerCase() === &#x27;input&#x27;) {
    // IE8 input.
    var range = document.selection.createRange();
    // There can only be one selection per document in IE, so it must
    // be in our element.
    if (range.parentElement() === input) {
      selection = {
        start: -range.moveStart(&#x27;character&#x27;, -input.value.length),
        end: -range.moveEnd(&#x27;character&#x27;, -input.value.length)
      };
    }
  } else {
    // Content editable or old IE textarea.
    selection = ReactDOMSelection.getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
var selection = window.getSelection &#x26;&#x26; window.<span class="apidocCodeKeywordSpan">getSelection</span>();

if (!selection || selection.rangeCount === 0) {
  return null;
}

var anchorNode = selection.anchorNode;
var anchorOffset = selection.anchorOffset;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInputSelection.getSelectionInformation" id="apidoc.element.react-test-renderer.ReactInputSelection.getSelectionInformation">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>getSelectionInformation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSelectionInformation = function () {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) :
null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInputSelection.hasSelectionCapabilities" id="apidoc.element.react-test-renderer.ReactInputSelection.hasSelectionCapabilities">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>hasSelectionCapabilities
        <span class="apidocSignatureSpan">(elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasSelectionCapabilities = function (elem) {
  var nodeName = elem &#x26;&#x26; elem.nodeName &#x26;&#x26; elem.nodeName.toLowerCase();
  return nodeName &#x26;&#x26; (nodeName === &#x27;input&#x27; &#x26;&#x26; elem.type === &#x27;text&#x27; || nodeName === &#x27;textarea&#x27; || elem.contentEditable === &#x27;true&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return nodeName &#x26;&#x26; (nodeName === &#x27;input&#x27; &#x26;&#x26; elem.type === &#x27;text&#x27; || nodeName === &#x27
;textarea&#x27; || elem.contentEditable === &#x27;true&#x27;);
},

getSelectionInformation: function () {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: ReactInputSelection.<span class="apidocCodeKeywordSpan">hasSelectionCapabilities</span>(focusedElem) ? ReactInputSelection
.getSelection(focusedElem) : null
  };
},

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInputSelection.restoreSelection" id="apidoc.element.react-test-renderer.ReactInputSelection.restoreSelection">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>restoreSelection
        <span class="apidocSignatureSpan">(priorSelectionInformation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreSelection = function (priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem &#x26;&#x26; isInDocument(priorFocusedElem)) {
    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
      ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
    }
    focusNode(priorFocusedElem);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInputSelection.setSelection" id="apidoc.element.react-test-renderer.ReactInputSelection.setSelection">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInputSelection.</span>setSelection
        <span class="apidocSignatureSpan">(input, offsets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSelection = function (input, offsets) {
  var start = offsets.start;
  var end = offsets.end;
  if (end === undefined) {
    end = start;
  }

  if (&#x27;selectionStart&#x27; in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else if (document.selection &#x26;&#x26; input.nodeName &#x26;&#x26; input.nodeName.toLowerCase() === &#x27;input&#x27;) {
    var range = input.createTextRange();
    range.collapse(true);
    range.moveStart(&#x27;character&#x27;, start);
    range.moveEnd(&#x27;character&#x27;, end - start);
    range.select();
  } else {
    ReactDOMSelection.setOffsets(input, offsets);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
restoreSelection: function (priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem &#x26;&#x26; isInDocument(priorFocusedElem)) {
    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
      ReactInputSelection.<span class="apidocCodeKeywordSpan">setSelection</span>(priorFocusedElem, priorSelectionRange);
    }
    focusNode(priorFocusedElem);
  }
},

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactInstanceMap" id="apidoc.module.react-test-renderer.ReactInstanceMap">module react-test-renderer.ReactInstanceMap</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInstanceMap.get" id="apidoc.element.react-test-renderer.ReactInstanceMap.get">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  return key._reactInternalInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ImpureClass: 0,
PureClass: 1,
StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
var Component = ReactInstanceMap.<span class="apidocCodeKeywordSpan">get</span>(this)._currentElement.type;
var element = Component(this.props, this.context, this.updater);
warnIfInvalidElement(Component, element);
return element;
};

function warnIfInvalidElement(Component, element) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInstanceMap.has" id="apidoc.element.react-test-renderer.ReactInstanceMap.has">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (key) {
  return key._reactInternalInstance !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
 * @param {ReactElement} nextElement Component element to render.
 * @param {DOMElement} container DOM element to render into.
 * @param {?function} callback function triggered on completion
 * @return {ReactComponent} Component instance rendered in `container`.
 */
renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &#x26;&#x26; ReactInstanceMap.<span class="apidocCodeKeywordSpan">has</span>(parentComponent)) ? process
.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;parentComponent must be a valid React Component&#x27;) : _prodInvariant
(&#x27;38&#x27;) : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
},

_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, &#x27;ReactDOM.render&#x27;);
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactDOM.render():
Invalid component element.%s&#x27;, typeof nextElement === &#x27;string&#x27; ? &#x27; Instead of passing a string like\&#x27;div\&#x27;, pass &#x27; + &#x27;React.createElement(\&#x27;div\&#x27;) or &#x3c;div /&#x3e;.&#x27; : typeof nextElement === &#x27;function&#x27; ? &#x27; Instead of passing a class like Foo, pass &#x27; + &#x27;React.createElement(Foo) or &#x3c;Foo /&#x3e;.&#x27; :
  // Check if it quacks like an element
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInstanceMap.remove" id="apidoc.element.react-test-renderer.ReactInstanceMap.remove">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>remove
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (key) {
  key._reactInternalInstance = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._context = null;
  this._rootNodeID = 0;
  this._topLevelWrapper = null;

  // Delete the reference from the instance to this internal representation
  // which allow the internals to be properly cleaned up even if the user
  // leaks a reference to the public instance.
  ReactInstanceMap.<span class="apidocCodeKeywordSpan">remove</span>(inst);

  // Some existing components rely on inst.props even after they&#x27;ve been
  // destroyed (in event handlers).
  // TODO: inst.props = null;
  // TODO: inst.state = null;
  // TODO: inst.context = null;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInstanceMap.set" id="apidoc.element.react-test-renderer.ReactInstanceMap.set">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInstanceMap.</span>set
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value) {
  key._reactInternalInstance = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
inst.context = publicContext;
inst.refs = emptyObject;
inst.updater = updateQueue;

this._instance = inst;

// Store a reference from the instance back to the internal representation
ReactInstanceMap.<span class="apidocCodeKeywordSpan">set</span>(inst, this);

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  // Since plain JS classes are defined without any special initialization
  // logic, we can not catch common errors early. Therefore, we have to
  // catch them here, at initialization time, instead.
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved ||
inst.state, &#x27;getInitialState was defined on %s, a plain JavaScript class. &#x27; + &#x27;This is only supported for classes
 created using React.createClass. &#x27; + &#x27;Did you mean to define a state property instead?&#x27;, this.getName() || &#x27
;a component&#x27;) : void 0;
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, &#
x27;getDefaultProps was defined on %s, a plain JavaScript class. &#x27; + &#x27;This is only supported for classes created using
 React.createClass. &#x27; + &#x27;Use a static property to define defaultProps instead.&#x27;, this.getName() || &#x27;a component
&#x27;) : void 0;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactInvalidSetStateWarningHook" id="apidoc.module.react-test-renderer.ReactInvalidSetStateWarningHook">module react-test-renderer.ReactInvalidSetStateWarningHook</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext" id="apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onBeginProcessingChildContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onBeginProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBeginProcessingChildContext = function () {
  processingChildContext = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  _processChildContext: function (currentContext) {
var Component = this._currentElement.type;
var inst = this._instance;
var childContext;

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onBeginProcessingChildContext</span>();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.onEndProcessingChildContext();
    }
  } else {
    childContext = inst.getChildContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onEndProcessingChildContext" id="apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onEndProcessingChildContext">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onEndProcessingChildContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEndProcessingChildContext = function () {
  processingChildContext = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (inst.getChildContext) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onBeginProcessingChildContext();
    try {
      childContext = inst.getChildContext();
    } finally {
      ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onEndProcessingChildContext</span>();
    }
  } else {
    childContext = inst.getChildContext();
  }
}

if (childContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onSetState" id="apidoc.element.react-test-renderer.ReactInvalidSetStateWarningHook.onSetState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactInvalidSetStateWarningHook.</span>onSetState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onSetState = function () {
  warnInvalidSetState();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  ReactInstrumentation.debugTool.<span class="apidocCodeKeywordSpan">onSetState</span>();
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(partialState != null, &#x27;setState(...): You passed an undefined or
 null state object; &#x27; + &#x27;instead, use forceUpdate().&#x27;) : void 0;
}

var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;setState&#x27;);

if (!internalInstance) {
  return;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactMarkupChecksum" id="apidoc.module.react-test-renderer.ReactMarkupChecksum">module react-test-renderer.ReactMarkupChecksum</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMarkupChecksum.addChecksumToMarkup" id="apidoc.element.react-test-renderer.ReactMarkupChecksum.addChecksumToMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMarkupChecksum.</span>addChecksumToMarkup
        <span class="apidocSignatureSpan">(markup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addChecksumToMarkup = function (markup) {
  var checksum = adler32(markup);

  // Add checksum (handle both parent tags, comments and self-closing tags)
  if (COMMENT_START.test(markup)) {
    return markup;
  } else {
    return markup.replace(TAG_END, &#x27; &#x27; + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + &#x27;=&#x22;&#x27; + checksum + &#x27;&#x22;$&#x26;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var componentInstance = instantiateReactComponent(element, true);
    var markup = ReactReconciler.mountComponent(componentInstance, transaction, null, ReactDOMContainerInfo(), emptyObject, 0 /*
parentDebugID */
    );
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      ReactInstrumentation.debugTool.onUnmountComponent(componentInstance._debugID);
    }
    if (!makeStaticMarkup) {
      markup = ReactMarkupChecksum.<span class="apidocCodeKeywordSpan">addChecksumToMarkup</span>(markup);
    }
    return markup;
  }, null);
} finally {
  pendingTransactions--;
  ReactServerRenderingTransaction.release(transaction);
  // Revert to the DOM batching strategy since these two renderers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMarkupChecksum.canReuseMarkup" id="apidoc.element.react-test-renderer.ReactMarkupChecksum.canReuseMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMarkupChecksum.</span>canReuseMarkup
        <span class="apidocSignatureSpan">(markup, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canReuseMarkup = function (markup, element) {
  var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
  existingChecksum = existingChecksum &#x26;&#x26; parseInt(existingChecksum, 10);
  var markupChecksum = adler32(markup);
  return markupChecksum === existingChecksum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;mountComponentIntoNode
(...): Target container is not valid.&#x27;) : _prodInvariant(&#x27;41&#x27;) : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.<span class="apidocCodeKeywordSpan">canReuseMarkup</span>(markup, rootElement)) {
ReactDOMComponentTree.precacheNode(instance, rootElement);
return;
      } else {
var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

var rootMarkup = rootElement.outerHTML;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactMount" id="apidoc.module.react-test-renderer.ReactMount">module react-test-renderer.ReactMount</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount.TopLevelWrapper" id="apidoc.element.react-test-renderer.ReactMount.TopLevelWrapper">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>TopLevelWrapper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount._mountImageIntoNode" id="apidoc.element.react-test-renderer.ReactMount._mountImageIntoNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_mountImageIntoNode
        <span class="apidocSignatureSpan">(markup, container, instance, shouldReuseMarkup, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mountImageIntoNode = function (markup, container, instance, shouldReuseMarkup, transaction) {
  !isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;mountComponentIntoNode(...): Target container
 is not valid.&#x27;) : _prodInvariant(&#x27;41&#x27;) : void 0;

  if (shouldReuseMarkup) {
    var rootElement = getReactRootElementInContainer(container);
    if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
      ReactDOMComponentTree.precacheNode(instance, rootElement);
      return;
    } else {
      var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

      var rootMarkup = rootElement.outerHTML;
      rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

      var normalizedMarkup = markup;
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        // because rootMarkup is retrieved from the DOM, various normalizations
        // will have occurred which will not be present in `markup`. Here,
        // insert markup into a &#x3c;div&#x3e; or &#x3c;iframe&#x3e; depending on the container
        // type to perform the same normalizations before comparing.
        var normalizer;
        if (container.nodeType === ELEMENT_NODE_TYPE) {
          normalizer = document.createElement(&#x27;div&#x27;);
          normalizer.innerHTML = markup;
          normalizedMarkup = normalizer.innerHTML;
        } else {
          normalizer = document.createElement(&#x27;iframe&#x27;);
          document.body.appendChild(normalizer);
          normalizer.contentDocument.write(markup);
          normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
          document.body.removeChild(normalizer);
        }
      }

      var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
      var difference = &#x27; (client) &#x27; + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + &#x27;\n (server) &#x27; + rootMarkup.substring
(diffIndex - 20, diffIndex + 20);

      !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;You\&#x27;re trying to render
 a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component
 type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due
to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and
 ensure the props are the same client and server side:\n%s&#x27;, difference) : _prodInvariant(&#x27;42&#x27;, difference) : void 0;

      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;React attempted to reuse markup in a container but the &#x27; + &#x27;checksum
 was invalid. This generally means that you are &#x27; + &#x27;using server rendering and the markup generated on the &#x27; + &#x27;server was not
what the client was expecting. React injected &#x27; + &#x27;new markup to compensate which works but you have lost many &#x27; + &#x27;of the benefits
 of server rendering. Instead, figure out &#x27; + &#x27;why the markup being generated is different on the client &#x27; + &#x27;or server:\n%s&#x27;, difference) : void 0;
      }
    }
  }

  !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;You\&#x27;re trying to render a
 component to the document but you didn\&#x27;t use server rendering. We can\&#x27;t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.&#x27;) : _prodInvariant(&#x27;43&#x27;) : void 0;

  if (transaction.useCreateElement) {
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
    DOMLazyTree.insertTreeBefore(container, markup, null);
  } else {
    setInnerHTML(container, markup);
    ReactDOMComponentTree.precacheNode(instance, container.firstChild);
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
    if (hostNode._debugID !== 0) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 );

 if (markerName) {
   console.timeEnd(markerName);
 }

 wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
 ReactMount.<span class="apidocCodeKeywordSpan">_mountImageIntoNode</span>(markup, container, wrapperInstance, shouldReuseMarkup
, transaction);
}

/**
* Batched mount.
*
* @param {ReactComponent} componentInstance The instance to mount.
* @param {DOMElement} container DOM element to mount into.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount._renderNewRootComponent" id="apidoc.element.react-test-renderer.ReactMount._renderNewRootComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_renderNewRootComponent
        <span class="apidocSignatureSpan">(nextElement, container, shouldReuseMarkup, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderNewRootComponent = function (nextElement, container, shouldReuseMarkup, context) {
  // Various parts of our code (such as ReactCompositeComponent&#x27;s
  // _renderValidatedComponent) assume that calls to render aren&#x27;t nested;
  // verify that that&#x27;s the case.
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(ReactCurrentOwner.current == null, &#x27;_renderNewRootComponent(): Render methods
should be a pure function &#x27; + &#x27;of props and state; triggering nested component updates from &#x27; + &#x27;render is not allowed. If necessary
, trigger nested updates in &#x27; + &#x27;componentDidUpdate. Check the render method of %s.&#x27;, ReactCurrentOwner.current &#x26;&#x26; ReactCurrentOwner
.current.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;_registerComponent(...): Target container
 is not a DOM element.&#x27;) : _prodInvariant(&#x27;37&#x27;) : void 0;

  ReactBrowserEventEmitter.ensureScrollValueMonitoring();
  var componentInstance = instantiateReactComponent(nextElement, false);

  // The initial render is synchronous but any updates that happen during
  // rendering, in componentWillMount or componentDidMount, will be batched
  // according to the current batching strategy.

  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

  var wrapperID = componentInstance._instance.rootID;
  instancesByReactRootID[wrapperID] = componentInstance;

  return componentInstance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        rootElementSibling = rootElementSibling.nextSibling;
      }
    }
  }

  var shouldReuseMarkup = containerHasReactMarkup &#x26;&#x26; !prevComponent &#x26;&#x26; !containerHasNonRootReactChild;
  var component = ReactMount.<span class="apidocCodeKeywordSpan">_renderNewRootComponent</span>(nextWrappedElement, container, shouldReuseMarkup
, nextContext)._renderedComponent.getPublicInstance();
  if (callback) {
    callback.call(component);
  }
  return component;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount._renderSubtreeIntoContainer" id="apidoc.element.react-test-renderer.ReactMount._renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, &#x27;ReactDOM.render&#x27;);
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactDOM.render(): Invalid component
 element.%s&#x27;, typeof nextElement === &#x27;string&#x27; ? &#x27; Instead of passing a string like\&#x27;div\&#x27;, pass &#x27; + &#x27;React.createElement(\&#x27;div\&#x27;) or &#x3c;div /&#x3e;.&#x27; : typeof nextElement === &#x27;function&#x27; ? &#x27; Instead of passing a class like Foo, pass &#x27; + &#x27;React.createElement(Foo) or &#x3c;Foo /&#x3e;.&#x27; :
  // Check if it quacks like an element
  nextElement != null &#x26;&#x26; nextElement.props !== undefined ? &#x27; This may be caused by unintentionally loading two independent &#x27; + &#x27;
copies of React.&#x27; : &#x27;&#x27;) : _prodInvariant(&#x27;39&#x27;, typeof nextElement === &#x27;string&#x27; ? &#x27; Instead of passing a string like\&#x27;div\&#x27;, pass &#x27; + &#x27;React.createElement(\&#x27;div\&#x27;) or &#x3c;div /&#x3e;.&#x27; : typeof nextElement === &#x27;function&#x27; ? &#x27; Instead of passing a class like Foo, pass &#x27; + &#x27;React.createElement(Foo) or &#x3c;Foo /&#x3e;.&#x27; : nextElement != null &#x26;&#x26; nextElement.props !== undefined ? &#x27; This may be caused by unintentionally loading two independent &#x27; + &#x27;copies of React.&#x27; : &#x27;&#x27;) : void 0;

  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== &#x27;BODY&#x27;, &#x27;
render(): Rendering components directly into document.body is &#x27; + &#x27;discouraged, since its children are often manipulated by third
-party &#x27; + &#x27;scripts and browser extensions. This may lead to subtle &#x27; + &#x27;reconciliation issues. Try rendering into a container element
 created &#x27; + &#x27;for your app.&#x27;) : void 0;

  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

  var nextContext;
  if (parentComponent) {
    var parentInst = ReactInstanceMap.get(parentComponent);
    nextContext = parentInst._processChildContext(parentInst._context);
  } else {
    nextContext = emptyObject;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);

  if (prevComponent) {
    var prevWrappedElement = prevComponent._currentElement;
    var prevElement = prevWrappedElement.props.child;
    if (shouldUpdateReactComponent(prevElement, nextElement)) {
      var publicInst = prevComponent._renderedComponent.getPublicInstance();
      var updatedCallback = callback &#x26;&#x26; function () {
        callback.call(publicInst);
      };
      ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
      return publicInst;
    } else {
      ReactMount.unmountComponentAtNode(container);
    }
  }

  var reactRootElement = getReactRootElementInContainer(container);
  var containerHasReactMarkup = reactRootElement &#x26;&#x26; !!internalGetID(reactRootElement);
  var containerHasNonRootReactChild = hasNonRootReactChild(container);

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!containerHasNonRootReactChild, &#x27;render(...): Replacing React-rendered children
 with a new root &#x27; + &#x27;component. If you intended to update the children of this node, &#x27; + &#x27;you should instead have the existing
children update their state &#x27; + &#x27;and render the new components instead of calling ReactDOM.render.&#x27;) : void 0;

    if (!containerHasReactMarkup || reactRootElement.nextSibling) {
      var rootElementSibling = reactRootElement;
      while (rootElementSibling) {
        if (internalGetID(rootElementSibling)) {
          process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;render(): Target node has markup rendered by React, but there &#x27; + &#x27;
are unrelated nodes as well. This is most commonly caused by &#x27; + &#x27;white-space inserted around server-rendered markup.&#x27;) : void 0
;
          break;
        }
        rootElementSibling = rootElementSibling.nextSibling;
      }
    }
  }

  var shouldReuseMarkup = containerHasReactMarkup &#x26;&#x26; !prevComponent &#x26;&#x26; !containerHasNonRootReactChild;
  var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent
.getPublicInstance();
  if (callback) {
    callback.call(compon ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactElement} nextElement Component element to render.
 * @param {DOMElement} container DOM element to render into.
 * @param {?function} callback function triggered on completion
 * @return {ReactComponent} Component instance rendered in `container`.
 */
renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &#x26;&#x26; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== &#x27;production&#x27
; ? invariant(false, &#x27;parentComponent must be a valid React Component&#x27;) : _prodInvariant(&#x27;38&#x27;) : void 0;
  return ReactMount.<span class="apidocCodeKeywordSpan">_renderSubtreeIntoContainer</span>(parentComponent, nextElement, container
, callback);
},

_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
  ReactUpdateQueue.validateCallback(callback, &#x27;ReactDOM.render&#x27;);
  !React.isValidElement(nextElement) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactDOM.render():
Invalid component element.%s&#x27;, typeof nextElement === &#x27;string&#x27; ? &#x27; Instead of passing a string like\&#x27;div\&#x27;, pass &#x27; + &#x27;React.createElement(\&#x27;div\&#x27;) or &#x3c;div /&#x3e;.&#x27; : typeof nextElement === &#x27;function&#x27; ? &#x27; Instead of passing a class like Foo, pass &#x27; + &#x27;React.createElement(Foo) or &#x3c;Foo /&#x3e;.&#x27; :
  // Check if it quacks like an element
  nextElement != null &#x26;&#x26; nextElement.props !== undefined ? &#x27; This may be caused by unintentionally loading two independent
 &#x27; + &#x27;copies of React.&#x27; : &#x27;&#x27;) : _prodInvariant(&#x27;39&#x27;, typeof nextElement === &#x27;string&#x27
; ? &#x27; Instead of passing a string like\&#x27;div\&#x27;, pass &#x27; + &#x27;React.createElement(\&#x27;div\&#x27;) or &#x3c;div /&#x3e;.&#x27; : typeof nextElement === &#x27;function&#x27; ? &#x27; Instead of passing a class like Foo, pass &#x27; + &#x27;React.createElement(Foo) or &#x3c;Foo /&#x3e;.&#x27; : nextElement != null &#x26;&#x26; nextElement.props !== undefined ? &#x27; This may be caused by unintentionally loading two independent &#x27; + &#x27;copies of React.&#x27; : &#x27;&#x27;) : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount._updateRootComponent" id="apidoc.element.react-test-renderer.ReactMount._updateRootComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>_updateRootComponent
        <span class="apidocSignatureSpan">(prevComponent, nextElement, nextContext, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateRootComponent = function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
    }
  });

  return prevComponent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var prevWrappedElement = prevComponent._currentElement;
  var prevElement = prevWrappedElement.props.child;
  if (shouldUpdateReactComponent(prevElement, nextElement)) {
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &#x26;&#x26; function () {
      callback.call(publicInst);
    };
    ReactMount.<span class="apidocCodeKeywordSpan">_updateRootComponent</span>(prevComponent, nextWrappedElement, nextContext, container
, updatedCallback);
    return publicInst;
  } else {
    ReactMount.unmountComponentAtNode(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount.render" id="apidoc.element.react-test-renderer.ReactMount.render">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>render
        <span class="apidocSignatureSpan">(nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (nextElement, container, callback) {
  return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Shallow rendering lets you render a component &#x22;one level deep&#x22; and assert facts about what its render method returns,
without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.

```jsx
const ReactShallowRenderer = require(&#x27;react-test-renderer/shallow&#x27;);

const renderer = new ReactShallowRenderer();
renderer.<span class="apidocCodeKeywordSpan">render</span>(&#x3c;MyComponent /&#x3e;);

const result = renderer.getRenderOutput();
expect(result.type).toBe(&#x27;div&#x27;);
expect(result.props.children).toEqual([
  &#x3c;span className=&#x22;heading&#x22;&#x3e;Title&#x3c;/span&#x3e;,
  &#x3c;Subcomponent foo=&#x22;bar&#x22; /&#x3e;
]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount.renderSubtreeIntoContainer" id="apidoc.element.react-test-renderer.ReactMount.renderSubtreeIntoContainer">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>renderSubtreeIntoContainer
        <span class="apidocSignatureSpan">(parentComponent, nextElement, container, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderSubtreeIntoContainer = function (parentComponent, nextElement, container, callback) {
  !(parentComponent != null &#x26;&#x26; ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;
parentComponent must be a valid React Component&#x27;) : _prodInvariant(&#x27;38&#x27;) : void 0;
  return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount.scrollMonitor" id="apidoc.element.react-test-renderer.ReactMount.scrollMonitor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>scrollMonitor
        <span class="apidocSignatureSpan">(container, renderCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scrollMonitor = function (container, renderCallback) {
  renderCallback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Take a component that&#x27;s already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
ReactMount.<span class="apidocCodeKeywordSpan">scrollMonitor</span>(container, function () {
  ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
  }
});

return prevComponent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactMount.unmountComponentAtNode" id="apidoc.element.react-test-renderer.ReactMount.unmountComponentAtNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactMount.</span>unmountComponentAtNode
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponentAtNode = function (container) {
  // Various parts of our code (such as ReactCompositeComponent&#x27;s
  // _renderValidatedComponent) assume that calls to render aren&#x27;t nested;
  // verify that that&#x27;s the case. (Strictly speaking, unmounting won&#x27;t cause a
  // render but we still don&#x27;t expect to be in a render call here.)
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(ReactCurrentOwner.current == null, &#x27;unmountComponentAtNode(): Render methods should
 be a pure function &#x27; + &#x27;of props and state; triggering nested component updates from render &#x27; + &#x27;is not allowed. If necessary,
trigger nested updates in &#x27; + &#x27;componentDidUpdate. Check the render method of %s.&#x27;, ReactCurrentOwner.current &#x26;&#x26; ReactCurrentOwner
.current.getName() || &#x27;ReactCompositeComponent&#x27;) : void 0;

  !isValidContainer(container) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;unmountComponentAtNode(...): Target container
 is not a DOM element.&#x27;) : _prodInvariant(&#x27;40&#x27;) : void 0;

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!nodeIsRenderedByOtherInstance(container), &#x27;unmountComponentAtNode(): The node
 you\&#x27;re attempting to unmount &#x27; + &#x27;was rendered by another copy of React.&#x27;) : void 0;
  }

  var prevComponent = getTopLevelWrapperInContainer(container);
  if (!prevComponent) {
    // Check if the node being unmounted was rendered by React, but isn&#x27;t a
    // root node.
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    // Check if the container itself is a React root node.
    var isContainerReactRoot = container.nodeType === 1 &#x26;&#x26; container.hasAttribute(ROOT_ATTR_NAME);

    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(!containerHasNonRootReactChild, &#x27;unmountComponentAtNode(): The node you\&#x27;re
 attempting to unmount &#x27; + &#x27;was rendered by React and is not a top-level container. %s&#x27;, isContainerReactRoot ? &#x27;You may have accidentally
 passed in a React root node instead &#x27; + &#x27;of its container.&#x27; : &#x27;Instead, have the parent component update its state and &#x27; + &#x27;rerender
 in order to remove this component.&#x27;) : void 0;
    }

    return false;
  }
  delete instancesByReactRootID[prevComponent._instance.rootID];
  ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var publicInst = prevComponent._renderedComponent.getPublicInstance();
    var updatedCallback = callback &#x26;&#x26; function () {
      callback.call(publicInst);
    };
    ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
    return publicInst;
  } else {
    ReactMount.<span class="apidocCodeKeywordSpan">unmountComponentAtNode</span>(container);
  }
}

var reactRootElement = getReactRootElementInContainer(container);
var containerHasReactMarkup = reactRootElement &#x26;&#x26; !!internalGetID(reactRootElement);
var containerHasNonRootReactChild = hasNonRootReactChild(container);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactNodeTypes" id="apidoc.module.react-test-renderer.ReactNodeTypes">module react-test-renderer.ReactNodeTypes</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactNodeTypes.getType" id="apidoc.element.react-test-renderer.ReactNodeTypes.getType">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactNodeTypes.</span>getType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getType = function (node) {
  if (node === null || node === false) {
    return ReactNodeTypes.EMPTY;
  } else if (React.isValidElement(node)) {
    if (typeof node.type === &#x27;function&#x27;) {
      return ReactNodeTypes.COMPOSITE;
    } else {
      return ReactNodeTypes.HOST;
    }
  }
  !false ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Unexpected node: %s&#x27;, node) : _prodInvariant(&#x27;26&#x27;, node) :
void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If not a stateless component, we now render
if (renderedElement === undefined) {
  renderedElement = this._renderValidatedComponent();
}

var nodeType = ReactNodeTypes.<span class="apidocCodeKeywordSpan">getType</span>(renderedElement);
this._renderedNodeType = nodeType;
var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
);
this._renderedComponent = child;

var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context
), debugID);
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactOwner" id="apidoc.module.react-test-renderer.ReactOwner">module react-test-renderer.ReactOwner</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactOwner.addComponentAsRefTo" id="apidoc.element.react-test-renderer.ReactOwner.addComponentAsRefTo">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactOwner.</span>addComponentAsRefTo
        <span class="apidocSignatureSpan">(component, ref, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addComponentAsRefTo = function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;addComponentAsRefTo(...): Only a ReactOwner can
 have refs. You might be adding a ref to a component that was not created inside a component\&#x27;s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).&#x27;) : _prodInvariant(&#x27;119&#x27;) : void 0;
  owner.attachRef(ref, component);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReactRef = {};

function attachRef(ref, component, owner) {
if (typeof ref === &#x27;function&#x27;) {
  ref(component.getPublicInstance());
} else {
  // Legacy ref
  ReactOwner.<span class="apidocCodeKeywordSpan">addComponentAsRefTo</span>(component, ref, owner);
}
}

function detachRef(ref, component, owner) {
if (typeof ref === &#x27;function&#x27;) {
  ref(null);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactOwner.removeComponentAsRefFrom" id="apidoc.element.react-test-renderer.ReactOwner.removeComponentAsRefFrom">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactOwner.</span>removeComponentAsRefFrom
        <span class="apidocSignatureSpan">(component, ref, owner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeComponentAsRefFrom = function (component, ref, owner) {
  !isValidOwner(owner) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;removeComponentAsRefFrom(...): Only a ReactOwner
 can have refs. You might be removing a ref to a component that was not created inside a component\&#x27;s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).&#x27;) : _prodInvariant(&#x27;120&#x27;) : void 0;
  var ownerPublicInstance = owner.getPublicInstance();
  // Check that `component`&#x27;s owner is still alive and that `component` is still the current ref
  // because we do not want to detach the ref if another component stole it.
  if (ownerPublicInstance &#x26;&#x26; ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
    owner.detachRef(ref);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function detachRef(ref, component, owner) {
if (typeof ref === &#x27;function&#x27;) {
  ref(null);
} else {
  // Legacy ref
  ReactOwner.<span class="apidocCodeKeywordSpan">removeComponentAsRefFrom</span>(component, ref, owner);
}
}

ReactRef.attachRefs = function (instance, element) {
if (element === null || typeof element !== &#x27;object&#x27;) {
  return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactPerf" id="apidoc.module.react-test-renderer.ReactPerf">module react-test-renderer.ReactPerf</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getExclusive" id="apidoc.element.react-test-renderer.ReactPerf.getExclusive">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getExclusive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExclusive() {
  var flushHistory = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, timerType, applyUpdate) {
    var displayName = treeSnapshot[instanceID].displayName;

    var key = displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        counts: {},
        durations: {},
        totalDuration: 0
      };
    }
    if (!stats.durations[timerType]) {
      stats.durations[timerType] = 0;
    }
    if (!stats.counts[timerType]) {
      stats.counts[timerType] = 0;
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot;

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      updateAggregatedStats(treeSnapshot, instanceID, timerType, function (stats) {
        stats.totalDuration += duration;
        stats.durations[timerType] += duration;
        stats.counts[timerType]++;
      });
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.totalDuration - a.totalDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getInclusive" id="apidoc.element.react-test-renderer.ReactPerf.getInclusive">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getInclusive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getInclusive() {
  var flushHistory = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
    var _treeSnapshot$instanc = treeSnapshot[instanceID],
        displayName = _treeSnapshot$instanc.displayName,
        ownerID = _treeSnapshot$instanc.ownerID;

    var owner = treeSnapshot[ownerID];
    var key = (owner ? owner.displayName + &#x27; &#x3e; &#x27; : &#x27;&#x27;) + displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        inclusiveRenderDuration: 0,
        renderCount: 0
      };
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  var isCompositeByID = {};
  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements;

    measurements.forEach(function (measurement) {
      var instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== &#x27;render&#x27;) {
        return;
      }
      isCompositeByID[instanceID] = true;
    });
  });

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot;

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== &#x27;render&#x27;) {
        return;
      }
      updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
        stats.renderCount++;
      });
      var nextParentID = instanceID;
      while (nextParentID) {
        // As we traverse parents, only count inclusive time towards composites.
        // We know something is a composite if its render() was called.
        if (isCompositeByID[nextParentID]) {
          updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
            stats.inclusiveRenderDuration += duration;
          });
        }
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getLastMeasurements" id="apidoc.element.react-test-renderer.ReactPerf.getLastMeasurements">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getLastMeasurements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLastMeasurements() {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return [];
  }

  return ReactDebugTool.getFlushHistory();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getMeasurementsSummaryMap" id="apidoc.element.react-test-renderer.ReactPerf.getMeasurementsSummaryMap">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getMeasurementsSummaryMap
        <span class="apidocSignatureSpan">(measurements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMeasurementsSummaryMap(measurements) {
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutGetMeasurementsSummaryMap, &#x27;`ReactPerf.getMeasurementsSummaryMap(...)`
is deprecated. Use &#x27; + &#x27;`ReactPerf.getWasted(...)` instead.&#x27;) : void 0;
  warnedAboutGetMeasurementsSummaryMap = true;
  return getWasted(measurements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutPrintDOM, &#x27;`ReactPerf.printDOM(...)` is deprecated. Use
 &#x27; + &#x27;`ReactPerf.printOperations(...)` instead.&#x27;) : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutGetMeasurementsSummaryMap, &#x27;`ReactPerf.<span class="apidocCodeKeywordSpan
">getMeasurementsSummaryMap</span>(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf.getWasted(...)` instead.&#x27;) : void 0;
warnedAboutGetMeasurementsSummaryMap = true;
return getWasted(measurements);
}

function start() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getOperations" id="apidoc.element.react-test-renderer.ReactPerf.getOperations">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getOperations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOperations() {
  var flushHistory = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return [];
  }

  var stats = [];
  flushHistory.forEach(function (flush, flushIndex) {
    var operations = flush.operations,
        treeSnapshot = flush.treeSnapshot;

    operations.forEach(function (operation) {
      var instanceID = operation.instanceID,
          type = operation.type,
          payload = operation.payload;
      var _treeSnapshot$instanc3 = treeSnapshot[instanceID],
          displayName = _treeSnapshot$instanc3.displayName,
          ownerID = _treeSnapshot$instanc3.ownerID;

      var owner = treeSnapshot[ownerID];
      var key = (owner ? owner.displayName + &#x27; &#x3e; &#x27; : &#x27;&#x27;) + displayName;

      stats.push({
        flushIndex: flushIndex,
        instanceID: instanceID,
        key: key,
        type: type,
        ownerID: ownerID,
        payload: payload
      });
    });
  });
  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.getWasted" id="apidoc.element.react-test-renderer.ReactPerf.getWasted">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>getWasted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWasted() {
  var flushHistory = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : getLastMeasurements();

  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return [];
  }

  var aggregatedStats = {};
  var affectedIDs = {};

  function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
    var _treeSnapshot$instanc2 = treeSnapshot[instanceID],
        displayName = _treeSnapshot$instanc2.displayName,
        ownerID = _treeSnapshot$instanc2.ownerID;

    var owner = treeSnapshot[ownerID];
    var key = (owner ? owner.displayName + &#x27; &#x3e; &#x27; : &#x27;&#x27;) + displayName;
    var stats = aggregatedStats[key];
    if (!stats) {
      affectedIDs[key] = {};
      stats = aggregatedStats[key] = {
        key: key,
        instanceCount: 0,
        inclusiveRenderDuration: 0,
        renderCount: 0
      };
    }
    affectedIDs[key][instanceID] = true;
    applyUpdate(stats);
  }

  flushHistory.forEach(function (flush) {
    var measurements = flush.measurements,
        treeSnapshot = flush.treeSnapshot,
        operations = flush.operations;

    var isDefinitelyNotWastedByID = {};

    // Find host components associated with an operation in this batch.
    // Mark all components in their parent tree as definitely not wasted.
    operations.forEach(function (operation) {
      var instanceID = operation.instanceID;

      var nextParentID = instanceID;
      while (nextParentID) {
        isDefinitelyNotWastedByID[nextParentID] = true;
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });

    // Find composite components that rendered in this batch.
    // These are potential candidates for being wasted renders.
    var renderedCompositeIDs = {};
    measurements.forEach(function (measurement) {
      var instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== &#x27;render&#x27;) {
        return;
      }
      renderedCompositeIDs[instanceID] = true;
    });

    measurements.forEach(function (measurement) {
      var duration = measurement.duration,
          instanceID = measurement.instanceID,
          timerType = measurement.timerType;

      if (timerType !== &#x27;render&#x27;) {
        return;
      }

      // If there was a DOM update below this component, or it has just been
      // mounted, its render() is not considered wasted.
      var updateCount = treeSnapshot[instanceID].updateCount;

      if (isDefinitelyNotWastedByID[instanceID] || updateCount === 0) {
        return;
      }

      // We consider this render() wasted.
      updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
        stats.renderCount++;
      });

      var nextParentID = instanceID;
      while (nextParentID) {
        // Any parents rendered during this batch are considered wasted
        // unless we previously marked them as dirty.
        var isWasted = renderedCompositeIDs[nextParentID] &#x26;&#x26; !isDefinitelyNotWastedByID[nextParentID];
        if (isWasted) {
          updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
            stats.inclusiveRenderDuration += duration;
          });
        }
        nextParentID = treeSnapshot[nextParentID].parentID;
      }
    });
  });

  return Object.keys(aggregatedStats).map(function (key) {
    return _extends({}, aggregatedStats[key], {
      instanceCount: Object.keys(affectedIDs[key]).length
    });
  }).sort(function (a, b) {
    return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutPrintDOM, &#x27;`ReactPerf.printDOM(...)` is deprecated. Use
 &#x27; + &#x27;`ReactPerf.printOperations(...)` instead.&#x27;) : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutGetMeasurementsSummaryMap, &#x27;`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf.<span class="apidocCodeKeywordSpan">getWasted</span>(...)` instead.&#x27;) :
void 0;
warnedAboutGetMeasurementsSummaryMap = true;
return getWasted(measurements);
}

function start() {
if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
  warnInProduction();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.isRunning" id="apidoc.element.react-test-renderer.ReactPerf.isRunning">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>isRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRunning() {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return false;
  }

  return ReactDebugTool.isProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.printDOM" id="apidoc.element.react-test-renderer.ReactPerf.printDOM">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printDOM
        <span class="apidocSignatureSpan">(measurements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printDOM(measurements) {
  process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutPrintDOM, &#x27;`ReactPerf.printDOM(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf
.printOperations(...)` instead.&#x27;) : void 0;
  warnedAboutPrintDOM = true;
  return printOperations(measurements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
});
consoleTable(table);
}

var warnedAboutPrintDOM = false;
function printDOM(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutPrintDOM, &#x27;`ReactPerf.<span class="apidocCodeKeywordSpan
">printDOM</span>(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf.printOperations(...)` instead.&#x27;) : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutGetMeasurementsSummaryMap, &#x27;`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf.getWasted(...)` instead.&#x27;) : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.printExclusive" id="apidoc.element.react-test-renderer.ReactPerf.printExclusive">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printExclusive
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printExclusive(flushHistory) {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  var stats = getExclusive(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        totalDuration = item.totalDuration;

    var renderCount = item.counts.render || 0;
    var renderDuration = item.durations.render || 0;
    return {
      &#x27;Component&#x27;: key,
      &#x27;Total time (ms)&#x27;: roundFloat(totalDuration),
      &#x27;Instance count&#x27;: instanceCount,
      &#x27;Total render time (ms)&#x27;: roundFloat(renderDuration),
      &#x27;Average render time (ms)&#x27;: renderCount ? roundFloat(renderDuration / renderCount) : undefined,
      &#x27;Render count&#x27;: renderCount,
      &#x27;Total lifecycle time (ms)&#x27;: roundFloat(totalDuration - renderDuration)
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.printInclusive" id="apidoc.element.react-test-renderer.ReactPerf.printInclusive">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printInclusive
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printInclusive(flushHistory) {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  var stats = getInclusive(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        inclusiveRenderDuration = item.inclusiveRenderDuration,
        renderCount = item.renderCount;

    return {
      &#x27;Owner &#x3e; Component&#x27;: key,
      &#x27;Inclusive render time (ms)&#x27;: roundFloat(inclusiveRenderDuration),
      &#x27;Instance count&#x27;: instanceCount,
      &#x27;Render count&#x27;: renderCount
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.printOperations" id="apidoc.element.react-test-renderer.ReactPerf.printOperations">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printOperations
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printOperations(flushHistory) {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  var stats = getOperations(flushHistory);
  var table = stats.map(function (stat) {
    return {
      &#x27;Owner &#x3e; Node&#x27;: stat.key,
      &#x27;Operation&#x27;: stat.type,
      &#x27;Payload&#x27;: typeof stat.payload === &#x27;object&#x27; ? JSON.stringify(stat.payload) : stat.payload,
      &#x27;Flush index&#x27;: stat.flushIndex,
      &#x27;Owner Component ID&#x27;: stat.ownerID,
      &#x27;DOM Component ID&#x27;: stat.instanceID
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
});
consoleTable(table);
}

var warnedAboutPrintDOM = false;
function printDOM(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutPrintDOM, &#x27;`ReactPerf.printDOM(...)` is deprecated. Use
 &#x27; + &#x27;`ReactPerf.<span class="apidocCodeKeywordSpan">printOperations</span>(...)` instead.&#x27;) : void 0;
warnedAboutPrintDOM = true;
return printOperations(measurements);
}

var warnedAboutGetMeasurementsSummaryMap = false;
function getMeasurementsSummaryMap(measurements) {
process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warnedAboutGetMeasurementsSummaryMap, &#x27;`ReactPerf.getMeasurementsSummaryMap
(...)` is deprecated. Use &#x27; + &#x27;`ReactPerf.getWasted(...)` instead.&#x27;) : void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.printWasted" id="apidoc.element.react-test-renderer.ReactPerf.printWasted">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>printWasted
        <span class="apidocSignatureSpan">(flushHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printWasted(flushHistory) {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  var stats = getWasted(flushHistory);
  var table = stats.map(function (item) {
    var key = item.key,
        instanceCount = item.instanceCount,
        inclusiveRenderDuration = item.inclusiveRenderDuration,
        renderCount = item.renderCount;

    return {
      &#x27;Owner &#x3e; Component&#x27;: key,
      &#x27;Inclusive wasted time (ms)&#x27;: roundFloat(inclusiveRenderDuration),
      &#x27;Instance count&#x27;: instanceCount,
      &#x27;Render count&#x27;: renderCount
    };
  });
  consoleTable(table);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.start" id="apidoc.element.react-test-renderer.ReactPerf.start">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start() {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  ReactDebugTool.beginProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactPerf.stop" id="apidoc.element.react-test-renderer.ReactPerf.stop">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactPerf.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop() {
  if (!(process.env.NODE_ENV !== &#x27;production&#x27;)) {
    warnInProduction();
    return;
  }

  ReactDebugTool.endProfiling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactReconcileTransaction" id="apidoc.module.react-test-renderer.ReactReconcileTransaction">module react-test-renderer.ReactReconcileTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.ReactReconcileTransaction" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(useCreateElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it&#x27;s
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.getPooled" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.release" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.release">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactReconcileTransaction.prototype" id="apidoc.module.react-test-renderer.ReactReconcileTransaction.prototype">module react-test-renderer.ReactReconcileTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.checkpoint" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {
  // reactMountReady is the our only stateful wrapper
  return this.reactMountReady.checkpoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.closeAll" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.closeAll(): Cannot close transaction
 when none are open.&#x27;) : _prodInvariant(&#x27;28&#x27;) : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it&#x27;s still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &#x26;&#x26; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.destructor" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  CallbackQueue.release(this.reactMountReady);
  this.reactMountReady = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getReactMountReady" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return this.reactMountReady;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, &#x27;componentDidMount&#x27;);
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * &#x22;PooledClass&#x22;.
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getUpdateQueue" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return ReactUpdateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.initializeAll" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it&#x27;s still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it&#x27;s still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.isInTransaction" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object?=} d Argument to pass to the method.
 * @param {Object?=} e Argument to pass to the method.
 * @param {Object?=} f Argument to pass to the method.
 *
 * @return {*} Return value from `method`.
 */
perform: function (method, scope, a, b, c, d, e, f) {
  !!this.<span class="apidocCodeKeywordSpan">isInTransaction</span>() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant
(false, &#x27;Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.&#x27;) :
_prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.perform" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.&#x27;) : _prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.rollback" id="apidoc.element.react-test-renderer.ReactReconcileTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconcileTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">(checkpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (checkpoint) {
  this.reactMountReady.rollback(checkpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactReconciler" id="apidoc.module.react-test-renderer.ReactReconciler">module react-test-renderer.ReactReconciler</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconciler.getHostNode" id="apidoc.element.react-test-renderer.ReactReconciler.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>getHostNode
        <span class="apidocSignatureSpan">(internalInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function (internalInstance) {
  return internalInstance.getHostNode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconciler.mountComponent" id="apidoc.element.react-test-renderer.ReactReconciler.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>mountComponent
        <span class="apidocSignatureSpan">(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots ) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID
);
    }
  }
  var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
  if (internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
    }
  }
  return markup;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconciler.performUpdateIfNecessary" id="apidoc.element.react-test-renderer.ReactReconciler.performUpdateIfNecessary">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>performUpdateIfNecessary
        <span class="apidocSignatureSpan">(internalInstance, transaction, updateBatchNumber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">performUpdateIfNecessary = function (internalInstance, transaction, updateBatchNumber) {
  if (internalInstance._updateBatchNumber !== updateBatchNumber) {
    // The component&#x27;s enqueued batch number should always be the current
    // batch or the following one.
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber
 === updateBatchNumber + 1, &#x27;performUpdateIfNecessary: Unexpected batch number (current %s, &#x27; + &#x27;pending %s)&#x27;, updateBatchNumber
, internalInstance._updateBatchNumber) : void 0;
    return;
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.performUpdateIfNecessary(transaction);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
    }
  }
  internalInstance.<span class="apidocCodeKeywordSpan">performUpdateIfNecessary</span>(transaction);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconciler.receiveComponent" id="apidoc.element.react-test-renderer.ReactReconciler.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>receiveComponent
        <span class="apidocSignatureSpan">(internalInstance, nextElement, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function (internalInstance, nextElement, transaction, context) {
  var prevElement = internalInstance._currentElement;

  if (nextElement === prevElement &#x26;&#x26; context === internalInstance._context) {
    // Since elements are immutable after the owner is rendered,
    // we can do a cheap identity compare here to determine if this is a
    // superfluous reconcile. It&#x27;s possible for state to be mutable but such
    // change should trigger an update of the owner which would recreate
    // the element. We explicitly check for the existence of an owner since
    // it&#x27;s possible for an element created outside a composite to be
    // deeply mutated and reused.

    // TODO: Bailing out early is just a perf optimization right?
    // TODO: Removing the return statement should affect correctness?
    return;
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
    }
  }

  var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

  if (refsChanged) {
    ReactRef.detachRefs(internalInstance, prevElement);
  }

  internalInstance.receiveComponent(nextElement, transaction, context);

  if (refsChanged &#x26;&#x26; internalInstance._currentElement &#x26;&#x26; internalInstance._currentElement.ref != null) {
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
  }

  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReconciler.unmountComponent" id="apidoc.element.react-test-renderer.ReactReconciler.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReconciler.</span>unmountComponent
        <span class="apidocSignatureSpan">(internalInstance, safely)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function (internalInstance, safely) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
    }
  }
  ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactRef" id="apidoc.module.react-test-renderer.ReactRef">module react-test-renderer.ReactRef</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactRef.attachRefs" id="apidoc.element.react-test-renderer.ReactRef.attachRefs">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>attachRefs
        <span class="apidocSignatureSpan">(instance, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachRefs = function (instance, element) {
  if (element === null || typeof element !== &#x27;object&#x27;) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var warning = require(&#x27;fbjs/lib/warning&#x27;);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
ReactRef.<span class="apidocCodeKeywordSpan">attachRefs</span>(this, this._currentElement);
}

var ReactReconciler = {

/**
 * Initializes the component, renders markup, and registers event listeners.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactRef.detachRefs" id="apidoc.element.react-test-renderer.ReactRef.detachRefs">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>detachRefs
        <span class="apidocSignatureSpan">(instance, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detachRefs = function (instance, element) {
  if (element === null || typeof element !== &#x27;object&#x27;) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
unmountComponent: function (internalInstance, safely) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
    }
  }
  ReactRef.<span class="apidocCodeKeywordSpan">detachRefs</span>(internalInstance, internalInstance._currentElement);
  internalInstance.unmountComponent(safely);
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    if (internalInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
    }
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactRef.shouldUpdateRefs" id="apidoc.element.react-test-renderer.ReactRef.shouldUpdateRefs">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactRef.</span>shouldUpdateRefs
        <span class="apidocSignatureSpan">(prevElement, nextElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it&#x27;s forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null &#x26;&#x26; typeof prevElement === &#x27;object&#x27;) {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null &#x26;&#x26; typeof nextElement === &#x27;object&#x27;) {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don&#x27;t update refs
  typeof nextRef === &#x27;string&#x27; &#x26;&#x26; nextOwner !== prevOwner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (process.env.NODE_ENV !== &#x27;production&#x27;) {
  if (internalInstance._debugID !== 0) {
    ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
  }
}

var refsChanged = ReactRef.<span class="apidocCodeKeywordSpan">shouldUpdateRefs</span>(prevElement, nextElement);

if (refsChanged) {
  ReactRef.detachRefs(internalInstance, prevElement);
}

internalInstance.receiveComponent(nextElement, transaction, context);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactReifiedYield" id="apidoc.module.react-test-renderer.ReactReifiedYield">module react-test-renderer.ReactReifiedYield</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReifiedYield.createReifiedYield" id="apidoc.element.react-test-renderer.ReactReifiedYield.createReifiedYield">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReifiedYield.</span>createReifiedYield
        <span class="apidocSignatureSpan">(yieldNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReifiedYield = function (yieldNode) {
  var fiber = createFiberFromElementType(yieldNode.continuation, yieldNode.key);
  return {
    continuation: fiber,
    props: yieldNode.props
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactReifiedYield.createUpdatedReifiedYield" id="apidoc.element.react-test-renderer.ReactReifiedYield.createUpdatedReifiedYield">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactReifiedYield.</span>createUpdatedReifiedYield
        <span class="apidocSignatureSpan">(previousYield, yieldNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdatedReifiedYield = function (previousYield, yieldNode) {
  return {
    continuation: previousYield.continuation,
    props: yieldNode.props
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerBatchingStrategy" id="apidoc.module.react-test-renderer.ReactServerBatchingStrategy">module react-test-renderer.ReactServerBatchingStrategy</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerBatchingStrategy.batchedUpdates" id="apidoc.element.react-test-renderer.ReactServerBatchingStrategy.batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerBatchingStrategy.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batchedUpdates = function (callback) {
  // Don&#x27;t do anything here. During the server rendering we don&#x27;t want to
  // schedule any updates. We will simply ignore them.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactTestInstance.prototype.getInstance = function () {
  return this._component._renderedComponent.getPublicInstance();
};
ReactTestInstance.prototype.update = function (nextElement) {
  !this._component ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactTestRenderer: .update() can\&#
x27;t be called after unmount.&#x27;) : _prodInvariant(&#x27;139&#x27;) : void 0;
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
  var component = this._component;
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(function () {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    transaction.perform(function () {
      ReactReconciler.receiveComponent(component, nextWrappedElement, transaction, emptyObject);
    });
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  });
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerRendering" id="apidoc.module.react-test-renderer.ReactServerRendering">module react-test-renderer.ReactServerRendering</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRendering.renderToStaticMarkup" id="apidoc.element.react-test-renderer.ReactServerRendering.renderToStaticMarkup">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRendering.</span>renderToStaticMarkup
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToStaticMarkup(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;renderToStaticMarkup(): You must pass
 a valid ReactElement.&#x27;) : _prodInvariant(&#x27;47&#x27;) : void 0;
  return renderToStringImpl(element, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRendering.renderToString" id="apidoc.element.react-test-renderer.ReactServerRendering.renderToString">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRendering.</span>renderToString
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderToString(element) {
  !React.isValidElement(element) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;renderToString(): You must pass a valid
 ReactElement.&#x27;) : _prodInvariant(&#x27;46&#x27;) : void 0;
  return renderToStringImpl(element, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
!ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup
(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React
when unit testing or use ReactDOMServer.<span class="apidocCodeKeywordSpan">renderToString</span>() for server rendering.&#x27;) :
_prodInvariant(&#x27;56&#x27;) : void 0;
!markup ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup(...): Missing
 markup.&#x27;) : _prodInvariant(&#x27;57&#x27;) : void 0;
!(oldChild.nodeName !== &#x27;HTML&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;dangerouslyReplaceNodeWithMarkup
(...): Cannot replace markup of the &#x3c;html&#x3e; node. This is because browser quirks make this unreliable and/or slow. If you
 want to render to the root you must use server rendering. See ReactDOMServer.renderToString().&#x27;) : _prodInvariant(&#x27;58
&#x27;) : void 0;

if (typeof markup === &#x27;string&#x27;) {
  var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
  oldChild.parentNode.replaceChild(newChild, oldChild);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerRenderingTransaction" id="apidoc.module.react-test-renderer.ReactServerRenderingTransaction">module react-test-renderer.ReactServerRenderingTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.ReactServerRenderingTransaction" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.ReactServerRenderingTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerRenderingTransaction
        <span class="apidocSignatureSpan">(renderToStaticMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.getPooled" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.release" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.release">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerRenderingTransaction.prototype" id="apidoc.module.react-test-renderer.ReactServerRenderingTransaction.prototype">module react-test-renderer.ReactServerRenderingTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.checkpoint" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.closeAll" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.closeAll(): Cannot close transaction
 when none are open.&#x27;) : _prodInvariant(&#x27;28&#x27;) : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it&#x27;s still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &#x26;&#x26; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.destructor" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getReactMountReady" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return noopCallbackQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, &#x27;componentDidMount&#x27;);
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * &#x22;PooledClass&#x22;.
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getUpdateQueue" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return this.updateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.initializeAll" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it&#x27;s still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it&#x27;s still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.isInTransaction" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object?=} d Argument to pass to the method.
 * @param {Object?=} e Argument to pass to the method.
 * @param {Object?=} f Argument to pass to the method.
 *
 * @return {*} Return value from `method`.
 */
perform: function (method, scope, a, b, c, d, e, f) {
  !!this.<span class="apidocCodeKeywordSpan">isInTransaction</span>() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant
(false, &#x27;Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.&#x27;) :
_prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.perform" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.&#x27;) : _prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.rollback" id="apidoc.element.react-test-renderer.ReactServerRenderingTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerRenderingTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerUpdateQueue" id="apidoc.module.react-test-renderer.ReactServerUpdateQueue">module react-test-renderer.ReactServerUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.ReactServerUpdateQueue" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.ReactServerUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactServerUpdateQueue
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactServerUpdateQueue(transaction) {
  _classCallCheck(this, ReactServerUpdateQueue);

  this.transaction = transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactServerUpdateQueue.prototype" id="apidoc.module.react-test-renderer.ReactServerUpdateQueue.prototype">module react-test-renderer.ReactServerUpdateQueue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueCallback" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueCallback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueCallback
        <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallback</span>(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueForceUpdate" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueForceUpdate">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueForceUpdate
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueForceUpdate(publicInstance);
  } else {
    warnNoop(publicInstance, &#x27;forceUpdate&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance that should rerender.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueForceUpdate</span>(publicInstance);
  } else {
    warnNoop(publicInstance, &#x27;forceUpdate&#x27;);
  }
};

/**
 * Replaces all of the state. Always use this or `setState` to mutate state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueReplaceState" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueReplaceState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueReplaceState
        <span class="apidocSignatureSpan">(publicInstance, completeState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, &#x27;replaceState&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object|function} completeState Next state.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueReplaceState</span>(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, &#x27;replaceState&#x27;);
  }
};

/**
 * Sets a subset of the state. This only exists because _pendingState is
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueSetState" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.enqueueSetState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>enqueueSetState
        <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueSetState(publicInstance, partialState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
  } else {
    warnNoop(publicInstance, &#x27;setState&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueSetState</span>(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, &#x27;setState&#x27;);
    }
  };

  return ReactServerUpdateQueue;
}();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.isMounted" id="apidoc.element.react-test-renderer.ReactServerUpdateQueue.prototype.isMounted">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactServerUpdateQueue.prototype.</span>isMounted
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMounted(publicInstance) {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactSimpleEmptyComponent" id="apidoc.module.react-test-renderer.ReactSimpleEmptyComponent">module react-test-renderer.ReactSimpleEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.ReactSimpleEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactSimpleEmptyComponent
        <span class="apidocSignatureSpan">(placeholderElement, instantiate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReactSimpleEmptyComponent = function (placeholderElement, instantiate) {
  this._currentElement = null;
  this._renderedComponent = instantiate(placeholderElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactSimpleEmptyComponent.prototype" id="apidoc.module.react-test-renderer.ReactSimpleEmptyComponent.prototype">module react-test-renderer.ReactSimpleEmptyComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHostNode = function () {
  return ReactReconciler.getHostNode(this._renderedComponent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">(transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mountComponent = function (transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots ) {
  return ReactReconciler.mountComponent(this._renderedComponent, transaction, hostParent, hostContainerInfo, context, parentDebugID
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receiveComponent = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactSimpleEmptyComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactSimpleEmptyComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmountComponent = function () {
  ReactReconciler.unmountComponent(this._renderedComponent);
  this._renderedComponent = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestEmptyComponent" id="apidoc.module.react-test-renderer.ReactTestEmptyComponent">module react-test-renderer.ReactTestEmptyComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.ReactTestEmptyComponent" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.ReactTestEmptyComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestEmptyComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestEmptyComponent() {
  _classCallCheck(this, ReactTestEmptyComponent);

  this._currentElement = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestEmptyComponent.prototype" id="apidoc.module.react-test-renderer.ReactTestEmptyComponent.prototype">module react-test-renderer.ReactTestEmptyComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHostNode() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mountComponent() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function receiveComponent() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.toJSON" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.toJSON">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```jsx
const ReactTestRenderer = require(&#x27;react-test-renderer&#x27;);

const renderer = ReactTestRenderer.create(
  &#x3c;Link page=&#x22;https://www.facebook.com/&#x22;&#x3e;Facebook&#x3c;/Link&#x3e;
);

console.log(renderer.<span class="apidocCodeKeywordSpan">toJSON</span>());
// { type: &#x27;a&#x27;,
//   props: { href: &#x27;https://www.facebook.com/&#x27; },
//   children: [ &#x27;Facebook&#x27; ] }
```

You can also use Jest&#x27;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your
tests that it hasn&#x27;t changed: http://facebook.github.io/jest/blog/2016/07/27/jest-14.html.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactTestEmptyComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestEmptyComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmountComponent() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestMount" id="apidoc.module.react-test-renderer.ReactTestMount">module react-test-renderer.ReactTestMount</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestMount.render" id="apidoc.element.react-test-renderer.ReactTestMount.render">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestMount.</span>render
        <span class="apidocSignatureSpan">(nextElement, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (nextElement, options) {
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

  var instance = instantiateReactComponent(nextWrappedElement, false);

  // The initial render is synchronous but any updates that happen during
  // rendering, in componentWillMount or componentDidMount, will be batched
  // according to the current batching strategy.
  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, instance, _assign({}, defaultTestOptions, options));
  return new ReactTestInstance(instance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Shallow rendering lets you render a component &#x22;one level deep&#x22; and assert facts about what its render method returns,
without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.

```jsx
const ReactShallowRenderer = require(&#x27;react-test-renderer/shallow&#x27;);

const renderer = new ReactShallowRenderer();
renderer.<span class="apidocCodeKeywordSpan">render</span>(&#x3c;MyComponent /&#x3e;);

const result = renderer.getRenderOutput();
expect(result.type).toBe(&#x27;div&#x27;);
expect(result.props.children).toEqual([
  &#x3c;span className=&#x22;heading&#x22;&#x3e;Title&#x3c;/span&#x3e;,
  &#x3c;Subcomponent foo=&#x22;bar&#x22; /&#x3e;
]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestReconcileTransaction" id="apidoc.module.react-test-renderer.ReactTestReconcileTransaction">module react-test-renderer.ReactTestReconcileTransaction</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.ReactTestReconcileTransaction" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.ReactTestReconcileTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestReconcileTransaction
        <span class="apidocSignatureSpan">(testOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestReconcileTransaction(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue.getPooled(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.getPooled" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>getPooled
        <span class="apidocSignatureSpan">(copyFieldsFrom)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.release" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.release">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestReconcileTransaction.prototype" id="apidoc.module.react-test-renderer.ReactTestReconcileTransaction.prototype">module react-test-renderer.ReactTestReconcileTransaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.checkpoint" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.checkpoint">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>checkpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function () {
  // reactMountReady is the our only stateful wrapper
  return this.reactMountReady.checkpoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    return Component(publicProps, publicContext, updateQueue);
  }
},

performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
  var markup;
  var checkpoint = transaction.<span class="apidocCodeKeywordSpan">checkpoint</span>();
  try {
    markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
  } catch (e) {
    // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
    transaction.rollback(checkpoint);
    this._instance.unstable_handleError(e);
    if (this._pendingStateQueue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.closeAll" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.closeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.closeAll(): Cannot close transaction
 when none are open.&#x27;) : _prodInvariant(&#x27;28&#x27;) : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it&#x27;s still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &#x26;&#x26; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.destructor" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  CallbackQueue.release(this.reactMountReady);
  this.reactMountReady = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getReactMountReady" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getReactMountReady">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getReactMountReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReactMountReady = function () {
  return this.reactMountReady;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
} else {
  markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
}

if (inst.componentDidMount) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    transaction.<span class="apidocCodeKeywordSpan">getReactMountReady</span>().enqueue(function () {
      measureLifeCyclePerf(function () {
        return inst.componentDidMount();
      }, _this._debugID, &#x27;componentDidMount&#x27;);
    });
  } else {
    transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTestOptions" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTestOptions">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getTestOptions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTestOptions = function () {
  return this.testOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTransactionWrappers" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getTransactionWrappers">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getTransactionWrappers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransactionWrappers = function () {
  return TRANSACTION_WRAPPERS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sets up this instance so that it is prepared for collecting metrics. Does
 * so such that this setup method may be used on an instance that is already
 * initialized, in a way that does not consume additional memory upon reuse.
 * That can be useful if you decide to make your subclass of this mixin a
 * &#x22;PooledClass&#x22;.
 */
reinitializeTransaction: function () {
  this.transactionWrappers = this.<span class="apidocCodeKeywordSpan">getTransactionWrappers</span>();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getUpdateQueue" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.getUpdateQueue">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>getUpdateQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdateQueue = function () {
  return ReactUpdateQueue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._hostContainerInfo = hostContainerInfo;

var publicProps = this._currentElement.props;
var publicContext = this._processContext(context);

var Component = this._currentElement.type;

var updateQueue = transaction.<span class="apidocCodeKeywordSpan">getUpdateQueue</span>();

// Initialize the public class
var doConstruct = shouldConstruct(Component);
var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
var renderedElement;

// Support functional components
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.initializeAll" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.initializeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it&#x27;s still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it&#x27;s still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.isInTransaction" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.isInTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object?=} d Argument to pass to the method.
 * @param {Object?=} e Argument to pass to the method.
 * @param {Object?=} f Argument to pass to the method.
 *
 * @return {*} Return value from `method`.
 */
perform: function (method, scope, a, b, c, d, e, f) {
  !!this.<span class="apidocCodeKeywordSpan">isInTransaction</span>() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant
(false, &#x27;Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.&#x27;) :
_prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.perform" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.perform">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.&#x27;) : _prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.reinitializeTransaction" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.rollback" id="apidoc.element.react-test-renderer.ReactTestReconcileTransaction.prototype.rollback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestReconcileTransaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">(checkpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (checkpoint) {
  this.reactMountReady.rollback(checkpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
// Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
transaction.<span class="apidocCodeKeywordSpan">rollback</span>(checkpoint);
this._instance.unstable_handleError(e);
if (this._pendingStateQueue) {
  this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
}
checkpoint = transaction.checkpoint();

this._renderedComponent.unmountComponent(true);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestRenderer" id="apidoc.module.react-test-renderer.ReactTestRenderer">module react-test-renderer.ReactTestRenderer</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestRenderer.create" id="apidoc.element.react-test-renderer.ReactTestRenderer.create">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestRenderer.</span>create
        <span class="apidocSignatureSpan">(nextElement, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (nextElement, options) {
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

  var instance = instantiateReactComponent(nextWrappedElement, false);

  // The initial render is synchronous but any updates that happen during
  // rendering, in componentWillMount or componentDidMount, will be batched
  // according to the current batching strategy.
  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, instance, _assign({}, defaultTestOptions, options));
  return new ReactTestInstance(instance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Test renderer

Renders React components to pure JavaScript objects without depending on the DOM or a native mobile environment. This makes it easy
 to grab a snapshot of the &#x22;DOM tree&#x22; rendered by a React DOM or React Native component without using a browser or jsdom
.

```jsx
const ReactTestRenderer = require(&#x27;react-test-renderer&#x27;);

const renderer = ReactTestRenderer.<span class="apidocCodeKeywordSpan">create</span>(
  &#x3c;Link page=&#x22;https://www.facebook.com/&#x22;&#x3e;Facebook&#x3c;/Link&#x3e;
);

console.log(renderer.toJSON());
// { type: &#x27;a&#x27;,
//   props: { href: &#x27;https://www.facebook.com/&#x27; },
//   children: [ &#x27;Facebook&#x27; ] }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestRenderer.unstable_batchedUpdates" id="apidoc.element.react-test-renderer.ReactTestRenderer.unstable_batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestRenderer.</span>unstable_batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestTextComponent" id="apidoc.module.react-test-renderer.ReactTestTextComponent">module react-test-renderer.ReactTestTextComponent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.ReactTestTextComponent" id="apidoc.element.react-test-renderer.ReactTestTextComponent.ReactTestTextComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ReactTestTextComponent
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestTextComponent(element) {
  _classCallCheck(this, ReactTestTextComponent);

  this._currentElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactTestTextComponent.prototype" id="apidoc.module.react-test-renderer.ReactTestTextComponent.prototype">module react-test-renderer.ReactTestTextComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.getHostNode" id="apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.getHostNode">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>getHostNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHostNode() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.<span class="apidocCodeKeywordSpan">getHostNode</span>(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.mountComponent" id="apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.mountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>mountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mountComponent() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ReactReconciler.unmountComponent(prevChild, false);
    }
    // The child must be instantiated before it&#x27;s mounted.
    var nextChildInstance = instantiateReactComponent(nextElement, true);
    nextChildren[name] = nextChildInstance;
    // Creating mount image now ensures refs are resolved in right order
    // (see https://github.com/facebook/react/pull/7101 for explanation).
    var nextChildMountImage = ReactReconciler.<span class="apidocCodeKeywordSpan">mountComponent</span>(nextChildInstance, transaction
, hostParent, hostContainerInfo, context, selfDebugID);
    mountImages.push(nextChildMountImage);
  }
}
// Unmount children that are no longer present.
for (name in prevChildren) {
  if (prevChildren.hasOwnProperty(name) &#x26;&#x26; !(nextChildren &#x26;&#x26; nextChildren.hasOwnProperty(name))) {
    prevChild = prevChildren[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.receiveComponent" id="apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.receiveComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>receiveComponent
        <span class="apidocSignatureSpan">(nextElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function receiveComponent(nextElement) {
  this._currentElement = nextElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!nextChildren.hasOwnProperty(name)) {
  continue;
}
prevChild = prevChildren &#x26;&#x26; prevChildren[name];
var prevElement = prevChild &#x26;&#x26; prevChild._currentElement;
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.<span class="apidocCodeKeywordSpan">receiveComponent</span>(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.unmountComponent(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.toJSON" id="apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.toJSON">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  return this._currentElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```jsx
const ReactTestRenderer = require(&#x27;react-test-renderer&#x27;);

const renderer = ReactTestRenderer.create(
  &#x3c;Link page=&#x22;https://www.facebook.com/&#x22;&#x3e;Facebook&#x3c;/Link&#x3e;
);

console.log(renderer.<span class="apidocCodeKeywordSpan">toJSON</span>());
// { type: &#x27;a&#x27;,
//   props: { href: &#x27;https://www.facebook.com/&#x27; },
//   children: [ &#x27;Facebook&#x27; ] }
```

You can also use Jest&#x27;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your
tests that it hasn&#x27;t changed: http://facebook.github.io/jest/blog/2016/07/27/jest-14.html.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.unmountComponent" id="apidoc.element.react-test-renderer.ReactTestTextComponent.prototype.unmountComponent">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactTestTextComponent.prototype.</span>unmountComponent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmountComponent() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nextElement = nextChildren[name];
if (prevChild != null &#x26;&#x26; shouldUpdateReactComponent(prevElement, nextElement)) {
  ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
  nextChildren[name] = prevChild;
} else {
  if (prevChild) {
    removedNodes[name] = ReactReconciler.getHostNode(prevChild);
    ReactReconciler.<span class="apidocCodeKeywordSpan">unmountComponent</span>(prevChild, false);
  }
  // The child must be instantiated before it&#x27;s mounted.
  var nextChildInstance = instantiateReactComponent(nextElement, true);
  nextChildren[name] = nextChildInstance;
  // Creating mount image now ensures refs are resolved in right order
  // (see https://github.com/facebook/react/pull/7101 for explanation).
  var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context
, selfDebugID);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactUpdateQueue" id="apidoc.module.react-test-renderer.ReactUpdateQueue">module react-test-renderer.ReactUpdateQueue</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallback" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueCallback
        <span class="apidocSignatureSpan">(publicInstance, callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueCallback = function (publicInstance, callback, callerName) {
  ReactUpdateQueue.validateCallback(callback, callerName);
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

  // Previously we would throw an error if we didn&#x27;t have an internal
  // instance. Since we want to make it a no-op instead, we mirror the same
  // behavior we have in other enqueue* methods.
  // We also need to ignore callbacks in componentWillMount. See
  // enqueueUpdates.
  if (!internalInstance) {
    return null;
  }

  if (internalInstance._pendingCallbacks) {
    internalInstance._pendingCallbacks.push(callback);
  } else {
    internalInstance._pendingCallbacks = [callback];
  }
  // TODO: The callback here is ignored when setState is called from
  // componentWillMount. Either fix it or disallow doing so completely in
  // favor of getInitialState. Alternatively, we can disallow
  // componentWillMount during server-side rendering.
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {?function} callback Called after state is updated.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallback</span>(publicInstance, callback, callerName);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallbackInternal" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueCallbackInternal">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueCallbackInternal
        <span class="apidocSignatureSpan">(internalInstance, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueCallbackInternal = function (internalInstance, callback) {
  if (internalInstance._pendingCallbacks) {
    internalInstance._pendingCallbacks.push(callback);
  } else {
    internalInstance._pendingCallbacks = [callback];
  }
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DOMElement} container container to render into
 * @param {?function} callback function triggered on completion
 */
_updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueCallbackInternal</span>(prevComponent, callback);
    }
  });

  return prevComponent;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueElementInternal" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueElementInternal">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueElementInternal
        <span class="apidocSignatureSpan">(internalInstance, nextElement, nextContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueElementInternal = function (internalInstance, nextElement, nextContext) {
  internalInstance._pendingElement = nextElement;
  // TODO: introduce _pendingContext instead of setting it directly.
  internalInstance._context = nextContext;
  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactComponent} prevComponent component instance already in the DOM
 * @param {ReactElement} nextElement component instance to render
 * @param {DOMElement} container container to render into
 * @param {?function} callback function triggered on completion
 */
_updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
  ReactMount.scrollMonitor(container, function () {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueElementInternal</span>(prevComponent, nextElement, nextContext);
    if (callback) {
      ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
    }
  });

  return prevComponent;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueForceUpdate" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueForceUpdate">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueForceUpdate
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueForceUpdate = function (publicInstance) {
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;forceUpdate&#x27;);

  if (!internalInstance) {
    return;
  }

  internalInstance._pendingForceUpdate = true;

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {ReactClass} publicInstance The instance that should rerender.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueForceUpdate</span>(publicInstance);
  } else {
    warnNoop(publicInstance, &#x27;forceUpdate&#x27;);
  }
};

/**
 * Replaces all of the state. Always use this or `setState` to mutate state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueReplaceState" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueReplaceState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueReplaceState
        <span class="apidocSignatureSpan">(publicInstance, completeState, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueReplaceState = function (publicInstance, completeState, callback) {
  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;replaceState&#x27;);

  if (!internalInstance) {
    return;
  }

  internalInstance._pendingStateQueue = [completeState];
  internalInstance._pendingReplaceState = true;

  // Future-proof 15.5
  if (callback !== undefined &#x26;&#x26; callback !== null) {
    ReactUpdateQueue.validateCallback(callback, &#x27;replaceState&#x27;);
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
  }

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object|function} completeState Next state.
 * @internal
 */


ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
  if (this.transaction.isInTransaction()) {
    ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueReplaceState</span>(publicInstance, completeState);
  } else {
    warnNoop(publicInstance, &#x27;replaceState&#x27;);
  }
};

/**
 * Sets a subset of the state. This only exists because _pendingState is
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueSetState" id="apidoc.element.react-test-renderer.ReactUpdateQueue.enqueueSetState">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>enqueueSetState
        <span class="apidocSignatureSpan">(publicInstance, partialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueueSetState = function (publicInstance, partialState) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    ReactInstrumentation.debugTool.onSetState();
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(partialState != null, &#x27;setState(...): You passed an undefined or null state
object; &#x27; + &#x27;instead, use forceUpdate().&#x27;) : void 0;
  }

  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;setState&#x27;);

  if (!internalInstance) {
    return;
  }

  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
  queue.push(partialState);

  enqueueUpdate(internalInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.<span class="apidocCodeKeywordSpan">enqueueSetState</span>(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, &#x27;setState&#x27;);
    }
  };

  return ReactServerUpdateQueue;
}();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.isMounted" id="apidoc.element.react-test-renderer.ReactUpdateQueue.isMounted">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>isMounted
        <span class="apidocSignatureSpan">(publicInstance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMounted = function (publicInstance) {
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(owner._warnedAboutRefsInRender, &#x27;%s is accessing isMounted inside its render
() function. &#x27; + &#x27;render() should be a pure function of props and state. It should &#x27; + &#x27;never access something that requires stale
 data from the previous &#x27; + &#x27;render, such as refs. Move this logic to componentDidMount and &#x27; + &#x27;componentDidUpdate instead.&#x27;, owner
.getName() || &#x27;A component&#x27;) : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (internalInstance) {
    // During componentWillMount and render this will still be null but after
    // that will always render to something. At least for now. So we can use
    // this hack.
    return !!internalInstance._renderedComponent;
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdateQueue.validateCallback" id="apidoc.element.react-test-renderer.ReactUpdateQueue.validateCallback">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdateQueue.</span>validateCallback
        <span class="apidocSignatureSpan">(callback, callerName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateCallback = function (callback, callerName) {
  !(!callback || typeof callback === &#x27;function&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;%s(...): Expected the
 last optional `callback` argument to be a function. Instead received: %s.&#x27;, callerName, formatUnexpectedArgument(callback)) : _prodInvariant
(&#x27;122&#x27;, callerName, formatUnexpectedArgument(callback)) : void 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
ReactUpdateQueue.<span class="apidocCodeKeywordSpan">validateCallback</span>(callback, callerName);
var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

// Previously we would throw an error if we didn&#x27;t have an internal
// instance. Since we want to make it a no-op instead, we mirror the same
// behavior we have in other enqueue* methods.
// We also need to ignore callbacks in componentWillMount. See
// enqueueUpdates.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ReactUpdates" id="apidoc.module.react-test-renderer.ReactUpdates">module react-test-renderer.ReactUpdates</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdates.ReactReconcileTransaction" id="apidoc.element.react-test-renderer.ReactUpdates.ReactReconcileTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>ReactReconcileTransaction
        <span class="apidocSignatureSpan">(testOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactTestReconcileTransaction(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue.getPooled(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdates.asap" id="apidoc.element.react-test-renderer.ReactUpdates.asap">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>asap
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactUpdates.asap: Can\&#x27;t enqueue
 an asap callback in a context whereupdates are not being batched.&#x27;) : _prodInvariant(&#x27;125&#x27;) : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.<span class="apidocCodeKeywordSpan">asap</span>(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === &#x27;radio&#x27; &#x26;&#x26; name != null) {
var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
var queryRoot = rootNode;

while (queryRoot.parentNode) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdates.batchedUpdates" id="apidoc.element.react-test-renderer.ReactUpdates.batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>batchedUpdates
        <span class="apidocSignatureSpan">(callback, a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ReactTestInstance.prototype.getInstance = function () {
  return this._component._renderedComponent.getPublicInstance();
};
ReactTestInstance.prototype.update = function (nextElement) {
  !this._component ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactTestRenderer: .update() can\&#
x27;t be called after unmount.&#x27;) : _prodInvariant(&#x27;139&#x27;) : void 0;
  var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
  var component = this._component;
  ReactUpdates.<span class="apidocCodeKeywordSpan">batchedUpdates</span>(function () {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    transaction.perform(function () {
      ReactReconciler.receiveComponent(component, nextWrappedElement, transaction, emptyObject);
    });
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdates.enqueueUpdate" id="apidoc.element.react-test-renderer.ReactUpdates.enqueueUpdate">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>enqueueUpdate
        <span class="apidocSignatureSpan">(component)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent&#x27;s
  // _renderValidatedComponent) assume that calls to render aren&#x27;t nested;
  // verify that that&#x27;s the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ReactInstrumentation = require(&#x27;./ReactInstrumentation&#x27;);
var ReactUpdates = require(&#x27;./ReactUpdates&#x27;);

var invariant = require(&#x27;fbjs/lib/invariant&#x27;);
var warning = require(&#x27;fbjs/lib/warning&#x27;);

function enqueueUpdate(internalInstance) {
ReactUpdates.<span class="apidocCodeKeywordSpan">enqueueUpdate</span>(internalInstance);
}

function formatUnexpectedArgument(arg) {
var type = typeof arg;
if (type !== &#x27;object&#x27;) {
  return type;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ReactUpdates.flushBatchedUpdates" id="apidoc.element.react-test-renderer.ReactUpdates.flushBatchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.ReactUpdates.</span>flushBatchedUpdates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction&#x27;s wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ResponderEventPlugin" id="apidoc.module.react-test-renderer.ResponderEventPlugin">module react-test-renderer.ResponderEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderEventPlugin._getResponderID" id="apidoc.element.react-test-renderer.ResponderEventPlugin._getResponderID">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>_getResponderID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getResponderID = function () {
  return responderInst ? responderInst._rootNodeID : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.ResponderEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (isStartish(topLevelType)) {
    trackedTouchCount += 1;
  } else if (isEndish(topLevelType)) {
    if (trackedTouchCount &#x3e;= 0) {
      trackedTouchCount -= 1;
    } else {
      console.error(&#x27;Ended a touch event which was not counted in `trackedTouchCount`.&#x27;);
      return null;
    }
  }

  ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

  var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst
, nativeEvent, nativeEventTarget) : null;
  // Responder may or may not have transferred on a new touch start/move.
  // Regardless, whoever is the responder after any potential transfer, we
  // direct all touch start/move/ends to them in the form of
  // `onResponderMove/Start/End`. These will be called for *every* additional
  // finger that move/start/end, dispatched directly to whoever is the
  // current responder at that moment, until the responder is &#x22;released&#x22;.
  //
  // These multiple individual change touch events are are always bookended
  // by `onResponderGrant`, and one of
  // (`onResponderRelease/onResponderTerminate`).
  var isResponderTouchStart = responderInst &#x26;&#x26; isStartish(topLevelType);
  var isResponderTouchMove = responderInst &#x26;&#x26; isMoveish(topLevelType);
  var isResponderTouchEnd = responderInst &#x26;&#x26; isEndish(topLevelType);
  var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd
 ? eventTypes.responderEnd : null;

  if (incrementalTouch) {
    var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
    gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
    EventPropagators.accumulateDirectDispatches(gesture);
    extracted = accumulate(extracted, gesture);
  }

  var isResponderTerminate = responderInst &#x26;&#x26; topLevelType === &#x27;topTouchCancel&#x27;;
  var isResponderRelease = responderInst &#x26;&#x26; !isResponderTerminate &#x26;&#x26; isEndish(topLevelType) &#x26;&#x26; noResponderTouches(nativeEvent);
  var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null
;
  if (finalTouch) {
    var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
    finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
    EventPropagators.accumulateDirectDispatches(finalEvent);
    extracted = accumulate(extracted, finalEvent);
    changeResponder(null);
  }

  var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;
  if (ResponderEventPlugin.GlobalInteractionHandler &#x26;&#x26; numberActiveTouches !== previousActiveTouches) {
    ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);
  }
  previousActiveTouches = numberActiveTouches;

  return extracted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ResponderSyntheticEvent" id="apidoc.module.react-test-renderer.ResponderSyntheticEvent">module react-test-renderer.ResponderSyntheticEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.ResponderSyntheticEvent" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent.ResponderSyntheticEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>ResponderSyntheticEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.augmentClass" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.getPooled" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.release" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ResponderSyntheticEvent.prototype" id="apidoc.module.react-test-renderer.ResponderSyntheticEvent.prototype">module react-test-renderer.ResponderSyntheticEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderSyntheticEvent.prototype.constructor" id="apidoc.element.react-test-renderer.ResponderSyntheticEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderSyntheticEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ResponderTouchHistoryStore" id="apidoc.module.react-test-renderer.ResponderTouchHistoryStore">module react-test-renderer.ResponderTouchHistoryStore</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ResponderTouchHistoryStore.recordTouchTrack" id="apidoc.element.react-test-renderer.ResponderTouchHistoryStore.recordTouchTrack">
        function <span class="apidocSignatureSpan">react-test-renderer.ResponderTouchHistoryStore.</span>recordTouchTrack
        <span class="apidocSignatureSpan">(topLevelType, nativeEvent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recordTouchTrack = function (topLevelType, nativeEvent) {
  if (isMoveish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchMove);
  } else if (isStartish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchStart);
    touchHistory.numberActiveTouches = nativeEvent.touches.length;
    if (touchHistory.numberActiveTouches === 1) {
      touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
    }
  } else if (isEndish(topLevelType)) {
    nativeEvent.changedTouches.forEach(recordTouchEnd);
    touchHistory.numberActiveTouches = nativeEvent.touches.length;
    if (touchHistory.numberActiveTouches === 1) {
      for (var i = 0; i &#x3c; touchBank.length; i++) {
        var touchTrackToCheck = touchBank[i];
        if (touchTrackToCheck != null &#x26;&#x26; touchTrackToCheck.touchActive) {
          touchHistory.indexOfSingleActiveTouch = i;
          break;
        }
      }
      if (process.env.NODE_ENV !== &#x27;production&#x27;) {
        var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
        process.env.NODE_ENV !== &#x27;production&#x27; ? warning(activeRecord != null &#x26;&#x26; activeRecord.touchActive, &#x27;Cannot find single active
 touch.&#x27;) : void 0;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    trackedTouchCount -= 1;
  } else {
    console.error(&#x27;Ended a touch event which was not counted in `trackedTouchCount`.&#x27;);
    return null;
  }
}

ResponderTouchHistoryStore.<span class="apidocCodeKeywordSpan">recordTouchTrack</span>(topLevelType, nativeEvent);

var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst
, nativeEvent, nativeEventTarget) : null;
// Responder may or may not have transferred on a new touch start/move.
// Regardless, whoever is the responder after any potential transfer, we
// direct all touch start/move/ends to them in the form of
// `onResponderMove/Start/End`. These will be called for *every* additional
// finger that move/start/end, dispatched directly to whoever is the
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SelectEventPlugin" id="apidoc.module.react-test-renderer.SelectEventPlugin">module react-test-renderer.SelectEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SelectEventPlugin.didPutListener" id="apidoc.element.react-test-renderer.SelectEventPlugin.didPutListener">
        function <span class="apidocSignatureSpan">react-test-renderer.SelectEventPlugin.</span>didPutListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">didPutListener = function (inst, registrationName, listener) {
  if (registrationName === &#x27;onSelect&#x27;) {
    hasListener = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &#x26;&#x26; PluginModule.didPutListener) {
    PluginModule.<span class="apidocCodeKeywordSpan">didPutListener</span>(inst, registrationName, listener);
  }
},

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SelectEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.SelectEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.SelectEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (!hasListener) {
    return null;
  }

  var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

  switch (topLevelType) {
    // Track the input node that has focus.
    case &#x27;topFocus&#x27;:
      if (isTextInputElement(targetNode) || targetNode.contentEditable === &#x27;true&#x27;) {
        activeElement = targetNode;
        activeElementInst = targetInst;
        lastSelection = null;
      }
      break;
    case &#x27;topBlur&#x27;:
      activeElement = null;
      activeElementInst = null;
      lastSelection = null;
      break;

    // Don&#x27;t fire the event while the user is dragging. This matches the
    // semantics of the native select event.
    case &#x27;topMouseDown&#x27;:
      mouseDown = true;
      break;
    case &#x27;topContextMenu&#x27;:
    case &#x27;topMouseUp&#x27;:
      mouseDown = false;
      return constructSelectEvent(nativeEvent, nativeEventTarget);

    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn&#x27;t). IE&#x27;s event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn&#x27;t support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.
    case &#x27;topSelectionChange&#x27;:
      if (skipSelectionChangeEvent) {
        break;
      }
    // falls through
    case &#x27;topKeyDown&#x27;:
    case &#x27;topKeyUp&#x27;:
      return constructSelectEvent(nativeEvent, nativeEventTarget);
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SimpleEventPlugin" id="apidoc.module.react-test-renderer.SimpleEventPlugin">module react-test-renderer.SimpleEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SimpleEventPlugin.didPutListener" id="apidoc.element.react-test-renderer.SimpleEventPlugin.didPutListener">
        function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>didPutListener
        <span class="apidocSignatureSpan">(inst, registrationName, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">didPutListener = function (inst, registrationName, listener) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  if (registrationName === &#x27;onClick&#x27; &#x26;&#x26; !isInteractive(inst._tag)) {
    var key = getDictionaryKey(inst);
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    if (!onClickListeners[key]) {
      onClickListeners[key] = EventListener.listen(node, &#x27;click&#x27;, emptyFunction);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var key = getDictionaryKey(inst);
  var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[key] = listener;

  var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
  if (PluginModule &#x26;&#x26; PluginModule.didPutListener) {
    PluginModule.<span class="apidocCodeKeywordSpan">didPutListener</span>(inst, registrationName, listener);
  }
},

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SimpleEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.SimpleEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
  if (!dispatchConfig) {
    return null;
  }
  var EventConstructor;
  switch (topLevelType) {
    case &#x27;topAbort&#x27;:
    case &#x27;topCanPlay&#x27;:
    case &#x27;topCanPlayThrough&#x27;:
    case &#x27;topDurationChange&#x27;:
    case &#x27;topEmptied&#x27;:
    case &#x27;topEncrypted&#x27;:
    case &#x27;topEnded&#x27;:
    case &#x27;topError&#x27;:
    case &#x27;topInput&#x27;:
    case &#x27;topInvalid&#x27;:
    case &#x27;topLoad&#x27;:
    case &#x27;topLoadedData&#x27;:
    case &#x27;topLoadedMetadata&#x27;:
    case &#x27;topLoadStart&#x27;:
    case &#x27;topPause&#x27;:
    case &#x27;topPlay&#x27;:
    case &#x27;topPlaying&#x27;:
    case &#x27;topProgress&#x27;:
    case &#x27;topRateChange&#x27;:
    case &#x27;topReset&#x27;:
    case &#x27;topSeeked&#x27;:
    case &#x27;topSeeking&#x27;:
    case &#x27;topStalled&#x27;:
    case &#x27;topSubmit&#x27;:
    case &#x27;topSuspend&#x27;:
    case &#x27;topTimeUpdate&#x27;:
    case &#x27;topVolumeChange&#x27;:
    case &#x27;topWaiting&#x27;:
      // HTML Events
      // @see http://www.w3.org/TR/html5/index.html#events-0
      EventConstructor = SyntheticEvent;
      break;
    case &#x27;topKeyPress&#x27;:
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn&#x27;t).
      if (getEventCharCode(nativeEvent) === 0) {
        return null;
      }
<span class="apidocCodeCommentSpan">    /* falls through */
</span>    case &#x27;topKeyDown&#x27;:
    case &#x27;topKeyUp&#x27;:
      EventConstructor = SyntheticKeyboardEvent;
      break;
    case &#x27;topBlur&#x27;:
    case &#x27;topFocus&#x27;:
      EventConstructor = SyntheticFocusEvent;
      break;
    case &#x27;topClick&#x27;:
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return null;
      }
    /* falls through */
    case &#x27;topDoubleClick&#x27;:
    case &#x27;topMouseDown&#x27;:
    case &#x27;topMouseMove&#x27;:
    case &#x27;topMouseUp&#x27;:
    // TODO: Disabled elements should not respond to mouse events
    /* falls through */
    case &#x27;topMouseOut&#x27;:
    case &#x27;topMouseOver&#x27;:
    case &#x27;topContextMenu&#x27;:
      EventConstructor = SyntheticMouseEvent;
      break;
    case &#x27;topDrag&#x27;:
    case &#x27;topDragEnd&#x27;:
    case &#x27;topDragEnter&#x27;:
    case &#x27;topDragExit&#x27;:
    case &#x27;topDragLeave&#x27;:
    case &#x27;topDragOver&#x27;:
    case &#x27;topDragStart&#x27;:
    case &#x27;topDrop&#x27;:
      EventConstructor = SyntheticDragEvent;
      break;
    case &#x27;topTouchCancel&#x27;:
    case &#x27;topTouchEnd&#x27;:
    case &#x27;topTouchMove&#x27;:
    case &#x27;topTouchStart&#x27;:
      EventConstructor = SyntheticTouchEvent;
      break;
    case &#x27;topAnimationEnd&#x27;:
    case &#x27;topAnimationIteration&#x27;:
    case &#x27;topAnimationStart&#x27;:
      EventConstructor = SyntheticAnimationEvent;
      break;
    case &#x27;topTransitionEnd&#x27;:
      EventConstructor = SyntheticTransitionEvent;
      break;
    case &#x27;topScroll&#x27;:
      EventConstructor = SyntheticUIEvent;
      break;
    case &#x27;topWheel&#x27;:
      EventConstructor = SyntheticWheelEvent;
      break;
    case &#x27;topCopy&#x27;:
    case &#x27;topCut&#x27;:
    case &#x27;topPaste&#x27;:
      EventConstructor = SyntheticClipboardEvent;
      break;
  }
  !EventConstructor ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;SimpleEventPlugin: Unhandled event type, `%s`.&#x27;,
topLevelType) : _prodInvariant(&#x27;86&#x27;, topLevelType) : void 0;
  var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SimpleEventPlugin.willDeleteListener" id="apidoc.element.react-test-renderer.SimpleEventPlugin.willDeleteListener">
        function <span class="apidocSignatureSpan">react-test-renderer.SimpleEventPlugin.</span>willDeleteListener
        <span class="apidocSignatureSpan">(inst, registrationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">willDeleteListener = function (inst, registrationName) {
  if (registrationName === &#x27;onClick&#x27; &#x26;&#x26; !isInteractive(inst._tag)) {
    var key = getDictionaryKey(inst);
    onClickListeners[key].remove();
    delete onClickListeners[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
if (PluginModule &#x26;&#x26; PluginModule.willDeleteListener) {
  PluginModule.<span class="apidocCodeKeywordSpan">willDeleteListener</span>(inst, registrationName);
}

var bankForRegistrationName = listenerBank[registrationName];
// TODO: This should never be null -- when is it?
if (bankForRegistrationName) {
  var key = getDictionaryKey(inst);
  delete bankForRegistrationName[key];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticAnimationEvent" id="apidoc.module.react-test-renderer.SyntheticAnimationEvent">module react-test-renderer.SyntheticAnimationEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.SyntheticAnimationEvent" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent.SyntheticAnimationEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticAnimationEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.release" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticAnimationEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticAnimationEvent.prototype">module react-test-renderer.SyntheticAnimationEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticAnimationEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticAnimationEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticAnimationEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticClipboardEvent" id="apidoc.module.react-test-renderer.SyntheticClipboardEvent">module react-test-renderer.SyntheticClipboardEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.SyntheticClipboardEvent" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent.SyntheticClipboardEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticClipboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.release" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticClipboardEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticClipboardEvent.prototype">module react-test-renderer.SyntheticClipboardEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticClipboardEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticClipboardEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticClipboardEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticCompositionEvent" id="apidoc.module.react-test-renderer.SyntheticCompositionEvent">module react-test-renderer.SyntheticCompositionEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.SyntheticCompositionEvent" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent.SyntheticCompositionEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticCompositionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.release" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticCompositionEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticCompositionEvent.prototype">module react-test-renderer.SyntheticCompositionEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticCompositionEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticCompositionEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticCompositionEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticDragEvent" id="apidoc.module.react-test-renderer.SyntheticDragEvent">module react-test-renderer.SyntheticDragEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent.SyntheticDragEvent" id="apidoc.element.react-test-renderer.SyntheticDragEvent.SyntheticDragEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticDragEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticDragEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticDragEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent.release" id="apidoc.element.react-test-renderer.SyntheticDragEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticDragEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticDragEvent.prototype">module react-test-renderer.SyntheticDragEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticDragEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticDragEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticDragEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticEvent" id="apidoc.module.react-test-renderer.SyntheticEvent">module react-test-renderer.SyntheticEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.SyntheticEvent" id="apidoc.element.react-test-renderer.SyntheticEvent.SyntheticEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticEvent
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.release" id="apidoc.element.react-test-renderer.SyntheticEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticEvent.prototype">module react-test-renderer.SyntheticEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.destructor" id="apidoc.element.react-test-renderer.SyntheticEvent.prototype.destructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>destructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destructor = function () {
  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (process.env.NODE_ENV !== &#x27;production&#x27;) {
      Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
    } else {
      this[propName] = null;
    }
  }
  for (var i = 0; i &#x3c; shouldBeReleasedProperties.length; i++) {
    this[shouldBeReleasedProperties[i]] = null;
  }
  if (process.env.NODE_ENV !== &#x27;production&#x27;) {
    Object.defineProperty(this, &#x27;nativeEvent&#x27;, getPooledWarningPropertyDefinition(&#x27;nativeEvent&#x27;, null));
    Object.defineProperty(this, &#x27;preventDefault&#x27;, getPooledWarningPropertyDefinition(&#x27;preventDefault&#x27;, emptyFunction));
    Object.defineProperty(this, &#x27;stopPropagation&#x27;, getPooledWarningPropertyDefinition(&#x27;stopPropagation&#x27;, emptyFunction));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance
 into a pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.<span class="apidocCodeKeywordSpan">destructor</span>();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.isPersistent" id="apidoc.element.react-test-renderer.SyntheticEvent.prototype.isPersistent">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>isPersistent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPersistent = function () {
  return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.<span class="apidocCodeKeywordSpan">isPersistent</span>()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.persist" id="apidoc.element.react-test-renderer.SyntheticEvent.prototype.persist">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>persist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">persist = function () {
  this.isPersistent = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var result = isFunction ? &#x27;This is a no-op function&#x27; : &#x27;This is set to null&#x27;;
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(warningCondition, &#x27;This synthetic event is reused for performance
 reasons. If you\&#x27;re seeing this, &#x27; + &#x27;you\&#x27;re %s `%s` on a released/nullified synthetic event. %s. &#x27; + &#x27;If you must keep the original synthetic event around, use event.<span class="apidocCodeKeywordSpan">persist</span>(). &#x27; + &#x27;See https://fb.me/react-event-pooling for more information.&#x27;, action, propName, result) : void 0;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.preventDefault" id="apidoc.element.react-test-renderer.SyntheticEvent.prototype.preventDefault">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>preventDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preventDefault = function () {
  this.defaultPrevented = true;
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.preventDefault) {
    event.preventDefault();
  } else if (typeof event.returnValue !== &#x27;unknown&#x27;) {
    // eslint-disable-line valid-typeof
    event.returnValue = false;
  }
  this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.defaultPrevented = true;
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.preventDefault) {
    event.<span class="apidocCodeKeywordSpan">preventDefault</span>();
  } else if (typeof event.returnValue !== &#x27;unknown&#x27;) {
    // eslint-disable-line valid-typeof
    event.returnValue = false;
  }
  this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticEvent.prototype.stopPropagation" id="apidoc.element.react-test-renderer.SyntheticEvent.prototype.stopPropagation">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticEvent.prototype.</span>stopPropagation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopPropagation = function () {
  var event = this.nativeEvent;
  if (!event) {
    return;
  }

  if (event.stopPropagation) {
    event.stopPropagation();
  } else if (typeof event.cancelBubble !== &#x27;unknown&#x27;) {
    // eslint-disable-line valid-typeof
    // The ChangeEventPlugin registers a &#x22;propertychange&#x22; event for
    // IE. This event does not support bubbling or cancelling, and
    // any references to cancelBubble throw &#x22;Member not found&#x22;.  A
    // typeof check of &#x22;unknown&#x22; circumvents this issue (and is also
    // IE specific).
    event.cancelBubble = true;
  }

  this.isPropagationStopped = emptyFunction.thatReturnsTrue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  stopPropagation: function () {
var event = this.nativeEvent;
if (!event) {
  return;
}

if (event.stopPropagation) {
  event.<span class="apidocCodeKeywordSpan">stopPropagation</span>();
} else if (typeof event.cancelBubble !== &#x27;unknown&#x27;) {
  // eslint-disable-line valid-typeof
  // The ChangeEventPlugin registers a &#x22;propertychange&#x22; event for
  // IE. This event does not support bubbling or cancelling, and
  // any references to cancelBubble throw &#x22;Member not found&#x22;.  A
  // typeof check of &#x22;unknown&#x22; circumvents this issue (and is also
  // IE specific).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticFocusEvent" id="apidoc.module.react-test-renderer.SyntheticFocusEvent">module react-test-renderer.SyntheticFocusEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.SyntheticFocusEvent" id="apidoc.element.react-test-renderer.SyntheticFocusEvent.SyntheticFocusEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticFocusEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticFocusEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticFocusEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.release" id="apidoc.element.react-test-renderer.SyntheticFocusEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticFocusEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticFocusEvent.prototype">module react-test-renderer.SyntheticFocusEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticFocusEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticFocusEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticFocusEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticInputEvent" id="apidoc.module.react-test-renderer.SyntheticInputEvent">module react-test-renderer.SyntheticInputEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent.SyntheticInputEvent" id="apidoc.element.react-test-renderer.SyntheticInputEvent.SyntheticInputEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticInputEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticInputEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticInputEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent.release" id="apidoc.element.react-test-renderer.SyntheticInputEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticInputEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticInputEvent.prototype">module react-test-renderer.SyntheticInputEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticInputEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticInputEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticInputEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticKeyboardEvent" id="apidoc.module.react-test-renderer.SyntheticKeyboardEvent">module react-test-renderer.SyntheticKeyboardEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.SyntheticKeyboardEvent" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent.SyntheticKeyboardEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticKeyboardEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.release" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticKeyboardEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticKeyboardEvent.prototype">module react-test-renderer.SyntheticKeyboardEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticKeyboardEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticKeyboardEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticKeyboardEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticMouseEvent" id="apidoc.module.react-test-renderer.SyntheticMouseEvent">module react-test-renderer.SyntheticMouseEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.SyntheticMouseEvent" id="apidoc.element.react-test-renderer.SyntheticMouseEvent.SyntheticMouseEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticMouseEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticMouseEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticMouseEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.release" id="apidoc.element.react-test-renderer.SyntheticMouseEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticMouseEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticMouseEvent.prototype">module react-test-renderer.SyntheticMouseEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticMouseEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticMouseEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticMouseEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticTouchEvent" id="apidoc.module.react-test-renderer.SyntheticTouchEvent">module react-test-renderer.SyntheticTouchEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.SyntheticTouchEvent" id="apidoc.element.react-test-renderer.SyntheticTouchEvent.SyntheticTouchEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTouchEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticTouchEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticTouchEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.release" id="apidoc.element.react-test-renderer.SyntheticTouchEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticTouchEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticTouchEvent.prototype">module react-test-renderer.SyntheticTouchEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTouchEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticTouchEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTouchEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticTransitionEvent" id="apidoc.module.react-test-renderer.SyntheticTransitionEvent">module react-test-renderer.SyntheticTransitionEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.SyntheticTransitionEvent" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent.SyntheticTransitionEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticTransitionEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.release" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticTransitionEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticTransitionEvent.prototype">module react-test-renderer.SyntheticTransitionEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticTransitionEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticTransitionEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticTransitionEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticUIEvent" id="apidoc.module.react-test-renderer.SyntheticUIEvent">module react-test-renderer.SyntheticUIEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent.SyntheticUIEvent" id="apidoc.element.react-test-renderer.SyntheticUIEvent.SyntheticUIEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticUIEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticUIEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticUIEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent.release" id="apidoc.element.react-test-renderer.SyntheticUIEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticUIEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticUIEvent.prototype">module react-test-renderer.SyntheticUIEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticUIEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticUIEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticUIEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticWheelEvent" id="apidoc.module.react-test-renderer.SyntheticWheelEvent">module react-test-renderer.SyntheticWheelEvent</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.SyntheticWheelEvent" id="apidoc.element.react-test-renderer.SyntheticWheelEvent.SyntheticWheelEvent">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>SyntheticWheelEvent
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.augmentClass" id="apidoc.element.react-test-renderer.SyntheticWheelEvent.augmentClass">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>augmentClass
        <span class="apidocSignatureSpan">(Class, Interface)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} nativeEvent Native event.
 * @extends {SyntheticEvent}
 */
function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.<span class="apidocCodeKeywordSpan">augmentClass</span>(ResponderSyntheticEvent, ResponderEventInterface);

module.exports = ResponderSyntheticEvent;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.getPooled" id="apidoc.element.react-test-renderer.SyntheticWheelEvent.getPooled">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>getPooled
        <span class="apidocSignatureSpan">(a1, a2, a3, a4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPooled = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var invariant = require(&#x27;fbjs/lib/invariant&#x27;);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.<span class="apidocCodeKeywordSpan">getPooled</span>()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.release" id="apidoc.element.react-test-renderer.SyntheticWheelEvent.release">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.</span>release
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">release = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Trying to release an instance into a
pool of a different type.&#x27;) : _prodInvariant(&#x27;25&#x27;) : void 0;
  instance.destructor();
  if (Klass.instancePool.length &#x3c; Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.<span class="apidocCodeKeywordSpan">release</span>(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.SyntheticWheelEvent.prototype" id="apidoc.module.react-test-renderer.SyntheticWheelEvent.prototype">module react-test-renderer.SyntheticWheelEvent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.SyntheticWheelEvent.prototype.constructor" id="apidoc.element.react-test-renderer.SyntheticWheelEvent.prototype.constructor">
        function <span class="apidocSignatureSpan">react-test-renderer.SyntheticWheelEvent.prototype.</span>constructor
        <span class="apidocSignatureSpan">(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.TapEventPlugin" id="apidoc.module.react-test-renderer.TapEventPlugin">module react-test-renderer.TapEventPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.TapEventPlugin.extractEvents" id="apidoc.element.react-test-renderer.TapEventPlugin.extractEvents">
        function <span class="apidocSignatureSpan">react-test-renderer.TapEventPlugin.</span>extractEvents
        <span class="apidocSignatureSpan">(topLevelType, targetInst, nativeEvent, nativeEventTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractEvents = function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  if (!isStartish(topLevelType) &#x26;&#x26; !isEndish(topLevelType)) {
    return null;
  }
  // on ios, there is a delay after touch event and synthetic
  // mouse events, so that user can perform double tap
  // solution: ignore mouse events following touchevent within small timeframe
  if (touchEvents.indexOf(topLevelType) !== -1) {
    usedTouch = true;
    usedTouchTime = Date.now();
  } else {
    if (usedTouch &#x26;&#x26; Date.now() - usedTouchTime &#x3c; TOUCH_DELAY) {
      return null;
    }
  }
  var event = null;
  var distance = getDistance(startCoords, nativeEvent);
  if (isEndish(topLevelType) &#x26;&#x26; distance &#x3c; tapMoveThreshold) {
    event = SyntheticUIEvent.getPooled(eventTypes.touchTap, targetInst, nativeEvent, nativeEventTarget);
  }
  if (isStartish(topLevelType)) {
    startCoords.x = getAxisCoordOfEvent(Axis.x, nativeEvent);
    startCoords.y = getAxisCoordOfEvent(Axis.y, nativeEvent);
  } else if (isEndish(topLevelType)) {
    startCoords.x = 0;
    startCoords.y = 0;
  }
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  var plugins = EventPluginRegistry.plugins;
  for (var i = 0; i &#x3c; plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.<span class="apidocCodeKeywordSpan">extractEvents</span>(topLevelType, targetInst, nativeEvent
, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.TouchHistoryMath" id="apidoc.module.react-test-renderer.TouchHistoryMath">module react-test-renderer.TouchHistoryMath</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.centroidDimension" id="apidoc.element.react-test-renderer.TouchHistoryMath.centroidDimension">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>centroidDimension
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter, isXAxis, ofCurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">centroidDimension = function (touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
  var touchBank = touchHistory.touchBank;
  var total = 0;
  var count = 0;

  var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null
;

  if (oneTouchData !== null) {
    if (oneTouchData.touchActive &#x26;&#x26; oneTouchData.currentTimeStamp &#x3e; touchesChangedAfter) {
      total += ofCurrent &#x26;&#x26; isXAxis ? oneTouchData.currentPageX : ofCurrent &#x26;&#x26; !isXAxis ? oneTouchData.currentPageY : !ofCurrent
 &#x26;&#x26; isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
      count = 1;
    }
  } else {
    for (var i = 0; i &#x3c; touchBank.length; i++) {
      var touchTrack = touchBank[i];
      if (touchTrack !== null &#x26;&#x26; touchTrack !== undefined &#x26;&#x26; touchTrack.touchActive &#x26;&#x26; touchTrack.currentTimeStamp &#x3e;= touchesChangedAfter
) {
        var toAdd; // Yuck, program temporarily in invalid state.
        if (ofCurrent &#x26;&#x26; isXAxis) {
          toAdd = touchTrack.currentPageX;
        } else if (ofCurrent &#x26;&#x26; !isXAxis) {
          toAdd = touchTrack.currentPageY;
        } else if (!ofCurrent &#x26;&#x26; isXAxis) {
          toAdd = touchTrack.previousPageX;
        } else {
          toAdd = touchTrack.previousPageY;
        }
        total += toAdd;
        count++;
      }
    }
  }
  return count &#x3e; 0 ? total / count : TouchHistoryMath.noCentroid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
  }
  return count &#x3e; 0 ? total / count : TouchHistoryMath.noCentroid;
},

currentCentroidXOfTouchesChangedAfter: function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.<span class="apidocCodeKeywordSpan">centroidDimension</span>(touchHistory, touchesChangedAfter, true, //
isXAxis
  true // ofCurrent
  );
},

currentCentroidYOfTouchesChangedAfter: function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  true // ofCurrent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidX" id="apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidX">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidX
        <span class="apidocSignatureSpan">(touchHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidX = function (touchHistory) {
  return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
  true, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter" id="apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidXOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidXOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidXOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidY" id="apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidY">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidY
        <span class="apidocSignatureSpan">(touchHistory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidY = function (touchHistory) {
  return TouchHistoryMath.centroidDimension(touchHistory, 0, // touchesChangedAfter
  false, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter" id="apidoc.element.react-test-renderer.TouchHistoryMath.currentCentroidYOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>currentCentroidYOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCentroidYOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  true // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter" id="apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidXOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>previousCentroidXOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previousCentroidXOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, // isXAxis
  false // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter" id="apidoc.element.react-test-renderer.TouchHistoryMath.previousCentroidYOfTouchesChangedAfter">
        function <span class="apidocSignatureSpan">react-test-renderer.TouchHistoryMath.</span>previousCentroidYOfTouchesChangedAfter
        <span class="apidocSignatureSpan">(touchHistory, touchesChangedAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previousCentroidYOfTouchesChangedAfter = function (touchHistory, touchesChangedAfter) {
  return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, // isXAxis
  false // ofCurrent
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.Transaction" id="apidoc.module.react-test-renderer.Transaction">module react-test-renderer.Transaction</a></h1>




    <h2>
        <a href="#apidoc.element.react-test-renderer.Transaction.closeAll" id="apidoc.element.react-test-renderer.Transaction.closeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>closeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAll = function (startIndex) {
  !this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.closeAll(): Cannot close transaction
 when none are open.&#x27;) : _prodInvariant(&#x27;28&#x27;) : void 0;
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    var initData = this.wrapperInitData[i];
    var errorThrown;
    try {
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it&#x27;s still set to true in the finally block, it means
      // wrapper.close threw.
      errorThrown = true;
      if (initData !== OBSERVED_ERROR &#x26;&#x26; wrapper.close) {
        wrapper.close.call(this, initData);
      }
      errorThrown = false;
    } finally {
      if (errorThrown) {
        // The closer for wrapper i threw an error; close the remaining
        // wrappers but silence any exceptions from them to ensure that the
        // first error is the one to bubble up.
        try {
          this.closeAll(i + 1);
        } catch (e) {}
      }
    }
  }
  this.wrapperInitData.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
      try {
        this.<span class="apidocCodeKeywordSpan">closeAll</span>(0);
      } catch (err) {}
    } else {
      // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
      // here.
      this.closeAll(0);
    }
  } finally {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.Transaction.initializeAll" id="apidoc.element.react-test-renderer.Transaction.initializeAll">
        function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>initializeAll
        <span class="apidocSignatureSpan">(startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeAll = function (startIndex) {
  var transactionWrappers = this.transactionWrappers;
  for (var i = startIndex; i &#x3c; transactionWrappers.length; i++) {
    var wrapper = transactionWrappers[i];
    try {
      // Catching errors makes debugging more difficult, so we start with the
      // OBSERVED_ERROR state before overwriting it with the real return value
      // of initialize -- if it&#x27;s still set to OBSERVED_ERROR in the finally
      // block, it means wrapper.initialize threw.
      this.wrapperInitData[i] = OBSERVED_ERROR;
      this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
    } finally {
      if (this.wrapperInitData[i] === OBSERVED_ERROR) {
        // The initializer for wrapper i threw an error; initialize the
        // remaining wrappers but silence any exceptions from them to ensure
        // that the first error is the one to bubble up.
        try {
          this.initializeAll(i + 1);
        } catch (err) {}
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  this._isInTransaction = true;
  // Catching errors makes debugging more difficult, so we start with
  // errorThrown set to true before setting it to false after calling
  // close -- if it&#x27;s still set to true in the finally block, it means
  // one of these calls threw.
  errorThrown = true;
  this.<span class="apidocCodeKeywordSpan">initializeAll</span>(0);
  ret = method.call(scope, a, b, c, d, e, f);
  errorThrown = false;
} finally {
  try {
    if (errorThrown) {
      // If `method` throws, prefer to show that stack trace over any thrown
      // by invoking `closeAll`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.Transaction.isInTransaction" id="apidoc.element.react-test-renderer.Transaction.isInTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>isInTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInTransaction = function () {
  return !!this._isInTransaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object?=} d Argument to pass to the method.
 * @param {Object?=} e Argument to pass to the method.
 * @param {Object?=} f Argument to pass to the method.
 *
 * @return {*} Return value from `method`.
 */
perform: function (method, scope, a, b, c, d, e, f) {
  !!this.<span class="apidocCodeKeywordSpan">isInTransaction</span>() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant
(false, &#x27;Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.&#x27;) :
_prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.Transaction.perform" id="apidoc.element.react-test-renderer.Transaction.perform">
        function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>perform
        <span class="apidocSignatureSpan">(method, scope, a, b, c, d, e, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perform = function (method, scope, a, b, c, d, e, f) {
  !!this.isInTransaction() ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;Transaction.perform(...): Cannot initialize
 a transaction when there is already an outstanding transaction.&#x27;) : _prodInvariant(&#x27;27&#x27;) : void 0;
  var errorThrown;
  var ret;
  try {
    this._isInTransaction = true;
    // Catching errors makes debugging more difficult, so we start with
    // errorThrown set to true before setting it to false after calling
    // close -- if it&#x27;s still set to true in the finally block, it means
    // one of these calls threw.
    errorThrown = true;
    this.initializeAll(0);
    ret = method.call(scope, a, b, c, d, e, f);
    errorThrown = false;
  } finally {
    try {
      if (errorThrown) {
        // If `method` throws, prefer to show that stack trace over any thrown
        // by invoking `closeAll`.
        try {
          this.closeAll(0);
        } catch (err) {}
      } else {
        // Since `method` didn&#x27;t throw, we don&#x27;t want to silence the exception
        // here.
        this.closeAll(0);
      }
    } finally {
      this._isInTransaction = false;
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.<span class="apidocCodeKeywordSpan">perform</span>(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.Transaction.reinitializeTransaction" id="apidoc.element.react-test-renderer.Transaction.reinitializeTransaction">
        function <span class="apidocSignatureSpan">react-test-renderer.Transaction.</span>reinitializeTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reinitializeTransaction = function () {
  this.transactionWrappers = this.getTransactionWrappers();
  if (this.wrapperInitData) {
    this.wrapperInitData.length = 0;
  } else {
    this.wrapperInitData = [];
  }
  this._isInTransaction = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.<span class="apidocCodeKeywordSpan">reinitializeTransaction</span>();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.ViewportMetrics" id="apidoc.module.react-test-renderer.ViewportMetrics">module react-test-renderer.ViewportMetrics</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.ViewportMetrics.refreshScrollValues" id="apidoc.element.react-test-renderer.ViewportMetrics.refreshScrollValues">
        function <span class="apidocSignatureSpan">react-test-renderer.ViewportMetrics.</span>refreshScrollValues
        <span class="apidocSignatureSpan">(scrollPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshScrollValues = function (scrollPosition) {
  ViewportMetrics.currentScrollLeft = scrollPosition.x;
  ViewportMetrics.currentScrollTop = scrollPosition.y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.shallow" id="apidoc.module.react-test-renderer.shallow">module react-test-renderer.shallow</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.shallow" id="apidoc.element.react-test-renderer.shallow.shallow">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>shallow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);

  this._instance = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.createRenderer" id="apidoc.element.react-test-renderer.shallow.createRenderer">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.</span>createRenderer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createRenderer = function () {
  return new ReactShallowRenderer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.shallow.prototype" id="apidoc.module.react-test-renderer.shallow.prototype">module react-test-renderer.shallow.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype._render" id="apidoc.element.react-test-renderer.shallow.prototype._render">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>_render
        <span class="apidocSignatureSpan">(element, transaction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _render(element, transaction, context) {
  if (this._instance) {
    ReactReconciler.receiveComponent(this._instance, element, transaction, context);
  } else {
    var instance = new ShallowComponentWrapper(element);
    ReactReconciler.mountComponent(instance, transaction, null, null, context, 0);
    this._instance = instance;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},
_replaceNodeWithMarkup: function () {},
_renderValidatedComponent: ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext
});

function _batchedRender(renderer, element, context) {
var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
renderer.<span class="apidocCodeKeywordSpan">_render</span>(element, transaction, context);
ReactUpdates.ReactReconcileTransaction.release(transaction);
}

var ReactShallowRenderer = function () {
function ReactShallowRenderer() {
  _classCallCheck(this, ReactShallowRenderer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype.getMountedInstance" id="apidoc.element.react-test-renderer.shallow.prototype.getMountedInstance">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>getMountedInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMountedInstance() {
  return this._instance ? this._instance._instance : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype.getRenderOutput" id="apidoc.element.react-test-renderer.shallow.prototype.getRenderOutput">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>getRenderOutput
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRenderOutput() {
  return this._instance &#x26;&#x26; this._instance._renderedComponent &#x26;&#x26; this._instance._renderedComponent._renderedOutput || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```jsx
const ReactShallowRenderer = require(&#x27;react-test-renderer/shallow&#x27;);

const renderer = new ReactShallowRenderer();
renderer.render(&#x3c;MyComponent /&#x3e;);

const result = renderer.<span class="apidocCodeKeywordSpan">getRenderOutput</span>();
expect(result.type).toBe(&#x27;div&#x27;);
expect(result.props.children).toEqual([
  &#x3c;span className=&#x22;heading&#x22;&#x3e;Title&#x3c;/span&#x3e;,
  &#x3c;Subcomponent foo=&#x22;bar&#x22; /&#x3e;
]);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype.render" id="apidoc.element.react-test-renderer.shallow.prototype.render">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>render
        <span class="apidocSignatureSpan">(element, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function render(element, context) {
  // Ensure we&#x27;ve done the default injections. This might not be true in the
  // case of a simple test that only requires React and the TestUtils in
  // conjunction with an inline-requires transform.
  injectDefaults();

  !React.isValidElement(element) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactShallowRenderer render(): Invalid
 component element.%s&#x27;, typeof element === &#x27;function&#x27; ? &#x27; Instead of passing a component class, make sure to instantiate &#x27; + &#x27;it
 by passing it to React.createElement.&#x27; : &#x27;&#x27;) : _prodInvariant(&#x27;12&#x27;, typeof element === &#x27;function&#x27; ? &#x27; Instead of passing a component
 class, make sure to instantiate &#x27; + &#x27;it by passing it to React.createElement.&#x27; : &#x27;&#x27;) : void 0;
  !(typeof element.type !== &#x27;string&#x27;) ? process.env.NODE_ENV !== &#x27;production&#x27; ? invariant(false, &#x27;ReactShallowRenderer render():
Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting the rendered
 output, look at `el.props` directly instead.&#x27;, element.type) : _prodInvariant(&#x27;13&#x27;, element.type) : void 0;

  if (!context) {
    context = emptyObject;
  }
  ReactUpdates.batchedUpdates(_batchedRender, this, element, context);

  return this.getRenderOutput();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Shallow rendering lets you render a component &#x22;one level deep&#x22; and assert facts about what its render method returns,
without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.

```jsx
const ReactShallowRenderer = require(&#x27;react-test-renderer/shallow&#x27;);

const renderer = new ReactShallowRenderer();
renderer.<span class="apidocCodeKeywordSpan">render</span>(&#x3c;MyComponent /&#x3e;);

const result = renderer.getRenderOutput();
expect(result.type).toBe(&#x27;div&#x27;);
expect(result.props.children).toEqual([
  &#x3c;span className=&#x22;heading&#x22;&#x3e;Title&#x3c;/span&#x3e;,
  &#x3c;Subcomponent foo=&#x22;bar&#x22; /&#x3e;
]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype.unmount" id="apidoc.element.react-test-renderer.shallow.prototype.unmount">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>unmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmount() {
  if (this._instance) {
    ReactReconciler.unmountComponent(this._instance, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.shallow.prototype.unstable_batchedUpdates" id="apidoc.element.react-test-renderer.shallow.prototype.unstable_batchedUpdates">
        function <span class="apidocSignatureSpan">react-test-renderer.shallow.prototype.</span>unstable_batchedUpdates
        <span class="apidocSignatureSpan">(callback, bookkeeping)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unstable_batchedUpdates(callback, bookkeeping) {
  // This is used by Enzyme for fake-simulating events in shallow mode.
  injectDefaults();
  return ReactUpdates.batchedUpdates(callback, bookkeeping);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-test-renderer.validateDOMNesting" id="apidoc.module.react-test-renderer.validateDOMNesting">module react-test-renderer.validateDOMNesting</a></h1>


    <h2>
        <a href="#apidoc.element.react-test-renderer.validateDOMNesting.validateDOMNesting" id="apidoc.element.react-test-renderer.validateDOMNesting.validateDOMNesting">
        function <span class="apidocSignatureSpan">react-test-renderer.</span>validateDOMNesting
        <span class="apidocSignatureSpan">(childTag, childText, childInstance, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &#x26;&#x26; parentInfo.tag;

  if (childText != null) {
    process.env.NODE_ENV !== &#x27;production&#x27; ? warning(childTag == null, &#x27;validateDOMNesting: when childText is passed, childTag should
 be null&#x27;) : void 0;
    childTag = &#x27;#text&#x27;;
  }

  var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
  var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
  var problematic = invalidParent || invalidAncestor;

  if (problematic) {
    var ancestorTag = problematic.tag;
    var ancestorInstance = problematic.instance;

    var childOwner = childInstance &#x26;&#x26; childInstance._currentElement._owner;
    var ancestorOwner = ancestorInstance &#x26;&#x26; ancestorInstance._currentElement._owner;

    var childOwners = findOwnerStack(childOwner);
    var ancestorOwners = findOwnerStack(ancestorOwner);

    var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
    var i;

    var deepestCommon = -1;
    for (i = 0; i &#x3c; minStackLen; i++) {
      if (childOwners[i] === ancestorOwners[i]) {
        deepestCommon = i;
      } else {
        break;
      }
    }

    var UNKNOWN = &#x27;(unknown)&#x27;;
    var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
      return inst.getName() || UNKNOWN;
    });
    var ownerInfo = [].concat(
    // If the parent and child instances have a common owner ancestor, start
    // with that -- otherwise we just start with the parent&#x27;s owners.
    deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
    // If we&#x27;re warning about an invalid (non-parent) ancestry, add &#x27;...&#x27;
    invalidAncestor ? [&#x27;...&#x27;] : [], childOwnerNames, childTag).join(&#x27; &#x3e; &#x27;);

    var warnKey = !!invalidParent + &#x27;|&#x27; + childTag + &#x27;|&#x27; + ancestorTag + &#x27;|&#x27; + ownerInfo;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = &#x27;&#x27;;
    if (childTag === &#x27;#text&#x27;) {
      if (/\S/.test(childText)) {
        tagDisplayName = &#x27;Text nodes&#x27;;
      } else {
        tagDisplayName = &#x27;Whitespace text nodes&#x27;;
        whitespaceInfo = &#x27; Make sure you don\&#x27;t have any extra whitespace between tags on &#x27; + &#x27;each line of your source code.&#x27;;
      }
    } else {
      tagDisplayName = &#x27;&#x3c;&#x27; + childTag + &#x27;&#x3e;&#x27;;
    }

    if (invalidParent) {
      var info = &#x27;&#x27;;
      if (ancestorTag === &#x27;table&#x27; &#x26;&#x26; childTag === &#x27;tr&#x27;) {
        info += &#x27; Add a &#x3c;tbody&#x3e; to your code to match the DOM tree generated by &#x27; + &#x27;the browser.&#x27;;
      }
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;validateDOMNesting(...): %s cannot appear as a child of &#x3c;%s&#x3e;.%s &#x27; + &#x27;
See %s.%s&#x27;, tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
    } else {
      process.env.NODE_ENV !== &#x27;production&#x27; ? warning(false, &#x27;validateDOMNesting(...): %s cannot appear as a descendant of &#x27; + &#x27;&#x3c;%
s&#x3e;. See %s.&#x27;, tagDisplayName, ancestorTag, ownerInfo) : void 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.validateDOMNesting.isTagValidInContext" id="apidoc.element.react-test-renderer.validateDOMNesting.isTagValidInContext">
        function <span class="apidocSignatureSpan">react-test-renderer.validateDOMNesting.</span>isTagValidInContext
        <span class="apidocSignatureSpan">(tag, ancestorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTagValidInContext = function (tag, ancestorInfo) {
  ancestorInfo = ancestorInfo || emptyAncestorInfo;
  var parentInfo = ancestorInfo.current;
  var parentTag = parentInfo &#x26;&#x26; parentInfo.tag;
  return isTagValidWithParent(tag, parentTag) &#x26;&#x26; !findInvalidAncestorForTag(tag, ancestorInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-test-renderer.validateDOMNesting.updatedAncestorInfo" id="apidoc.element.react-test-renderer.validateDOMNesting.updatedAncestorInfo">
        function <span class="apidocSignatureSpan">react-test-renderer.validateDOMNesting.</span>updatedAncestorInfo
        <span class="apidocSignatureSpan">(oldInfo, tag, instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatedAncestorInfo = function (oldInfo, tag, instance) {
  var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
  var info = { tag: tag, instance: instance };

  if (inScopeTags.indexOf(tag) !== -1) {
    ancestorInfo.aTagInScope = null;
    ancestorInfo.buttonTagInScope = null;
    ancestorInfo.nobrTagInScope = null;
  }
  if (buttonScopeTags.indexOf(tag) !== -1) {
    ancestorInfo.pTagInButtonScope = null;
  }

  // See rules for &#x27;li&#x27;, &#x27;dd&#x27;, &#x27;dt&#x27; start tags in
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
  if (specialTags.indexOf(tag) !== -1 &#x26;&#x26; tag !== &#x27;address&#x27; &#x26;&#x26; tag !== &#x27;div&#x27; &#x26;&#x26; tag !== &#x27;p&#x27;) {
    ancestorInfo.listItemTagAutoclosing = null;
    ancestorInfo.dlItemTagAutoclosing = null;
  }

  ancestorInfo.current = info;

  if (tag === &#x27;form&#x27;) {
    ancestorInfo.formTag = info;
  }
  if (tag === &#x27;a&#x27;) {
    ancestorInfo.aTagInScope = info;
  }
  if (tag === &#x27;button&#x27;) {
    ancestorInfo.buttonTagInScope = info;
  }
  if (tag === &#x27;nobr&#x27;) {
    ancestorInfo.nobrTagInScope = info;
  }
  if (tag === &#x27;p&#x27;) {
    ancestorInfo.pTagInButtonScope = info;
  }
  if (tag === &#x27;li&#x27;) {
    ancestorInfo.listItemTagAutoclosing = info;
  }
  if (tag === &#x27;dd&#x27; || tag === &#x27;dt&#x27;) {
    ancestorInfo.dlItemTagAutoclosing = info;
  }

  return ancestorInfo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    parentInfo = hostContainerInfo._ancestorInfo;
  }
  if (parentInfo) {
    // parentInfo should always be present except for the top-level
    // component when server rendering
    validateDOMNesting(this._tag, null, this, parentInfo);
  }
  this._ancestorInfo = validateDOMNesting.<span class="apidocCodeKeywordSpan">updatedAncestorInfo</span>(parentInfo, this._tag,
this);
}

var mountImage;
if (transaction.useCreateElement) {
  var ownerDocument = hostContainerInfo._ownerDocument;
  var el;
  if (namespaceURI === DOMNamespaces.html) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
